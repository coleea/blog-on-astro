<!DOCTYPE html><html lang="ko"><head><link rel="stylesheet" href="/index.css"><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>LKB BLOG</title><meta name="title" content="LKB BLOG"><meta name="description" content=""><link rel="stylesheet" href="/_astro/common-ZEJS2I.css" type="text/css"><style type="text/css">astro-root, astro-fragment { display: contents; }</style></head><body><div class="wrapper astro-ldKR6c5M"><img id="logo" src="/icon_blog.png" height="50rem" class="astro-ldKR6c5M"><br class="astro-ldKR6c5M">
    LeeKb의 블로그
    <hr class="astro-ldKR6c5M"><astro-root uid="2nKi87"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211112_project_loom"><p class="title">자바진영의 프로젝트 룸(Project Loom)이란 무엇인가?</p></a></header><time>2021.11.12</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2nKi87", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "자바진영의 프로젝트 룸(Project Loom)이란 무엇인가?",
    "description": "JVM기반의 스케줄링 모델",
    "publishDate": "2021.11.12",
    "astro": {
      "headers": [{
        "depth": 2,
        "slug": "프로젝트-룸project-loom이란-무엇인가",
        "text": "프로젝트 룸(Project Loom)이란 무엇인가?"
      }],
      "source": "\r\n## 프로젝트 룸(Project Loom)이란 무엇인가?\r\n\r\n프로젝트 룸 (project loom)은 JVM 가상머신 기반의 스케줄링 메커니즘을 새로 구현하는 프로젝트이다. 얼랭(erlang)과 마찬가지로 동시성 패턴의 최적화를 목표로 한다\\\r\n\\\r\n이는 os의 관리하에 있었던 커널스레드 모델에서 가상머신이 관리하는 경량스레드 모델로의 전환으로 이루어진다.\\\r\n\\\r\n경량스레드라는 용어는 혼란을 줄 수 있는 용어인데 엄밀히 말하면 스레드가 아니기 때문이다. 스레드는 그저 OS가 관리하는 실행 흐름의 단위를 뜻한다. 하나의 어플리케이션에서 여러개의 실행흐름이 동시에 관리되어야 하는 상황이 있다. 네트워크와 통신하거나 유저의 입력을 기다리거나 UI를 새로 렌더링 하는 등 이런 여러개의 실행흐름을 동시에 관리하려는 목적으로 OS레벨에서 관리하는 실행흐름을 스레드 또는 커널스레드라고 한다\\\r\n\\\r\n그러면 경량스레드는 무엇인가 ? 이 또한 실행흐름의 단위이다. 스레드와 개념적으로는 거의 같다. 즉 여러개의 실행흐름이 동시에 관리되어야 하는 상황에서 사용한다. 다만 이러한 실행흐름이 OS단위에서 관리되지 않고 어플리케이션 레벨에서 관리된다. 자바의 예를 들면 JVM이라는 가상머신이 이러한 실행흐름의 관리자가 된다. 이 가상머신은 OS와 비슷한 개념으로 작동하는데 즉 자체 스케줄러를 별도로 가지게 되며 이 스케줄러에서 관리하는 자체의 실행흐름을 생성 및 관리한다.\\\r\n\\\r\n이것은 제네레이터라는 개념을 알고 있다면 이해가 쉽다. 가상머신 내부의 스케줄러가 제네레이터를 하나의 실행흐름 단위로 생성하여 생성, 호출, 중지, 재개하기 등의 작업을 종합적으로 컨트롤한다. 이렇게 하면 마치 OS에서 스레드를 사용하여 동시성을 관리하는 것과 거의 유사한 효과를 준다\\\r\n\\\r\n이러한 경량스레드라는 용어가 OS 스레드와 혼선을 줄 수 있음에도 경량스레드로 불리는 이유는 스레드와 기능적으로 거의 유사하기 때문이다. 이러한 혼선을 피하기 위한 목적으로 화이버(fiber)라는 용어가 고안되었다. 화이버는 경량스레드의 또다른 이름이다. 프로젝트 룸에서 화이버 모델은 컨티뉴에이션이라는 형태로 구현된다.\\\r\n\\\r\n사실 이전에도 자바 진영에서 화이버 모델을 구현하려는 시도는 있었다. 그린 스레드라는 이름으로도 유명한데 이 모델은 커널 스레드와 경량 스레드를 1:N 관계로 맵핑하여 경량 스레드를 스케줄링한다. 대략 아래와 같다\r\n\r\n<!-- ![img](../assets/blog/211112_project_loom/project_loom_1.png) -->\r\n![img](/assets/blog/211112_project_loom/project_loom_1.png)\r\n\r\n이 모델은 각 커널 스레드별로 별도의 스케줄러를 생성하여 경량스레드를 작업단위로 관리한다\\\r\n\\\r\n이 모델은 훌륭하지만 한계가 있다. 커널 스레드 단위로만 스케줄링이 가능하다는 점이다. 전체 가상머신 단위의 잡 스케줄링이 불가능하다. 프로젝트 룸은 이것을 실현하기 위한 프로젝트이다.\\\r\n\\\r\n즉 프로젝트 룸 기반의 경량스레드 모델은 커널 스레드와 경량 스레드를 N:N 관계로 스케줄링한다. 이 스케줄링의 주체는 가상머신이다. 그림으로 표현하면 아래와 같다\r\n\r\n![project_loom_2](/assets/blog/211112_project_loom/project_loom_2.jpg)\r\n\r\n이 모델은 특정한 경량스레드가 실행되어야 할 때 가장 최소의 컨텍스트 스위칭 비용이 발생하는 커널 스레드에게 작업을 위임할 수 있다. 이러한 스레드간의 N:N 모델은 그린스레드의 1:N 모델에 비하여 커널 스레드라는 자원을 훨씬 효율적으로 사용할 수 있다\\\r\n\\\r\n그리고 이 모델은 기존의 그린스레드가 가졌던 메모리 절감 효과도 그대로 가져온다. 하나의 루틴을 새로 생성한다고 가정해 보자. 이 때 고전적인 스레드 기반의 루틴을 새로 생성한다면 이들 스레드는 OS가 제공하는 커널 스레드이고 이 커널 스레드는 상당한 메모리 공간을 차지한다. 일단 이것은 메모리 효율성 측면에서 좋지않다.\\\r\n\\\r\n반면 화이버 기반에서는 OS가 아닌 가상머신이 경량스레드를 생성하는데 이 경량스레드는 커널스레드 대비 메타데이터 크기가 약 1/7에서 1/10 수준에 그친다. 아래는 프로젝트 룸의 테크니컬 리드가 말하는 커널스레드와 가상 스레드의 비교 데이터이다.\r\n\r\n<!-- assets\\blog\\211112_project_loom -->\r\n![img](/assets/blog/211112_project_loom/project_loom_3_mod.jpg)\r\n\r\n\r\n그림의 상단은 스레드가 차지하는 메타데이터 크기를 비교해놓았다. 이와는 별개로 그림 하단에는 컨텍스트 스위칭 시간을 비교해놓았다.\\\r\n\\\r\n컨텍스트 스위칭이란 활성 스레드가 기존의 작업을 중단하고 유휴 스레드에게 자원을 할당하여 새로운 작업을 시작하는 프로세스를 일컫는데 고전적인 모델에서는 이 컨텍스트 스위칭이 OS레벨에서 발생했다. 즉 컨텍스트 스위칭이 커널스레드 간에 스위칭하는 방식으로 구현되어 있다. 그런데 앞서 살펴봤듯이 커널스레드는 약 200kb 가량의 메타데이터를 가지며 추가로 1메가 가량의 스택 크기도 할당받는다. 이 메타데이터를 스위칭하고 새로운 작업을 준비하는 과정에서 약 1-10마이크로세컨드가 소모된다.\\\r\n\\\r\n이 시간이 사소해 보일지 모르겠지만 작업이 빈번하게 여러번 전환되는 상황에서는 어느정도 처리속도의 지연이 있다.\r\n반면 가상머신 기반의 컨텍스트 스위칭은 커널스레드에 기반하지 않는다. 이는 가상머신의 경량스레드에 기반하며 따라서 스케줄링되는 작업의 단위는 경량스레드, 즉 화이버이다. 화이버 단위의 컨텍스트 스위칭이 가능한 이유는 OS가 수행했던 스케줄링 작업을 가상머신이 대신 수행하기 때문이다\\\r\n\\\r\n당연하지만 컨텍스트 스위칭에 소모되는 시간은 스레드가 가진 메타데이터의 크기에 비례한다. 그런 관계로 훨씬 적은 메타데이터를 가진 경량스레드는 기존 컨텍스트 스위칭 대비 약 5~50배 빠른 전환 속도를 보여준다. 기존의 동시성 패턴대비 더나은 퍼포먼스와 더 적은 메모리 소모를 경험할 수 있다\\\r\n\\\r\n스케줄링의 권한이 OS가 아닌 응용프로그램에 위임될 때는 또다른 장점이 있다. 이것을 코틀린과 비교하여 설명해 보자. 코틀린의 컨티뉴에이션 루틴은 작업이 오래 지속될 시에 개발자가 원하는 타이밍에 작업을 취소되거나 작업순위을 뒤로 미룰 수 없다. 만일 특정한 작업이 자원을 선점하고 있어서 다른 화이버가 자원을 사용할 수 없는 기아상태가 지속된다면 그것이 OS 스케줄러 수준에서 관리된다.\\\r\n\\\r\n즉 OS스케줄러가 작업을 중단시키거나 작업순위를 뒤로 미루게 된다. 이것은 두가지 문제가 있다. 첫째로 얼마나 시간이 흐른 뒤에 작업을 중단시킬지 응용프로그램 수준에서 관리할 수 없다. 즉 스케줄링이 실행중인 OS에 전적으로 의존해야 하므로 당신이 OS커널 내부의 스케줄러를 수정하지 않는 이상은 실행흐름 관련 커스터마이징이 불가능하다. 리눅스 커널의 스케줄러를 개조하여 사용하는 경우가 있기는 하지만 이것은 상당한 전문지식과 수고로움을 필요로 한다. 두번째 문제는 내가 작업을 도중에 중단하고 싶지 않은 경우에도 OS스케줄러에 의해 강제적으로 재스케줄링이 될 수도 있다는 점이다. 종합하면 내가 원하는 스케줄링 정책을 적용할 수가 없다.\\\r\n\\\r\n그러나 가상머신 기반의 컨티뉴에이션 루틴은 스케줄링 정책을 개발자가 직접 설정할 수 있다. 만일 더 지연된 시간에 작업을 리스케줄링 하고 싶다면 그렇게 할 수 있고 중도에 리스케줄링을 원하지 않는다면 그렇게 할 수도 있다. 이것은 실행흐름을 실행할 때 `데드라인`을 설정하여 가능해진다. 가령 `withDeadline(30초)`라고 설정하여 실행흐름을 시작한다면 이 실행흐름의 최대 실행시간은 30초로 제한된다. 즉 응용프로그램 레벨에서 미세한 스케줄링 정책을 컨트롤할 수 있게 되었다\\\r\n\\\r\n그 외에 롬은 기존의 비동기함수 처리방식을 훨씬 간단하게 만든다. 이것을 설명하기 앞서 전염성이라는 개념을 이해할 필요가 있다.\\\r\n\\\r\n예를들어 어떤 메소드가 퓨처(Future)를 반환하면 이를 호출한 다른 메소드도 퓨처를 반환해야 하는데 이러한 방식은 퓨처가 포함된 콜스택을 통틀어 비동기 패러다임을 강제하는 문제를 야기한다.\r\n이것을 `함수의 색 문제`라고 하는데 동기 함수와 비동기 함수 사이에 거대한 벽이 있어 상호 연동이 쉽지 않은 문제를 말한다. 실제로 개발 시 동기 함수를 작성하고 있는 건지 비동기 함수를 작성하고 있는 건지 계속해서 의식하게 해야 하는 불편함이 발생한다.\\\r\n\\\r\n함수의 색 문제를 자세히 알고 싶다면 밥 니스트롬(Bob Nystrom)의 [당신 함수의 색은 무엇입니까?](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)(What Color is Your Function?) 문서를 참고해 보자.\\\r\n\\\r\n프로젝트 룸의 테크니컬 리드인 론 프레슬러는 이런 전염성이 기존 스레드 모델의 가장 큰 문제라고 말한다.\r\n만일 가상머신 기반의 경량스레드 모델을 사용한다면 이런 함수의 색 문제로부터 자유롭다. 즉 함수를 작성할 때 이전에 호출했던 함수가 동기인지 비동기인지를 체크할 필요가 없어진다. 그저 비동기 처리용 컨티뉴에이션을 생성하고 그즉시 yield를 수행하여 작업을 잠정 중단한 뒤에 비동기 처리용 컨티뉴에이션에서 비동기 작업이 종료되면 이전에 작업하던 컨티뉴에이션을 다시 호출하여 작업을 재개하면 되기 떄문이다. 따라서 프로젝트 룸이 프로덕션 레벨에 적용된다면 비동기 처리관련 코딩 스타일이 급변하게 되는것은 필연이다. 그리고 이것은 개발자를 더욱 편하게 만들어줄 것이다\\\r\n\\\r\n그 외에 프로젝트 룸은 꼬리재귀 최적화를 지원한다. 따라서 재귀함수가 꼬리재귀 기반으로 구현되었다면 더 빠른 처리 속도와 적은 메모리 사용이라는 이익을 볼 수 있다. 이로서 퍼포먼스의 눈치를 보지 않고도 꼬리재귀를 구현할 수 있는 환경이 마련되었다\r\n\r\n---\r\n\r\n참고자료\r\n\r\n론 프레슬러의 프로젝트 룸 소개 동영상 (론 프레슬러는 프로젝트 룸의 테크니컬 리드이다)\\\r\nhttps://www.youtube.com/watch?v=fOEPEXTpbJA\r\n\r\n자바 공식 문서 (Project Loom: JVM을 위한 화이버와 컨티뉴에이션)\\\r\nhttps://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html\r\n",
      "html": "<h2 id=\"프로젝트-룸project-loom이란-무엇인가\">프로젝트 룸(Project Loom)이란 무엇인가?</h2>\n<p>프로젝트 룸 (project loom)은 JVM 가상머신 기반의 스케줄링 메커니즘을 새로 구현하는 프로젝트이다. 얼랭(erlang)과 마찬가지로 동시성 패턴의 최적화를 목표로 한다<br>\n<br>\n이는 os의 관리하에 있었던 커널스레드 모델에서 가상머신이 관리하는 경량스레드 모델로의 전환으로 이루어진다.<br>\n<br>\n경량스레드라는 용어는 혼란을 줄 수 있는 용어인데 엄밀히 말하면 스레드가 아니기 때문이다. 스레드는 그저 OS가 관리하는 실행 흐름의 단위를 뜻한다. 하나의 어플리케이션에서 여러개의 실행흐름이 동시에 관리되어야 하는 상황이 있다. 네트워크와 통신하거나 유저의 입력을 기다리거나 UI를 새로 렌더링 하는 등 이런 여러개의 실행흐름을 동시에 관리하려는 목적으로 OS레벨에서 관리하는 실행흐름을 스레드 또는 커널스레드라고 한다<br>\n<br>\n그러면 경량스레드는 무엇인가 ? 이 또한 실행흐름의 단위이다. 스레드와 개념적으로는 거의 같다. 즉 여러개의 실행흐름이 동시에 관리되어야 하는 상황에서 사용한다. 다만 이러한 실행흐름이 OS단위에서 관리되지 않고 어플리케이션 레벨에서 관리된다. 자바의 예를 들면 JVM이라는 가상머신이 이러한 실행흐름의 관리자가 된다. 이 가상머신은 OS와 비슷한 개념으로 작동하는데 즉 자체 스케줄러를 별도로 가지게 되며 이 스케줄러에서 관리하는 자체의 실행흐름을 생성 및 관리한다.<br>\n<br>\n이것은 제네레이터라는 개념을 알고 있다면 이해가 쉽다. 가상머신 내부의 스케줄러가 제네레이터를 하나의 실행흐름 단위로 생성하여 생성, 호출, 중지, 재개하기 등의 작업을 종합적으로 컨트롤한다. 이렇게 하면 마치 OS에서 스레드를 사용하여 동시성을 관리하는 것과 거의 유사한 효과를 준다<br>\n<br>\n이러한 경량스레드라는 용어가 OS 스레드와 혼선을 줄 수 있음에도 경량스레드로 불리는 이유는 스레드와 기능적으로 거의 유사하기 때문이다. 이러한 혼선을 피하기 위한 목적으로 화이버(fiber)라는 용어가 고안되었다. 화이버는 경량스레드의 또다른 이름이다. 프로젝트 룸에서 화이버 모델은 컨티뉴에이션이라는 형태로 구현된다.<br>\n<br>\n사실 이전에도 자바 진영에서 화이버 모델을 구현하려는 시도는 있었다. 그린 스레드라는 이름으로도 유명한데 이 모델은 커널 스레드와 경량 스레드를 1:N 관계로 맵핑하여 경량 스레드를 스케줄링한다. 대략 아래와 같다</p>\n<!-- ![img](../assets/blog/211112_project_loom/project_loom_1.png) -->\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_1.png\" alt=\"img\"></p>\n<p>이 모델은 각 커널 스레드별로 별도의 스케줄러를 생성하여 경량스레드를 작업단위로 관리한다<br>\n<br>\n이 모델은 훌륭하지만 한계가 있다. 커널 스레드 단위로만 스케줄링이 가능하다는 점이다. 전체 가상머신 단위의 잡 스케줄링이 불가능하다. 프로젝트 룸은 이것을 실현하기 위한 프로젝트이다.<br>\n<br>\n즉 프로젝트 룸 기반의 경량스레드 모델은 커널 스레드와 경량 스레드를 N:N 관계로 스케줄링한다. 이 스케줄링의 주체는 가상머신이다. 그림으로 표현하면 아래와 같다</p>\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_2.jpg\" alt=\"project_loom_2\"></p>\n<p>이 모델은 특정한 경량스레드가 실행되어야 할 때 가장 최소의 컨텍스트 스위칭 비용이 발생하는 커널 스레드에게 작업을 위임할 수 있다. 이러한 스레드간의 N:N 모델은 그린스레드의 1:N 모델에 비하여 커널 스레드라는 자원을 훨씬 효율적으로 사용할 수 있다<br>\n<br>\n그리고 이 모델은 기존의 그린스레드가 가졌던 메모리 절감 효과도 그대로 가져온다. 하나의 루틴을 새로 생성한다고 가정해 보자. 이 때 고전적인 스레드 기반의 루틴을 새로 생성한다면 이들 스레드는 OS가 제공하는 커널 스레드이고 이 커널 스레드는 상당한 메모리 공간을 차지한다. 일단 이것은 메모리 효율성 측면에서 좋지않다.<br>\n<br>\n반면 화이버 기반에서는 OS가 아닌 가상머신이 경량스레드를 생성하는데 이 경량스레드는 커널스레드 대비 메타데이터 크기가 약 1/7에서 1/10 수준에 그친다. 아래는 프로젝트 룸의 테크니컬 리드가 말하는 커널스레드와 가상 스레드의 비교 데이터이다.</p>\n<!-- assets\\blog\\211112_project_loom -->\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_3_mod.jpg\" alt=\"img\"></p>\n<p>그림의 상단은 스레드가 차지하는 메타데이터 크기를 비교해놓았다. 이와는 별개로 그림 하단에는 컨텍스트 스위칭 시간을 비교해놓았다.<br>\n<br>\n컨텍스트 스위칭이란 활성 스레드가 기존의 작업을 중단하고 유휴 스레드에게 자원을 할당하여 새로운 작업을 시작하는 프로세스를 일컫는데 고전적인 모델에서는 이 컨텍스트 스위칭이 OS레벨에서 발생했다. 즉 컨텍스트 스위칭이 커널스레드 간에 스위칭하는 방식으로 구현되어 있다. 그런데 앞서 살펴봤듯이 커널스레드는 약 200kb 가량의 메타데이터를 가지며 추가로 1메가 가량의 스택 크기도 할당받는다. 이 메타데이터를 스위칭하고 새로운 작업을 준비하는 과정에서 약 1-10마이크로세컨드가 소모된다.<br>\n<br>\n이 시간이 사소해 보일지 모르겠지만 작업이 빈번하게 여러번 전환되는 상황에서는 어느정도 처리속도의 지연이 있다.\r\n반면 가상머신 기반의 컨텍스트 스위칭은 커널스레드에 기반하지 않는다. 이는 가상머신의 경량스레드에 기반하며 따라서 스케줄링되는 작업의 단위는 경량스레드, 즉 화이버이다. 화이버 단위의 컨텍스트 스위칭이 가능한 이유는 OS가 수행했던 스케줄링 작업을 가상머신이 대신 수행하기 때문이다<br>\n<br>\n당연하지만 컨텍스트 스위칭에 소모되는 시간은 스레드가 가진 메타데이터의 크기에 비례한다. 그런 관계로 훨씬 적은 메타데이터를 가진 경량스레드는 기존 컨텍스트 스위칭 대비 약 5~50배 빠른 전환 속도를 보여준다. 기존의 동시성 패턴대비 더나은 퍼포먼스와 더 적은 메모리 소모를 경험할 수 있다<br>\n<br>\n스케줄링의 권한이 OS가 아닌 응용프로그램에 위임될 때는 또다른 장점이 있다. 이것을 코틀린과 비교하여 설명해 보자. 코틀린의 컨티뉴에이션 루틴은 작업이 오래 지속될 시에 개발자가 원하는 타이밍에 작업을 취소되거나 작업순위을 뒤로 미룰 수 없다. 만일 특정한 작업이 자원을 선점하고 있어서 다른 화이버가 자원을 사용할 수 없는 기아상태가 지속된다면 그것이 OS 스케줄러 수준에서 관리된다.<br>\n<br>\n즉 OS스케줄러가 작업을 중단시키거나 작업순위를 뒤로 미루게 된다. 이것은 두가지 문제가 있다. 첫째로 얼마나 시간이 흐른 뒤에 작업을 중단시킬지 응용프로그램 수준에서 관리할 수 없다. 즉 스케줄링이 실행중인 OS에 전적으로 의존해야 하므로 당신이 OS커널 내부의 스케줄러를 수정하지 않는 이상은 실행흐름 관련 커스터마이징이 불가능하다. 리눅스 커널의 스케줄러를 개조하여 사용하는 경우가 있기는 하지만 이것은 상당한 전문지식과 수고로움을 필요로 한다. 두번째 문제는 내가 작업을 도중에 중단하고 싶지 않은 경우에도 OS스케줄러에 의해 강제적으로 재스케줄링이 될 수도 있다는 점이다. 종합하면 내가 원하는 스케줄링 정책을 적용할 수가 없다.<br>\n<br>\n그러나 가상머신 기반의 컨티뉴에이션 루틴은 스케줄링 정책을 개발자가 직접 설정할 수 있다. 만일 더 지연된 시간에 작업을 리스케줄링 하고 싶다면 그렇게 할 수 있고 중도에 리스케줄링을 원하지 않는다면 그렇게 할 수도 있다. 이것은 실행흐름을 실행할 때 <code>데드라인</code>을 설정하여 가능해진다. 가령 <code>withDeadline(30초)</code>라고 설정하여 실행흐름을 시작한다면 이 실행흐름의 최대 실행시간은 30초로 제한된다. 즉 응용프로그램 레벨에서 미세한 스케줄링 정책을 컨트롤할 수 있게 되었다<br>\n<br>\n그 외에 롬은 기존의 비동기함수 처리방식을 훨씬 간단하게 만든다. 이것을 설명하기 앞서 전염성이라는 개념을 이해할 필요가 있다.<br>\n<br>\n예를들어 어떤 메소드가 퓨처(Future)를 반환하면 이를 호출한 다른 메소드도 퓨처를 반환해야 하는데 이러한 방식은 퓨처가 포함된 콜스택을 통틀어 비동기 패러다임을 강제하는 문제를 야기한다.\r\n이것을 <code>함수의 색 문제</code>라고 하는데 동기 함수와 비동기 함수 사이에 거대한 벽이 있어 상호 연동이 쉽지 않은 문제를 말한다. 실제로 개발 시 동기 함수를 작성하고 있는 건지 비동기 함수를 작성하고 있는 건지 계속해서 의식하게 해야 하는 불편함이 발생한다.<br>\n<br>\n함수의 색 문제를 자세히 알고 싶다면 밥 니스트롬(Bob Nystrom)의 <a href=\"http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">당신 함수의 색은 무엇입니까?</a>(What Color is Your Function?) 문서를 참고해 보자.<br>\n<br>\n프로젝트 룸의 테크니컬 리드인 론 프레슬러는 이런 전염성이 기존 스레드 모델의 가장 큰 문제라고 말한다.\r\n만일 가상머신 기반의 경량스레드 모델을 사용한다면 이런 함수의 색 문제로부터 자유롭다. 즉 함수를 작성할 때 이전에 호출했던 함수가 동기인지 비동기인지를 체크할 필요가 없어진다. 그저 비동기 처리용 컨티뉴에이션을 생성하고 그즉시 yield를 수행하여 작업을 잠정 중단한 뒤에 비동기 처리용 컨티뉴에이션에서 비동기 작업이 종료되면 이전에 작업하던 컨티뉴에이션을 다시 호출하여 작업을 재개하면 되기 떄문이다. 따라서 프로젝트 룸이 프로덕션 레벨에 적용된다면 비동기 처리관련 코딩 스타일이 급변하게 되는것은 필연이다. 그리고 이것은 개발자를 더욱 편하게 만들어줄 것이다<br>\n<br>\n그 외에 프로젝트 룸은 꼬리재귀 최적화를 지원한다. 따라서 재귀함수가 꼬리재귀 기반으로 구현되었다면 더 빠른 처리 속도와 적은 메모리 사용이라는 이익을 볼 수 있다. 이로서 퍼포먼스의 눈치를 보지 않고도 꼬리재귀를 구현할 수 있는 환경이 마련되었다</p>\n<hr>\n<p>참고자료</p>\n<p>론 프레슬러의 프로젝트 룸 소개 동영상 (론 프레슬러는 프로젝트 룸의 테크니컬 리드이다)<br>\n<a href=\"https://www.youtube.com/watch?v=fOEPEXTpbJA\">https://www.youtube.com/watch?v=fOEPEXTpbJA</a></p>\n<p>자바 공식 문서 (Project Loom: JVM을 위한 화이버와 컨티뉴에이션)<br>\n<a href=\"https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html\">https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html</a></p>"
    },
    "url": "/posts/211112_project_loom",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/211112_project_loom.md")
  }
}, children);

});
</script><astro-root uid="1IoJj2"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211028_phoenix_qna"><p class="title">엘릭서의 피닉스 프레임워크 FAQ</p></a></header><time>2021.11.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("1IoJj2", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "엘릭서의 피닉스 프레임워크 FAQ",
    "description": "피닉스 프레임워크에 대해 흔하게 물어보는 질문들과 그 답변들",
    "publishDate": "2021.11.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "엘릭서의-피닉스-프레임워크-faq",
        "text": "엘릭서의 피닉스 프레임워크 FAQ"
      }, {
        "depth": 4,
        "slug": "약간-심화내용",
        "text": "약간 심화내용"
      }],
      "source": "\n### 엘릭서의 피닉스 프레임워크 FAQ\n\nQ. 피닉스란 무엇인가?\\\nA. 피닉스는 엘릭서의 웹서버 프레임워크 이다\\\n\\\nQ. 피닉스는 누가 만들었나?\\\nA. 피닉스는 크리스 맥코드가 만들었다. 그는 원래 루비온레일즈로 개발하던 서버 개발자였다. 그는 레일즈에서 `서버기반 상태관리`를 하고 싶었고 실제로 라이브러리까지 만들어가면서 방법을 연구했다. 하지만 루비라는 언어 및 레일즈라는 프레임워크가 제공하는 동시성 수준으로는 한계가 있었고 여러 상황에서 제대로 작동하지 않았던 것이다. 그는 결국 루비온레일즈를 떠났고 높은 수준의 동시성을 제공해주는 환경을 찾다가 결국 엘릭서 생태계로 이전한다. 그리고 나서 결국 웹서버 프레임워크인 피닉스를 만들게 된 것이다.\\\n[출처 : 해커뉴스 rkangel](https://news.ycombinator.com/item?id=25105581)\\\n\\\nQ. 피닉스는 어떤 특징이 있는가?\\\nA. 위에서 언급했던 대로 피닉스는 `서버기반 상태관리`를 하려다가 좌절한 개발자가 만든 웹 프레임워크다. 따라서 `서버기반 상태관리` 기능을 제공한다. 이를 피닉스 라이브뷰라고 한다\\\n\\\nQ. 웹페이지에서 페이지의 상태를 관리하는 기능은 리액트나 뷰 등의 UI 프레임워크가 제공하던 기능이 아닌가 ?\\\nA. 그렇다. 하지만 리액트나 뷰 등을 사용하는 것은 너무 많은 지식을 필요로 한다. 기술이 빠르게 바뀌고 새로운 라이브러리가 계속 등장하고 새로운 프레임워크도 계속 등장한다. 이것을 계속 따라가는 것은 피곤한 일이다. 하지만 `서버기반 상태관리`에 의존하면 이런 기술들을 계속 쫒아갈 필요가 없다. 그저 엘릭서와 피닉스에 대한 지식만으로도 SPA 웹사이트를 만들 수 있는 것이다. 자바스크립트를 단 한줄도 작성할 필요가 없다\\\n\\\nQ. 라이브뷰가 어떤 방식으로 `서버기반 상태관리 기능`을 제공하길래 자바스크립트를 한 줄도 작성할 필요가 없는가?\\\nA. 라이브뷰는 두가지로 이루어진다. 먼저 `템플릿 기반의 html 코드`이다. 이것은 다른 프레임워크도 흔하게 제공하는 기능이다. 두번째로 `이벤트 처리기`이다. 이벤트 처리기란 웹소켓을 통하여 클라이언트와 서버가 교신하는 모델이다. 클라이언트에게 이벤트가 발생하면 그 이벤트는 서버로 전송된다. 서버는 그 이벤트를 받아서 현재 `서버에 저장된 상태를 기준으로` 재랜더링(re-render)을 수행한다. 재랜더링을 수행하는 과정에서 diff알고리즘으로 이전 랜더링과의 차이점을 분석하고 변경된 사항만을 클라이언트에게 전송한다. 이것이 라이브뷰의 핵심이다\\\n\\\nQ. 서버가 상태를 가지고 있고 렌더링도 수행한다면 이건 `서버에서 작동하는 리액트`가 아닌가?\\\nA. 그렇게 볼 수도 있다. 다만 소위 말하는 `서버에서 작동하는 리액트`를 구현하기 위해 당신은 자바스크립트를 사용할 필요가 없다. 당연하게도 피닉스 프레임워크는 자바스크립트 기반으로 작동하는 서버가 아닌 엘릭서 기반의 서버이기 때문이다. 따라서 당신은 엘릭서와 자바스크립트 두가지 언어를 모두 알 필요가 없으며 엘릭서만 알아도 클라와 서버를 모두 만들 수 있다.\\\n\\\nQ. 클라이언트에서 이벤트가 발생할 때마다 서버에게 메시지를 보낸다면 서버에 너무 과부하가 몰리는 건 아닌가 ?\\\nA. 맞는 말이다. 수십만 수백만 클라이언트와 웹소켓으로 연결되어 실시간으로 메시지가 오간다면 이는 필연적으로 과부하를 야기한다. 하지만 피닉스는 엘릭서 기반이고 엘릭서는 높은 수준의 병렬성을 제공한다. 엘릭서의 창시자 호세 발림에 의하면 그는 루비온레일즈로 100개의 서버가 필요했던 환경에서 엘릭서로 이전하고 난 뒤에는 2개의 서버 만으로 감당할 수 있었다고 한다. 이렇게 극적으로 서버 갯수를 줄일 수 있었던 배경에는 엘릭서가 제공하는 높은 수준의 동시성이 있었기 때문이다.\\\n\\\nQ. `서버기반 상태관리`를 제공하는 프레임워크가 피닉스 뿐인가?\\\nA. 아니다. 웬만한 언어별로 `서버기반 상태관리` 라이브러리가 있다. 자세한 내용은 [여기](https://github.com/dbohdan/liveviews)에서 참조할 수 있다\\\n\\\nQ. 그렇다면 굳이 피닉스 프레임워크를 고집할 이유가 없는 것인가?\\\nA. 엄밀히 말하면 `서버기반 상태관리`는 엘릭서만의 전유물은 아니다. 하지만 위에서 말했듯이 엘릭서의 엑터 모델은 모든 언어를 통틀어 최고수준의 동시성을 보장한다. 따라서 서버기반 상태관리에 최적화 되어있는 언어라고 볼 수 있을것이다.\\\n\\\nQ. `서버기반 상태관리`외에 피닉스의 장점이 있는가?\\\nA. 그렇다. 피닉스는 PubSub모델을 제공한다\\\n\\\nQ. PubSub 모델이 뭔가?\\\nA. 어떤 클러스터 내에 누가 접속했고 누가 연결을 끊었는지 알수있는 매커니즘이라고 한다\\\n\\\nQ. 그게 왜 좋은가?\\\nA. 분산 컴퓨팅을 할 수 있기 때문이다. 어떤 서버에서 hello_world라는 함수를 실행하도록 요청받았는데 그런 함수가 구현되어 있지 않다면? 클러스터 내에 연결되어 있는 다른 노드에 대신 수행해 달라고 요청하면 된다. 다시말해 피닉스는 분산 컴퓨팅에 특화되어 있다\n\n---\n\n#### 약간 심화내용\n\nQ. 라이브뷰는 구체적으로 어떻게 구현되었는가 ?\\\nA. 먼저 라이브뷰가 비헤이비어 라는것을 이해해야 한다. 비헤이비어가 낮설다면 일종의 추상 클래스라고 이해해도 좋다. 비헤이비어는 특정한 함수들을 구현할 것을 강제하는데 이런 함수들을 함수 시그니처에 맞추어 구현하는 것이 비헤이비어의 존재 의의이다. 따라서 비헤이비어를 일종의 인터페이스라고 이해해도 좋다. 이렇게 구현된 함수들은 하나의 웹페이지에서 페이지의 상태를 관리하고 렌더링을 수행한다\\\n\\\nQ. 라이브뷰가 비헤이비어이고 비헤이비어가 특정 함수의 구현을 강제하는 것은 알겠다. 그러면 라이브뷰는 어떤 함수의 구현을 강제하는가?\\\nA. 라이브뷰는 웹소켓 기반의 메시지 통신을 구현할 것을 강제한다. 왜냐하면 클라이언트가 서버에게 이벤트의 발생을 알릴 때 웹소켓을 사용하기 때문이다\n",
      "html": "<h3 id=\"엘릭서의-피닉스-프레임워크-faq\">엘릭서의 피닉스 프레임워크 FAQ</h3>\n<p>Q. 피닉스란 무엇인가?<br>\nA. 피닉스는 엘릭서의 웹서버 프레임워크 이다<br>\n<br>\nQ. 피닉스는 누가 만들었나?<br>\nA. 피닉스는 크리스 맥코드가 만들었다. 그는 원래 루비온레일즈로 개발하던 서버 개발자였다. 그는 레일즈에서 <code>서버기반 상태관리</code>를 하고 싶었고 실제로 라이브러리까지 만들어가면서 방법을 연구했다. 하지만 루비라는 언어 및 레일즈라는 프레임워크가 제공하는 동시성 수준으로는 한계가 있었고 여러 상황에서 제대로 작동하지 않았던 것이다. 그는 결국 루비온레일즈를 떠났고 높은 수준의 동시성을 제공해주는 환경을 찾다가 결국 엘릭서 생태계로 이전한다. 그리고 나서 결국 웹서버 프레임워크인 피닉스를 만들게 된 것이다.<br>\n<a href=\"https://news.ycombinator.com/item?id=25105581\">출처 : 해커뉴스 rkangel</a><br>\n<br>\nQ. 피닉스는 어떤 특징이 있는가?<br>\nA. 위에서 언급했던 대로 피닉스는 <code>서버기반 상태관리</code>를 하려다가 좌절한 개발자가 만든 웹 프레임워크다. 따라서 <code>서버기반 상태관리</code> 기능을 제공한다. 이를 피닉스 라이브뷰라고 한다<br>\n<br>\nQ. 웹페이지에서 페이지의 상태를 관리하는 기능은 리액트나 뷰 등의 UI 프레임워크가 제공하던 기능이 아닌가 ?<br>\nA. 그렇다. 하지만 리액트나 뷰 등을 사용하는 것은 너무 많은 지식을 필요로 한다. 기술이 빠르게 바뀌고 새로운 라이브러리가 계속 등장하고 새로운 프레임워크도 계속 등장한다. 이것을 계속 따라가는 것은 피곤한 일이다. 하지만 <code>서버기반 상태관리</code>에 의존하면 이런 기술들을 계속 쫒아갈 필요가 없다. 그저 엘릭서와 피닉스에 대한 지식만으로도 SPA 웹사이트를 만들 수 있는 것이다. 자바스크립트를 단 한줄도 작성할 필요가 없다<br>\n<br>\nQ. 라이브뷰가 어떤 방식으로 <code>서버기반 상태관리 기능</code>을 제공하길래 자바스크립트를 한 줄도 작성할 필요가 없는가?<br>\nA. 라이브뷰는 두가지로 이루어진다. 먼저 <code>템플릿 기반의 html 코드</code>이다. 이것은 다른 프레임워크도 흔하게 제공하는 기능이다. 두번째로 <code>이벤트 처리기</code>이다. 이벤트 처리기란 웹소켓을 통하여 클라이언트와 서버가 교신하는 모델이다. 클라이언트에게 이벤트가 발생하면 그 이벤트는 서버로 전송된다. 서버는 그 이벤트를 받아서 현재 <code>서버에 저장된 상태를 기준으로</code> 재랜더링(re-render)을 수행한다. 재랜더링을 수행하는 과정에서 diff알고리즘으로 이전 랜더링과의 차이점을 분석하고 변경된 사항만을 클라이언트에게 전송한다. 이것이 라이브뷰의 핵심이다<br>\n<br>\nQ. 서버가 상태를 가지고 있고 렌더링도 수행한다면 이건 <code>서버에서 작동하는 리액트</code>가 아닌가?<br>\nA. 그렇게 볼 수도 있다. 다만 소위 말하는 <code>서버에서 작동하는 리액트</code>를 구현하기 위해 당신은 자바스크립트를 사용할 필요가 없다. 당연하게도 피닉스 프레임워크는 자바스크립트 기반으로 작동하는 서버가 아닌 엘릭서 기반의 서버이기 때문이다. 따라서 당신은 엘릭서와 자바스크립트 두가지 언어를 모두 알 필요가 없으며 엘릭서만 알아도 클라와 서버를 모두 만들 수 있다.<br>\n<br>\nQ. 클라이언트에서 이벤트가 발생할 때마다 서버에게 메시지를 보낸다면 서버에 너무 과부하가 몰리는 건 아닌가 ?<br>\nA. 맞는 말이다. 수십만 수백만 클라이언트와 웹소켓으로 연결되어 실시간으로 메시지가 오간다면 이는 필연적으로 과부하를 야기한다. 하지만 피닉스는 엘릭서 기반이고 엘릭서는 높은 수준의 병렬성을 제공한다. 엘릭서의 창시자 호세 발림에 의하면 그는 루비온레일즈로 100개의 서버가 필요했던 환경에서 엘릭서로 이전하고 난 뒤에는 2개의 서버 만으로 감당할 수 있었다고 한다. 이렇게 극적으로 서버 갯수를 줄일 수 있었던 배경에는 엘릭서가 제공하는 높은 수준의 동시성이 있었기 때문이다.<br>\n<br>\nQ. <code>서버기반 상태관리</code>를 제공하는 프레임워크가 피닉스 뿐인가?<br>\nA. 아니다. 웬만한 언어별로 <code>서버기반 상태관리</code> 라이브러리가 있다. 자세한 내용은 <a href=\"https://github.com/dbohdan/liveviews\">여기</a>에서 참조할 수 있다<br>\n<br>\nQ. 그렇다면 굳이 피닉스 프레임워크를 고집할 이유가 없는 것인가?<br>\nA. 엄밀히 말하면 <code>서버기반 상태관리</code>는 엘릭서만의 전유물은 아니다. 하지만 위에서 말했듯이 엘릭서의 엑터 모델은 모든 언어를 통틀어 최고수준의 동시성을 보장한다. 따라서 서버기반 상태관리에 최적화 되어있는 언어라고 볼 수 있을것이다.<br>\n<br>\nQ. <code>서버기반 상태관리</code>외에 피닉스의 장점이 있는가?<br>\nA. 그렇다. 피닉스는 PubSub모델을 제공한다<br>\n<br>\nQ. PubSub 모델이 뭔가?<br>\nA. 어떤 클러스터 내에 누가 접속했고 누가 연결을 끊었는지 알수있는 매커니즘이라고 한다<br>\n<br>\nQ. 그게 왜 좋은가?<br>\nA. 분산 컴퓨팅을 할 수 있기 때문이다. 어떤 서버에서 hello_world라는 함수를 실행하도록 요청받았는데 그런 함수가 구현되어 있지 않다면? 클러스터 내에 연결되어 있는 다른 노드에 대신 수행해 달라고 요청하면 된다. 다시말해 피닉스는 분산 컴퓨팅에 특화되어 있다</p>\n<hr>\n<h4 id=\"약간-심화내용\">약간 심화내용</h4>\n<p>Q. 라이브뷰는 구체적으로 어떻게 구현되었는가 ?<br>\nA. 먼저 라이브뷰가 비헤이비어 라는것을 이해해야 한다. 비헤이비어가 낮설다면 일종의 추상 클래스라고 이해해도 좋다. 비헤이비어는 특정한 함수들을 구현할 것을 강제하는데 이런 함수들을 함수 시그니처에 맞추어 구현하는 것이 비헤이비어의 존재 의의이다. 따라서 비헤이비어를 일종의 인터페이스라고 이해해도 좋다. 이렇게 구현된 함수들은 하나의 웹페이지에서 페이지의 상태를 관리하고 렌더링을 수행한다<br>\n<br>\nQ. 라이브뷰가 비헤이비어이고 비헤이비어가 특정 함수의 구현을 강제하는 것은 알겠다. 그러면 라이브뷰는 어떤 함수의 구현을 강제하는가?<br>\nA. 라이브뷰는 웹소켓 기반의 메시지 통신을 구현할 것을 강제한다. 왜냐하면 클라이언트가 서버에게 이벤트의 발생을 알릴 때 웹소켓을 사용하기 때문이다</p>"
    },
    "url": "/posts/211028_phoenix_qna",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/211028_phoenix_qna.md")
  }
}, children);

});
</script><astro-root uid="2b1HdU"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0"><p class="title">ec2에서 서버리스로의 교체기</p></a></header><time>2021.11.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2b1HdU", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "ec2에서 서버리스로의 교체기",
    "description": "요금과 콜드스타트의 관점에서",
    "publishDate": "2021.11.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "ec2에서-서버리스로의-교체기",
        "text": "ec2에서 서버리스로의 교체기"
      }, {
        "depth": 3,
        "slug": "요약",
        "text": "요약"
      }, {
        "depth": 3,
        "slug": "계기",
        "text": "계기"
      }, {
        "depth": 3,
        "slug": "aws-lambda",
        "text": "aws lambda"
      }, {
        "depth": 2,
        "slug": "서버리스--느린-db요청",
        "text": "서버리스 === 느린 db요청?"
      }, {
        "depth": 3,
        "slug": "콜드스타트-제거가-가능한가",
        "text": "콜드스타트 제거가 가능한가?"
      }, {
        "depth": 3,
        "slug": "서버리스의-또다른문제-db커넥션-제한",
        "text": "서버리스의 또다른문제, db커넥션 제한"
      }, {
        "depth": 3,
        "slug": "결론",
        "text": "결론"
      }],
      "source": "\r\n### ec2에서 서버리스로의 교체기\r\n\r\n### 요약\r\n1. (많은 경우) 람다는 ec2보다 싸다\r\n1. 람다는 한동안 접속하지 않을 시 콜드스타트가 적용된다. 따라서 느릴 수도 있다\r\n\r\n\r\n### 계기\r\n개인 웹서비스를 ec2에서 제공하고 있었다. 월 29,000원 정도 요금이 나오고 있었는데  비용을 더 줄이고 싶었다. 다른 대안을 알아보다가 서버리스의 존재를 알게된다. 솔깃했다. 어떤 개발자가 ec2에서 서버리스로 전환후 비용을 절약할 수 있었다는 말을 듣고 갈아탈 작정을 한다\r\n\r\n### aws lambda\r\naws도 `람다(lambda)`라는 이름으로 서버리스 서비스를 제공하고 있었다. 같은 aws인지 거부감도 없었고 바로 람다로 갈아타려고 했는데 몇가지 걸림돌이 있었다. 중앙 서버가 없으므로 정적파일을 cdn으로 제공하거나 api를 모듈 함수화 해야했는데 대단히 손이 많이가는 작업이었다. 당시 내 서비스는 next.js 기반이었는데 매번 디플로이를 할때마다 수동으로 이런 작업들을 한다는게 엄두가 나지 않았다. 다행이 `서버리스(serverless)`라는 프레임웍이 있었고 정적파일화 && 단일함수화 작업은 자동으로 수행되었다.\\\r\n그렇게 써보니 작동은 잘 되었고 요금은 월 2,500원 가량으로 약 2만원 이상 줄어들었다. 이정도면 요금의 관점에서는 바꾼 보람이 있었다. 그런데 없던 문제가 생겼다. db에서 데이터를 가져오는 시간이 너무 길었다\r\n\r\n## 서버리스 === 느린 db요청?\r\n그 서버리스 함수는 DBaaS의 일종인 [MongoDB Atlas(이하 아틀라스)](https://www.mongodb.com/)에서 데이터를 가져오고 있었다. 그래서 처음에는 이 아틀라스를 의심했지만 문제는 서버리스 함수의 `콜드스타트`였다. 이용자가 거의 없는 내 서비스는 람다의 입장에서 메모리에 함수를 계속 상주시킬 이유가 없었다. 요청이 뜸한 함수는 메모리에서 해제되는데 이 상황을 `게으른 상태(idle state)`라고 하는 모양이다. 게으른 상태에서 누군가 함수를 요청하면 해야할 일이 참 많다. 먼저 함수를 메모리에 적재한다. 이후 함수가 실행될 워커 스레드를 생성한다. 생성된 워커 스레드는 db 서버와 연결이 안되어있는 상태이므로 재연결을 요청한다. 재연결이 허가되면 그제서야 데이터를 요청한다. `여기까지 걸리는 시간은 약 4초였다`. 1초도 느리다고 취급받는 세상에서 4초는 넌센스였다. 역시 싼건 이유가 있었다.\r\n\r\n### 콜드스타트 제거가 가능한가?\r\n`콜드스타트에 한번 걸리면 느려진다`는 불만이 나한테만 있었을까. 당연히 aws측도 인지하고 있었던 문제였다. 그래서 그들은 2019년 12월, 함수가 `게으른 상태(idle state)`로 진입하지 않도록 하는 서비스인 `프로비전드 컨커런시(provisioned concurrency)`를 공개한다. 결론부터 말하면 본인은 이걸 사용하지 않았다. 프로비전드 컨커런시를 알아보던 도중 렘(realm)이라는 더 좋은 솔루션을 발견했다. 나는 이것에 미혹되었고 결국 서버리스 기반의 db통신은 버렸다. 따라서 내가 써보지 않은 프로비전드 컨커런시에 대한 이야기는 어렵다. 다만 납득할 수 있는 가격대였고 괜찮은 해결책으로 보였다. 만일 내가 렘을 몰랐다면 이것을 사용했을지는 분명하다\r\n\r\n### 서버리스의 또다른문제, db커넥션 제한\r\n여기서부터는 소규모 프로젝트에 대한 이야기는 아니다. 그래도 중요한 토픽이다.\\\r\n많은 db가 최대연결 설정을 제한한다. 그런 환경에서 서버리스를 사용할 때 기존에 없던 문제가 생긴다. 서버리스 환경의 각 함수는 각각의 db 세션을 가진다. 고전적인 서버 모델과 다른 이러한 특성은 많은 수의 동시 커넥션을 생성한다. 특히 서버리스 함수가 몇분간 호출되지 않아 `게으른 상태(idle state)`로 진입할 때 db와 커넥션을 종료하지 않는다. 이런 `좀비 커넥션`은 가용 커넥션의 수를 크게 제한한다. 이런 db커넥션 제한 문제도 콜드스타트 못지않은 서버리스의 문제점이었다. 과거형을 쓰는 이유는 해결책이 나왔기 때문이다. AWS의 RDS Proxy는 db연결 전용 프록시 함수를 생성하여 이 함수를 경유하도록 문제를 해결했다. 이렇게 되면 각각의 함수가 db커넥션 상태일 필요가 없어 총 db커넥션 수가 크게 줄어든다.\\\r\ndb프록시의 장점은 이것만이 아니다. 이미 연결되어 있는 db세션을 재활용하는 것이므로 함수가 콜드스타트 되었을 때 서버에 재연결을 시도하는 시간을 없앨 수 있다. 따라서 서버리스의 약점인 느린 레이턴시를 극복할 수 있다\r\n\r\n### 결론\r\n콜드스타트와 db커넥션 제한은 서버리스의 고질적인 문제였다. 하지만 aws는 이에대한 해결책을 제공했다. 이로서 서버리스를 경유한 db참조 문제는 대부분 해결된 셈이므로 서버리스 이용에 큰 부담을 덜 수 있게 되었다.",
      "html": "<h3 id=\"ec2에서-서버리스로의-교체기\">ec2에서 서버리스로의 교체기</h3>\n<h3 id=\"요약\">요약</h3>\n<ol>\n<li>(많은 경우) 람다는 ec2보다 싸다</li>\n<li>람다는 한동안 접속하지 않을 시 콜드스타트가 적용된다. 따라서 느릴 수도 있다</li>\n</ol>\n<h3 id=\"계기\">계기</h3>\n<p>개인 웹서비스를 ec2에서 제공하고 있었다. 월 29,000원 정도 요금이 나오고 있었는데  비용을 더 줄이고 싶었다. 다른 대안을 알아보다가 서버리스의 존재를 알게된다. 솔깃했다. 어떤 개발자가 ec2에서 서버리스로 전환후 비용을 절약할 수 있었다는 말을 듣고 갈아탈 작정을 한다</p>\n<h3 id=\"aws-lambda\">aws lambda</h3>\n<p>aws도 <code>람다(lambda)</code>라는 이름으로 서버리스 서비스를 제공하고 있었다. 같은 aws인지 거부감도 없었고 바로 람다로 갈아타려고 했는데 몇가지 걸림돌이 있었다. 중앙 서버가 없으므로 정적파일을 cdn으로 제공하거나 api를 모듈 함수화 해야했는데 대단히 손이 많이가는 작업이었다. 당시 내 서비스는 next.js 기반이었는데 매번 디플로이를 할때마다 수동으로 이런 작업들을 한다는게 엄두가 나지 않았다. 다행이 <code>서버리스(serverless)</code>라는 프레임웍이 있었고 정적파일화 &amp;&amp; 단일함수화 작업은 자동으로 수행되었다.<br>\n그렇게 써보니 작동은 잘 되었고 요금은 월 2,500원 가량으로 약 2만원 이상 줄어들었다. 이정도면 요금의 관점에서는 바꾼 보람이 있었다. 그런데 없던 문제가 생겼다. db에서 데이터를 가져오는 시간이 너무 길었다</p>\n<h2 id=\"서버리스--느린-db요청\">서버리스 === 느린 db요청?</h2>\n<p>그 서버리스 함수는 DBaaS의 일종인 <a href=\"https://www.mongodb.com/\">MongoDB Atlas(이하 아틀라스)</a>에서 데이터를 가져오고 있었다. 그래서 처음에는 이 아틀라스를 의심했지만 문제는 서버리스 함수의 <code>콜드스타트</code>였다. 이용자가 거의 없는 내 서비스는 람다의 입장에서 메모리에 함수를 계속 상주시킬 이유가 없었다. 요청이 뜸한 함수는 메모리에서 해제되는데 이 상황을 <code>게으른 상태(idle state)</code>라고 하는 모양이다. 게으른 상태에서 누군가 함수를 요청하면 해야할 일이 참 많다. 먼저 함수를 메모리에 적재한다. 이후 함수가 실행될 워커 스레드를 생성한다. 생성된 워커 스레드는 db 서버와 연결이 안되어있는 상태이므로 재연결을 요청한다. 재연결이 허가되면 그제서야 데이터를 요청한다. <code>여기까지 걸리는 시간은 약 4초였다</code>. 1초도 느리다고 취급받는 세상에서 4초는 넌센스였다. 역시 싼건 이유가 있었다.</p>\n<h3 id=\"콜드스타트-제거가-가능한가\">콜드스타트 제거가 가능한가?</h3>\n<p><code>콜드스타트에 한번 걸리면 느려진다</code>는 불만이 나한테만 있었을까. 당연히 aws측도 인지하고 있었던 문제였다. 그래서 그들은 2019년 12월, 함수가 <code>게으른 상태(idle state)</code>로 진입하지 않도록 하는 서비스인 <code>프로비전드 컨커런시(provisioned concurrency)</code>를 공개한다. 결론부터 말하면 본인은 이걸 사용하지 않았다. 프로비전드 컨커런시를 알아보던 도중 렘(realm)이라는 더 좋은 솔루션을 발견했다. 나는 이것에 미혹되었고 결국 서버리스 기반의 db통신은 버렸다. 따라서 내가 써보지 않은 프로비전드 컨커런시에 대한 이야기는 어렵다. 다만 납득할 수 있는 가격대였고 괜찮은 해결책으로 보였다. 만일 내가 렘을 몰랐다면 이것을 사용했을지는 분명하다</p>\n<h3 id=\"서버리스의-또다른문제-db커넥션-제한\">서버리스의 또다른문제, db커넥션 제한</h3>\n<p>여기서부터는 소규모 프로젝트에 대한 이야기는 아니다. 그래도 중요한 토픽이다.<br>\n많은 db가 최대연결 설정을 제한한다. 그런 환경에서 서버리스를 사용할 때 기존에 없던 문제가 생긴다. 서버리스 환경의 각 함수는 각각의 db 세션을 가진다. 고전적인 서버 모델과 다른 이러한 특성은 많은 수의 동시 커넥션을 생성한다. 특히 서버리스 함수가 몇분간 호출되지 않아 <code>게으른 상태(idle state)</code>로 진입할 때 db와 커넥션을 종료하지 않는다. 이런 <code>좀비 커넥션</code>은 가용 커넥션의 수를 크게 제한한다. 이런 db커넥션 제한 문제도 콜드스타트 못지않은 서버리스의 문제점이었다. 과거형을 쓰는 이유는 해결책이 나왔기 때문이다. AWS의 RDS Proxy는 db연결 전용 프록시 함수를 생성하여 이 함수를 경유하도록 문제를 해결했다. 이렇게 되면 각각의 함수가 db커넥션 상태일 필요가 없어 총 db커넥션 수가 크게 줄어든다.<br>\ndb프록시의 장점은 이것만이 아니다. 이미 연결되어 있는 db세션을 재활용하는 것이므로 함수가 콜드스타트 되었을 때 서버에 재연결을 시도하는 시간을 없앨 수 있다. 따라서 서버리스의 약점인 느린 레이턴시를 극복할 수 있다</p>\n<h3 id=\"결론\">결론</h3>\n<p>콜드스타트와 db커넥션 제한은 서버리스의 고질적인 문제였다. 하지만 aws는 이에대한 해결책을 제공했다. 이로서 서버리스를 경유한 db참조 문제는 대부분 해결된 셈이므로 서버리스 이용에 큰 부담을 덜 수 있게 되었다.</p>"
    },
    "url": "/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0.md")
  }
}, children);

});
</script><astro-root uid="Z28szC6"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210505_closure"><p class="title">클로저 (closure)에 대해 정리한 글</p></a></header><time>2021.05.05</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("Z28szC6", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "클로저 (closure)에 대해 정리한 글",
    "description": "상태를 저장하는 함수",
    "publishDate": "2021.05.05",
    "astro": {
      "headers": [{
        "depth": 1,
        "slug": "클로저-closure",
        "text": "클로저 (closure)"
      }],
      "source": "\r\n# 클로저 (closure)\r\n\r\n컴퓨터 과학 분야에서 클로저라는 개념은 란딘이 발표한 논문 `The mechanical evaluation of expressions`에서 처음 등장하지만 자바스크립트를 사용하는데 있어 이 정의는 크게 도움이 되지 않는다.\\\r\n\\\r\n그는 클로저를 다음과 같이 정의하였다\r\n\r\n> 클로저는 환경 파트와 컨트롤 파트로 나뉘어진 람다 표현식이고 이는 표현식을 평가하는데 쓰인다.\\\r\n> (a closure has an environment part and a control part which consists of a list whose sole item is an AE.)\r\n\r\n`(www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Landin64.pdf)`\r\n\\\r\n자바스크립트의 명세인 ECMAScript 스펙에도 클로저는 정의되어 있지 않다. 따라서 자바스크립트 내부에서 정확히 클로저가 무엇을 의미하는지는 알 수 없다.\\\r\n\\\r\n다만 자바스크립트의 가상 머신인 v8에 정의된 클로저 스코프라는 용어를 근거로 정의할 수 있다\r\n\r\n`자바스크립트에서 클로저란 클로저 스코프를 포함한 함수를 뜻한다`\r\n\r\n만일 함수가 클로저 스코프를 포함하지 않아도 클로저가 될 수 있다면 클로저 스코프의 존재 의의가 없어진다.\\\r\n\\\r\n그런 의미에서 이러한 정의는 어느정도의 설득력을 가질 수 있다.\\\r\n\\\r\n위의 정의에 의하면 함수가 가지고 있는 스코프 체인 내부에 클로저 스코프라는 유형의 스코프가 존재할 때 해당 함수는 클로저이다.\\\r\n\\\r\n클로저 스코프란 스코프의 일종인데 V8 엔진 내부에는 총 9종류의 스코프가 존재한다\r\n\r\n```cpp\r\nenum ScopeType {\r\n\r\n    ScopeTypeGlobal = 0,\r\n    ScopeTypeLocal,\r\n    ScopeTypeWith,\r\n    ScopeTypeClosure,\r\n    ScopeTypeCatch,\r\n    ScopeTypeBlock,\r\n    ScopeTypeScript,\r\n    ScopeTypeEval,\r\n    ScopeTypeModule\r\n};\r\n```\r\n\r\n< 참고 : v8/src/debug/debug-scopes.h >\\\r\n\\\r\n이 정보는 enum 형식으로 ScopeIterator 클래스에 정의되어 있다.\\\r\n\\\r\n클로저 스코프는 아래와 같은 상황에서 생성된다.\r\n\r\n```javascript\r\nfunction outer() {\r\n\r\n    var free = 1;\r\n\r\n    function inner() {\r\n        free++;\r\n    };\r\n\r\n    inner();\r\n};\r\n```\r\n\r\n위의 코드는 함수가 중첩되어 있는 상황에서 안쪽에 정의된 함수가 바깥쪽에 정의된 변수를 참조하는 상황이다.\\\r\n\\\r\ninner 함수가 호출될 때 생성되는 스코프 체인은 아래와 같다\r\n\r\n<!-- D:\\project\\리눅스폴더\\myblog_astro\\public\\assets\\blog\\closure -->\r\n![aaa](/assets/blog/closure/1.png)\r\n\r\n위의 스코프에서 Closure (outer) 라고 적혀있는 스코프가 클로저 스코프이다. 변수 free는 클로저 스코프에 의하여 식별된다.\\\r\n\\\r\n클로저 스코프가 생성되기 위한 조건을 정리하면 아래와 같다.\r\n\r\n```\r\n1. 두개의 함수가 있다. 이를 각각 inner 함수와 outer 함수라 하자.\r\n\r\n2. inner 함수는 outer 함수 내부에 정의되어 있다.\r\n\r\n3. inner 함수는 outer함수에 정의된 지역변수를 참조한다.\r\n이 지역변수를 참조하는 과정에서 스코프 체이닝을 수행한다.\r\n스코프 체이닝을 수행하는 과정에서 일련의 스코프를 순차적으로 탐색한다.\r\n\r\n4. 스코프 탐색 도중 outer함수에 정의된 지역변수를 발견한다.\r\n이 스코프의 이름을 클로저 스코프라고 한다\r\n```\r\n\r\n위의 내용을 더 간단하게 정리하면 아래와 같다.\r\n\r\n`함수가 중첩되어 있는 상황에서 안쪽의 함수가 바깥쪽 함수에 정의된 변수를 참조할 때 클로저 스코프라는 이름의 스코프에서 참조한다`\r\n\r\n위의 내용만 듣고보면 클로저의 유용함을 납득하기 어렵다. 위의 정의를 재해석해보면 아래와 같다\r\n\r\n`외부에 상태를 보존하고 있는 함수를 클로저라고 한다`\r\n\r\nouter 함수에 정의된 변수를 상태의 관점에서 접근하면 클로저의 유용함을 이해하기 편하다.\\\r\n\\\r\n클로저는 함수가 호출되는 시점의 상태에 근거하여 리턴값을 반환할 수 있다. 상태라는 개념은 함수 내부에 선언된 변수가 아닌 함수 외부에 선언된 변수에 접근하여 구현할 수 있다.\\\r\n\\\r\n이처럼 함수 외부에 선언되었고 함수 내부에서 접근할 수 있는 변수를 자유변수라고 한다. 함수를 호출할 때 중간 상태값에 근거하여 리턴값을 반환할 수 있다는 데서 자유변수의 의의가 있다.\\\r\n\\\r\n이처럼 자유변수를 특정 함수에서만 접근할 수 있는 패턴은 아래와 같이 작성한다\r\n\r\n```javascript\r\nfunction outer() {\r\n\r\n    var free = 1;\r\n\r\n    return function inner() {\r\n        free++;\r\n    };\r\n};\r\n\r\nconst inner = outer();\r\ninner();\r\n\r\n```\r\n\r\n위의 코드는 outer 함수를 호출하고 리턴값으로 inner 함수의 참조값을 반환받는다. 그리고 반환받은 inner 함수를 호출한다.\\\r\n\\\r\n호출된 inner 함수는 변수 free를 참조하여 값을 1 증가시킨다. 만일 클로저라는 개념이 없다면 위의 코드는 에러를 발생시킨다. 왜냐하면 inner 함수를 호출하는 시점에는 메모리상에 변수 free가 해제되어 존재하지 않기 때문이다. 클로저가 없다고 가정하고 이 상황을 정리하면 아래와 같다\r\n\r\n1. 먼저 outer 함수가 호출된다. outer 함수가 호출되는 시점에 outer 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 내부에는 outer함수 내부에서 선언된 지역 변수인 free가 저장되어 있다.\r\n이 실행 컨텍스트는 메모리 heap 영역에 저장된다.\r\n\r\n1. outer 함수의 루틴이 실행되고 먼저 변수 free에 값 1을 대입한다.\r\n\r\n1. 함수 inner를 리턴한다. 이 때 inner 함수 자체를 리턴하지 않으며 함수가 메모리상에서 정의된 메모리 주소를 리턴한다.\\\r\n이를 참조값(reference) 이라고 한다. 따라서 함수의 참조값을 리턴하기 전 메모리상에 함수에 대한 정보를 저장해 놓는다.\\\r\n이 함수에 대한 정보에는 식별자 해결(identifier resolution) 메커니즘인 스코프 체이 포함되어 있다.\\\r\n스코프 체인은 함수 내부에서 사용되는 변수가 어떤 실행 컨텍스트에 정의되어 있는지 판별하는 식별자 해결 메커니즘이다.\\\r\ninner 함수에서 참조하는 변수 free는 함수 외부에 정의되어 있다.\r\n따라서 이 free 변수를 참조할 수 있는 스코프를 스코프 체인 내부에 저장해 놓는다.\r\n이 스코프의 이름은 outer이다\r\n\r\n1. outer 함수가 리턴되고 outer 함수의 변수를 저장해 놓은 실행 컨텍스트가 메모리에서 해제된다.\r\n이제 outer함수의 실행 컨텍스트에 저장된 변수 free에 접근할 수 없다\r\n\r\n1. inner 함수가 호출된다. inner 함수가 호출되는 시점에 inner 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 생성 과정에서 어떠한 지역 변수가 선언되었는지 확인한다.\r\n확인결과 inner 함수의 내부에는 어떠한 지역 변수도 선언되지 않았다.\r\n따라서 inner 함수의 실행 컨텍스트에는 어떠한 지역 변수도 정의되지 않는다.\r\n\r\n1. inner 함수 내부에서 free++ ; 연산을 수행한다.\r\n이 때 free 변수가 inner함수 내부에 저장되어 있는지 확인하기 위하여 실행 컨텍스트를 참고한다.\r\n확인결과 inner 함수는 정의되지 않았다. 따라서 식별자 해결을 수행하는데 이 때 스코프 체인을 참고한다.\r\n이 스코프체인은 스탭 3에서 생성된 스코프 체인이고 이 스코프 체인에 따르면 free 변수는 outer 함수의 실행 컨텍스트에 저장되어 있다.\r\n따라서 outer 함수의 컨텍스트로 이동하여 해당 변수 값을 참고하려 할 것이다.\r\n\r\n1. 그러나 outer 함수의 실행 컨텍스트는 outer 함수가 종료된 시점에 메모리 상에서 사라졌다.\r\n따라서 outer 함수의 실행 컨텍스트를 참조할 수 없고 결과적으로 free 변수도 참조할 수 없다\r\n\r\n8. 변수를 참조할 수 없으므로 자바스크립트 엔진은 'Uncaught ReferenceError: free is not defined' 에러를 발생시키고 프로그램을 종료한다\r\n그러나 위의 시나리오와는 다르게 free 변수는 정상적으로 참조할 수 있다. 그 이유는 자바스크립트 엔진이 outer 함수의 실행 컨텍스트를 해제하지 않았기 떄문이다.\r\n본래대로라면 함수가 리턴되는 순간 실행 컨텍스트가 해제되지만 몇가지 조건이 갖추어지면 함수가 리턴되는 상황에서도 실행 컨텍스트가 해제되지 않는다. 그 조건은 아래와 같다\r\n```\r\n1. 함수가 리턴할 때 자기자신이 아닌 또다른 함수를 리턴한다.\r\n리턴되는 함수를 inner라 하자.\r\n\r\n2. inner 함수 내부에서 현재 실행중인 함수의 지역변수를 참조한다\r\n```\r\n\r\n위와 같은 조건에서는 함수가 종료되어도 실행 컨텍스트가 해제되지 않는다. 이렇게 되면 outer 변수의 free에 접근할 수 있는 수단은 inner함수를 호출하는 방법 외에는 없다.\\\r\n\\\r\n이로서 inner 함수가 자유변수를 사용할 수 있게 되었고, 오직 inner 함수를 통해서만 자유변수에 접근할 수 있게 되었다. 객체지향 프로그래밍을 공부해 본 사람이라면 이러한 개념이 객체가 제공하는 private 변수와 유사하다는 것을 느꼇을 것이다. 실제로 객체의 private 변수와 클로저의 자유변수는 개념상 거의 유사하고 추구하는 목적은 같다. 이러한 유사성에 대하여 윌리엄스 칼리지의 Daniel Barowy 교수는 다음과 같이 말했다\r\n\r\n> Objects are kind of closure\r\n\r\n`(www.cs.williams.edu/~dbarowy/cs334s18/assets/lecture_2018-04-10.pdf)`\\\r\n\\\r\n그리고 Norman Adams라는 사람은 다음과 같이 말했다\r\n\r\n> Objects are a poor man's closures\\\r\n> (객체란 실력이 부족한 사람들이 사용하는 클로저이다)\r\n\r\n`(Ken Dickey, \"Scheming with Objects\")`\\\r\n\\\r\n반면 소르본 대학의 명예교수인 크리스티안(Christian Queinnec)은 다음과 같이 말했다\r\n\r\n> 많은 사람들이 객체를 두고 실력이 부족한 사람들이 사용하는 클로저라고 말하는데,\\\r\n> 사실 클로저는 실력이 부족한 사람들이 사용하는 객체이다.\\\r\n> (although many people consider objects to be 'poor man's closures, closures are in fact poor man's objects)\r\n\r\n`(people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html)`\\\r\n\\\r\n위의 주장들은 누구의 주장이 옮다는 차원을 넘어서 클로저와 객체가 같은 지향점을 향한다는 점을 시사한다.\\\r\n\\\r\n이 둘은 모두 캡슐화를 지향한다. 그 목표를 달성하는 수단이 다를 뿐이다\\\r\n이런 점을 감안하면 굳이 클로저에 정의에 얽매일 필요가 없다. 자유변수를 하나의 함수에서만 접근할 수 있으면 그 함수는 클로저가 아니더라도 클로저처럼 사용할 수 있다\r\n\r\n```javascript\r\n{\r\n    let free = 0;\r\n\r\n    function func() {\r\n        return ++free;\r\n    }\r\n}\r\n\r\nconsole.log(func());\r\nconsole.log(func());\r\nconsole.log(func());\r\n```\r\n\r\n위의 코드에서 함수 func는 정의상으로는 클로저가 아닐지 몰라도 의미상으로는 클로저와 같다. 왜 그런지 알아보자.\\\r\n\\\r\n함수 func는 자유변수 free를 참조한다. 그리고 변수 free는 func를 통해서만 접근할 수 있다. 왜냐하면 블록 스코프 `{ }` 내부에 정의된 let은 블록 스코프에서 벗어나는 순간 접근이 불가하기 때문이다.\\\r\n\\\r\n본래대로라면 블록스코프 `{ }` 를 벗어난 순간 변수 free는 메모리에서 해제되어 접근할 수 있는 방법이 없어지게 된다. 하지만 블록 스코프를 벗어나는 시점에 지역변수 free를 참조하는 함수가 존재하는지 검사하는데 위의 경우 함수 func가 변수 free를 참조하기 때문에 블록 스코프는 메모리에서 해제되지 않는다. 메모리에서 해제되지는 않지만 블록스코프를 벗어난 지점에서 변수 free에 직접 접근할 수는 없다. 변수 free는 func 함수를 호출하여 참조할 수 있고 그 외에 접근할 수 있는 수단은 없다. 자유변수를 참조할 수 있는 방법을 강제로 제한해 버린다는 측면에서 이 패턴은 클로저로 분류될 수 있다.\\\r\n그렇다면 함수 func는 변수 free를 참조하는 스코프를 클로저스코프로 분류하는가? 아래 그림은 변수 free가 어느 스코프에서 참조되는지를 보여준다\r\n\r\n![aaa](/assets/blog/closure/2.png)\r\n<!-- ![aaa](./img_클로저의_뜻과_존재의의/2.png) -->\r\n\r\n변수 free는 block 스코프에서 참조된다. 그렇다면 변수 free가 클로저스코프에서 참조되지 않으니 함수 func는 클로저가 아니라고 말할 수 있는가? 정의상으로 클로저가 맞던 틀리던 간에 결과적으로 위의 자유변수 free는 객체지향 언어의 private 변수와 같은 개념으로 func함수가 접근할 수 있다. 따라서 클로저스코프를 생성하지는 않으나 함수를 사용하는 입장에서 func함수를 클로저로 보아도 큰 지장은 없다. 클로저의 정의에 얾매일 필요가 없다는 말은 이런 이유 때문이다.\\\r\n\\\r\n주제를 바꿔서 이야기해보자면, 상태를 보존한다는 개념이 구체적으로 어떤 유용함이 있는가? 게임의 예를 들어보자.\\\r\n\\\r\n1:1 격투게임을 구현할 때 각 플레이어의 HP를 감소시키려는 함수를 구현한다. 클로저를 사용하지 않은 상태에서 순수함수의 형태로 구현하면 아래와 같다.\r\n\r\n```javascript\r\nfunction modifyHP(currentHP, damage) {\r\n\r\n    return currentHP - damage;\r\n}\r\n```\r\n\r\n그리고 위의 함수는 아래와 같은 형태로 사용된다\r\n\r\n```javascript\r\nconst damage = getDamage();\r\n\r\nconst currentHP = getCurrentHP();\r\n\r\nconst modifiedHP = modifyHP(currentHP, damage);\r\n\r\nsaveHP(modifiedHP);\r\n```\r\n\r\n만일 상태가 없는 함수를 사용한다면 상태를 불러와 함수를 호출하고 그 리턴값을 다른 함수를 통하여 저장해야 한다\\\r\n\\\r\n반면 HP감소 함수를 클로저로 구현하면 아래와 같다.\r\n\r\n```javascript\r\nfunction hp수정(maxHP) {\r\n\r\n    let currentHP = maxHP;\r\n\r\n    return function (damage) {\r\n        return currentHP - damage;\r\n    }\r\n};\r\n\r\nconst modifyHP = outer(100);\r\n```\r\n\r\n그리고 위의 클로저 함수는 아래와 같이 사용된다.\r\n\r\n```javascript\r\nconst damage = getDamage()\r\n\r\nconst modifiedHP = modifyHP(damage)\r\n```\r\n\r\n내부에서 상태를 저장하므로 외부에서 상태를 불러올 필요가 없고 외부 함수를 통하여 상태를 저장할 필요가 없다.\\\r\n한마디로 클로저는 개발의 편의성을 제공한다.\\\r\n\\\r\n그러나 함수 외부에서 상태를 참조하는 것이 목적이라면 전역 변수를 참조하면 되는데 굳이 외부함수를 만들어 가면서까지 상태를 저장할 필요가 있는지 그 실용성에 의구심을 가질 수가 있다. 위에서 구현한 HP 감소 함수를 전역 변수를 사용하여 구현하면 다음과 같다.\r\n\r\n```javascript\r\nlet currentHP = maxHP;\r\n\r\nfunction modifyHP(damage) {\r\n    return currentHP - damage;\r\n}\r\n```\r\n\r\n위의 코드는 클로저에 비하여 직관적이고 코드량이 적다. 모든 면에서 클로저보다 이상적으로 보이기도 한다.\\\r\n\\\r\n소규모 프로젝트를 진행중이라면 이런 식의 코드 작성이 더 나은 선택일 수도 있다. 하지만 20명 이상이 참여하는 대규모 프론트엔드 프로젝트라면 이야기가 달라질 수도 있다.\\\r\n\\\r\n위에서 정의한 currentHP 변수는 전역변수이기 때문에 나 뿐만이 아닌 다른 모든 팀원이 접근할 수 있다. 따라서 다른 팀원이 currentHP 변수에 접근하지 않아야 한다는 보장이 필요하다. 만일 다른 팀원이 currentHP 변수에 접근하여 내가 의도한 것과 다른 방식으로 변수값을 조정하는 경우 플레이어의 hp가 의도치 않은 상황에 증가하거나 감소하는 상황이 발생하여 게임 진행 자체가 불가능하게 될 것이다. 이와 같은 상황을 방지하려면 전역변수를 생성할 때 마다 다른 모든 팀원을 대상으로 공지사항을 알려줘야 한다.\r\n\r\n> currentHP는 제가 만든 변수이니 이 변수를 사용하지 말라.\\\r\n> currentMP도 접근하지 말라\\\r\n> currentPowerGauge 접근하면 안되고 . . .\r\n\r\n코드를 작성할 수록 전역 변수는 늘어난다. 프로그램 실행중의 에러를 방지하려면 이 모든것을 문서화 해야 할 것이다. 이 자체만으로도 어려운 일이지만 만일 나 뿐만이 아닌 다른 모든 팀원들이 전역 변수를 사용한다면? 접근해서는 안되는 수백개의 전역변수를 기억한 채로 코드를 작성해야 한다. 이것은 고역이고 가능하지도 않다.\\\r\n\\\r\n더 큰 문제는 누군가가 currentHP에 임의로 접근하여 의도치 않은 상황에 hp가 증가하거나 감소하는 경우, 디버깅 대상이 되는 코드는 프로젝트 내의 전체 코드가 된다. 프로그램 내에 어떠한 문맥에서도 전역변수에 접근할 수 있기 때문이다. 이 경우 어떻게 디버깅을 진행할 것인가 ? 팀원 한명한명을 불러서 네가 currentHP에 접근했는지 심문할 것인가? 사실 개발자는 자기가 작성한 코드를 일일이 기억할 수 없다. 따라서 '나는 currentHP를 건드리지 않았는데요' 라고 어떤 개발자가 말했다고 해서 그 사람이 currentHP에 접근하지 않았다는 보장이 없다. 만일 전체 소스코드가 충분히 복잡하고 해당 버그를 재현하기도 어려운 상황이라면 최악의 상황에는 버그를 수정할 수 없는 상황까지 발생할 수 있다.\\\r\n\\\r\n이처럼 전역변수를 사용하는 데서 오는 코스트는 감당하기 어렵다. 개발자들은 디버깅 코스트를 최소화하기 위하여 오랜기간 고민하였고 그 결과 나온 개념이 함수형 프로그래밍 진형에서는 클로저이고 객체지향 프로그래밍 진형에서는 프라이빗(private) 멤버변수라는 형태로 고안되었다. 그 결과 변수가 오용될 수 있는 범위를 극적으로 줄일 수 있게 되었다. 더불어 상태값이 잘못 할당되어 프로그램이 오작동 될 때 디버깅 해야하는 코드 범위를 줄여 막대한 생산성 향상을 이끌어 내었다.\r\n\r\n-- 끝",
      "html": "<h1 id=\"클로저-closure\">클로저 (closure)</h1>\n<p>컴퓨터 과학 분야에서 클로저라는 개념은 란딘이 발표한 논문 <code>The mechanical evaluation of expressions</code>에서 처음 등장하지만 자바스크립트를 사용하는데 있어 이 정의는 크게 도움이 되지 않는다.<br>\n<br>\n그는 클로저를 다음과 같이 정의하였다</p>\n<blockquote>\n<p>클로저는 환경 파트와 컨트롤 파트로 나뉘어진 람다 표현식이고 이는 표현식을 평가하는데 쓰인다.<br>\n(a closure has an environment part and a control part which consists of a list whose sole item is an AE.)</p>\n</blockquote>\n<p><code>(www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Landin64.pdf)</code>\r\n<br>\n자바스크립트의 명세인 ECMAScript 스펙에도 클로저는 정의되어 있지 않다. 따라서 자바스크립트 내부에서 정확히 클로저가 무엇을 의미하는지는 알 수 없다.<br>\n<br>\n다만 자바스크립트의 가상 머신인 v8에 정의된 클로저 스코프라는 용어를 근거로 정의할 수 있다</p>\n<p><code>자바스크립트에서 클로저란 클로저 스코프를 포함한 함수를 뜻한다</code></p>\n<p>만일 함수가 클로저 스코프를 포함하지 않아도 클로저가 될 수 있다면 클로저 스코프의 존재 의의가 없어진다.<br>\n<br>\n그런 의미에서 이러한 정의는 어느정도의 설득력을 가질 수 있다.<br>\n<br>\n위의 정의에 의하면 함수가 가지고 있는 스코프 체인 내부에 클로저 스코프라는 유형의 스코프가 존재할 때 해당 함수는 클로저이다.<br>\n<br>\n클로저 스코프란 스코프의 일종인데 V8 엔진 내부에는 총 9종류의 스코프가 존재한다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum ScopeType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    ScopeTypeGlobal = 0,\r\n    ScopeTypeLocal,\r\n    ScopeTypeWith,\r\n    ScopeTypeClosure,\r\n    ScopeTypeCatch,\r\n    ScopeTypeBlock,\r\n    ScopeTypeScript,\r\n    ScopeTypeEval,\r\n    ScopeTypeModule\r\n};\n</code></pre>\n<p>&lt; 참고 : v8/src/debug/debug-scopes.h ><br>\n<br>\n이 정보는 enum 형식으로 ScopeIterator 클래스에 정의되어 있다.<br>\n<br>\n클로저 스코프는 아래와 같은 상황에서 생성된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function outer() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    var free = 1;\r\n\r\n    function inner() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        free++;\r\n    };\r\n\r\n    inner();\r\n};\n</code></pre>\n<p>위의 코드는 함수가 중첩되어 있는 상황에서 안쪽에 정의된 함수가 바깥쪽에 정의된 변수를 참조하는 상황이다.<br>\n<br>\ninner 함수가 호출될 때 생성되는 스코프 체인은 아래와 같다</p>\n<!-- D:\\project\\리눅스폴더\\myblog_astro\\public\\assets\\blog\\closure -->\n<p><img src=\"/assets/blog/closure/1.png\" alt=\"aaa\"></p>\n<p>위의 스코프에서 Closure (outer) 라고 적혀있는 스코프가 클로저 스코프이다. 변수 free는 클로저 스코프에 의하여 식별된다.<br>\n<br>\n클로저 스코프가 생성되기 위한 조건을 정리하면 아래와 같다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. 두개의 함수가 있다. 이를 각각 inner 함수와 outer 함수라 하자.\r\n\r\n2. inner 함수는 outer 함수 내부에 정의되어 있다.\r\n\r\n3. inner 함수는 outer함수에 정의된 지역변수를 참조한다.\r\n이 지역변수를 참조하는 과정에서 스코프 체이닝을 수행한다.\r\n스코프 체이닝을 수행하는 과정에서 일련의 스코프를 순차적으로 탐색한다.\r\n\r\n4. 스코프 탐색 도중 outer함수에 정의된 지역변수를 발견한다.\r\n이 스코프의 이름을 클로저 스코프라고 한다\n</code></pre>\n<p>위의 내용을 더 간단하게 정리하면 아래와 같다.</p>\n<p><code>함수가 중첩되어 있는 상황에서 안쪽의 함수가 바깥쪽 함수에 정의된 변수를 참조할 때 클로저 스코프라는 이름의 스코프에서 참조한다</code></p>\n<p>위의 내용만 듣고보면 클로저의 유용함을 납득하기 어렵다. 위의 정의를 재해석해보면 아래와 같다</p>\n<p><code>외부에 상태를 보존하고 있는 함수를 클로저라고 한다</code></p>\n<p>outer 함수에 정의된 변수를 상태의 관점에서 접근하면 클로저의 유용함을 이해하기 편하다.<br>\n<br>\n클로저는 함수가 호출되는 시점의 상태에 근거하여 리턴값을 반환할 수 있다. 상태라는 개념은 함수 내부에 선언된 변수가 아닌 함수 외부에 선언된 변수에 접근하여 구현할 수 있다.<br>\n<br>\n이처럼 함수 외부에 선언되었고 함수 내부에서 접근할 수 있는 변수를 자유변수라고 한다. 함수를 호출할 때 중간 상태값에 근거하여 리턴값을 반환할 수 있다는 데서 자유변수의 의의가 있다.<br>\n<br>\n이처럼 자유변수를 특정 함수에서만 접근할 수 있는 패턴은 아래와 같이 작성한다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function outer() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    var free = 1;\r\n\r\n    return function inner() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        free++;\r\n    };\r\n};\r\n\r\nconst inner = outer();\r\ninner();\r\n\n</code></pre>\n<p>위의 코드는 outer 함수를 호출하고 리턴값으로 inner 함수의 참조값을 반환받는다. 그리고 반환받은 inner 함수를 호출한다.<br>\n<br>\n호출된 inner 함수는 변수 free를 참조하여 값을 1 증가시킨다. 만일 클로저라는 개념이 없다면 위의 코드는 에러를 발생시킨다. 왜냐하면 inner 함수를 호출하는 시점에는 메모리상에 변수 free가 해제되어 존재하지 않기 때문이다. 클로저가 없다고 가정하고 이 상황을 정리하면 아래와 같다</p>\n<ol>\n<li>\n<p>먼저 outer 함수가 호출된다. outer 함수가 호출되는 시점에 outer 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 내부에는 outer함수 내부에서 선언된 지역 변수인 free가 저장되어 있다.\r\n이 실행 컨텍스트는 메모리 heap 영역에 저장된다.</p>\n</li>\n<li>\n<p>outer 함수의 루틴이 실행되고 먼저 변수 free에 값 1을 대입한다.</p>\n</li>\n<li>\n<p>함수 inner를 리턴한다. 이 때 inner 함수 자체를 리턴하지 않으며 함수가 메모리상에서 정의된 메모리 주소를 리턴한다.<br>\n이를 참조값(reference) 이라고 한다. 따라서 함수의 참조값을 리턴하기 전 메모리상에 함수에 대한 정보를 저장해 놓는다.<br>\n이 함수에 대한 정보에는 식별자 해결(identifier resolution) 메커니즘인 스코프 체이 포함되어 있다.<br>\n스코프 체인은 함수 내부에서 사용되는 변수가 어떤 실행 컨텍스트에 정의되어 있는지 판별하는 식별자 해결 메커니즘이다.<br>\ninner 함수에서 참조하는 변수 free는 함수 외부에 정의되어 있다.\r\n따라서 이 free 변수를 참조할 수 있는 스코프를 스코프 체인 내부에 저장해 놓는다.\r\n이 스코프의 이름은 outer이다</p>\n</li>\n<li>\n<p>outer 함수가 리턴되고 outer 함수의 변수를 저장해 놓은 실행 컨텍스트가 메모리에서 해제된다.\r\n이제 outer함수의 실행 컨텍스트에 저장된 변수 free에 접근할 수 없다</p>\n</li>\n<li>\n<p>inner 함수가 호출된다. inner 함수가 호출되는 시점에 inner 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 생성 과정에서 어떠한 지역 변수가 선언되었는지 확인한다.\r\n확인결과 inner 함수의 내부에는 어떠한 지역 변수도 선언되지 않았다.\r\n따라서 inner 함수의 실행 컨텍스트에는 어떠한 지역 변수도 정의되지 않는다.</p>\n</li>\n<li>\n<p>inner 함수 내부에서 free++ ; 연산을 수행한다.\r\n이 때 free 변수가 inner함수 내부에 저장되어 있는지 확인하기 위하여 실행 컨텍스트를 참고한다.\r\n확인결과 inner 함수는 정의되지 않았다. 따라서 식별자 해결을 수행하는데 이 때 스코프 체인을 참고한다.\r\n이 스코프체인은 스탭 3에서 생성된 스코프 체인이고 이 스코프 체인에 따르면 free 변수는 outer 함수의 실행 컨텍스트에 저장되어 있다.\r\n따라서 outer 함수의 컨텍스트로 이동하여 해당 변수 값을 참고하려 할 것이다.</p>\n</li>\n<li>\n<p>그러나 outer 함수의 실행 컨텍스트는 outer 함수가 종료된 시점에 메모리 상에서 사라졌다.\r\n따라서 outer 함수의 실행 컨텍스트를 참조할 수 없고 결과적으로 free 변수도 참조할 수 없다</p>\n</li>\n<li>\n<p>변수를 참조할 수 없으므로 자바스크립트 엔진은 ‘Uncaught ReferenceError: free is not defined’ 에러를 발생시키고 프로그램을 종료한다\r\n그러나 위의 시나리오와는 다르게 free 변수는 정상적으로 참조할 수 있다. 그 이유는 자바스크립트 엔진이 outer 함수의 실행 컨텍스트를 해제하지 않았기 떄문이다.\r\n본래대로라면 함수가 리턴되는 순간 실행 컨텍스트가 해제되지만 몇가지 조건이 갖추어지면 함수가 리턴되는 상황에서도 실행 컨텍스트가 해제되지 않는다. 그 조건은 아래와 같다</p>\n</li>\n</ol>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. 함수가 리턴할 때 자기자신이 아닌 또다른 함수를 리턴한다.\r\n리턴되는 함수를 inner라 하자.\r\n\r\n2. inner 함수 내부에서 현재 실행중인 함수의 지역변수를 참조한다\n</code></pre>\n<p>위와 같은 조건에서는 함수가 종료되어도 실행 컨텍스트가 해제되지 않는다. 이렇게 되면 outer 변수의 free에 접근할 수 있는 수단은 inner함수를 호출하는 방법 외에는 없다.<br>\n<br>\n이로서 inner 함수가 자유변수를 사용할 수 있게 되었고, 오직 inner 함수를 통해서만 자유변수에 접근할 수 있게 되었다. 객체지향 프로그래밍을 공부해 본 사람이라면 이러한 개념이 객체가 제공하는 private 변수와 유사하다는 것을 느꼇을 것이다. 실제로 객체의 private 변수와 클로저의 자유변수는 개념상 거의 유사하고 추구하는 목적은 같다. 이러한 유사성에 대하여 윌리엄스 칼리지의 Daniel Barowy 교수는 다음과 같이 말했다</p>\n<blockquote>\n<p>Objects are kind of closure</p>\n</blockquote>\n<p><code>(www.cs.williams.edu/~dbarowy/cs334s18/assets/lecture_2018-04-10.pdf)</code><br>\n<br>\n그리고 Norman Adams라는 사람은 다음과 같이 말했다</p>\n<blockquote>\n<p>Objects are a poor man’s closures<br>\n(객체란 실력이 부족한 사람들이 사용하는 클로저이다)</p>\n</blockquote>\n<p><code>(Ken Dickey, \"Scheming with Objects\")</code><br>\n<br>\n반면 소르본 대학의 명예교수인 크리스티안(Christian Queinnec)은 다음과 같이 말했다</p>\n<blockquote>\n<p>많은 사람들이 객체를 두고 실력이 부족한 사람들이 사용하는 클로저라고 말하는데,<br>\n사실 클로저는 실력이 부족한 사람들이 사용하는 객체이다.<br>\n(although many people consider objects to be ‘poor man’s closures, closures are in fact poor man’s objects)</p>\n</blockquote>\n<p><code>(people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html)</code><br>\n<br>\n위의 주장들은 누구의 주장이 옮다는 차원을 넘어서 클로저와 객체가 같은 지향점을 향한다는 점을 시사한다.<br>\n<br>\n이 둘은 모두 캡슐화를 지향한다. 그 목표를 달성하는 수단이 다를 뿐이다<br>\n이런 점을 감안하면 굳이 클로저에 정의에 얽매일 필요가 없다. 자유변수를 하나의 함수에서만 접근할 수 있으면 그 함수는 클로저가 아니더라도 클로저처럼 사용할 수 있다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    let free = 0;\r\n\r\n    function func() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        return ++free;\r\n    }\r\n}\r\n\r\nconsole.log(func());\r\nconsole.log(func());\r\nconsole.log(func());\n</code></pre>\n<p>위의 코드에서 함수 func는 정의상으로는 클로저가 아닐지 몰라도 의미상으로는 클로저와 같다. 왜 그런지 알아보자.<br>\n<br>\n함수 func는 자유변수 free를 참조한다. 그리고 변수 free는 func를 통해서만 접근할 수 있다. 왜냐하면 블록 스코프 <code>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000 }</code> 내부에 정의된 let은 블록 스코프에서 벗어나는 순간 접근이 불가하기 때문이다.<br>\n<br>\n본래대로라면 블록스코프 <code>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000 }</code> 를 벗어난 순간 변수 free는 메모리에서 해제되어 접근할 수 있는 방법이 없어지게 된다. 하지만 블록 스코프를 벗어나는 시점에 지역변수 free를 참조하는 함수가 존재하는지 검사하는데 위의 경우 함수 func가 변수 free를 참조하기 때문에 블록 스코프는 메모리에서 해제되지 않는다. 메모리에서 해제되지는 않지만 블록스코프를 벗어난 지점에서 변수 free에 직접 접근할 수는 없다. 변수 free는 func 함수를 호출하여 참조할 수 있고 그 외에 접근할 수 있는 수단은 없다. 자유변수를 참조할 수 있는 방법을 강제로 제한해 버린다는 측면에서 이 패턴은 클로저로 분류될 수 있다.<br>\n그렇다면 함수 func는 변수 free를 참조하는 스코프를 클로저스코프로 분류하는가? 아래 그림은 변수 free가 어느 스코프에서 참조되는지를 보여준다</p>\n<p><img src=\"/assets/blog/closure/2.png\" alt=\"aaa\"></p>\n<!-- ![aaa](./img_클로저의_뜻과_존재의의/2.png) -->\n<p>변수 free는 block 스코프에서 참조된다. 그렇다면 변수 free가 클로저스코프에서 참조되지 않으니 함수 func는 클로저가 아니라고 말할 수 있는가? 정의상으로 클로저가 맞던 틀리던 간에 결과적으로 위의 자유변수 free는 객체지향 언어의 private 변수와 같은 개념으로 func함수가 접근할 수 있다. 따라서 클로저스코프를 생성하지는 않으나 함수를 사용하는 입장에서 func함수를 클로저로 보아도 큰 지장은 없다. 클로저의 정의에 얾매일 필요가 없다는 말은 이런 이유 때문이다.<br>\n<br>\n주제를 바꿔서 이야기해보자면, 상태를 보존한다는 개념이 구체적으로 어떤 유용함이 있는가? 게임의 예를 들어보자.<br>\n<br>\n1:1 격투게임을 구현할 때 각 플레이어의 HP를 감소시키려는 함수를 구현한다. 클로저를 사용하지 않은 상태에서 순수함수의 형태로 구현하면 아래와 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function modifyHP(currentHP, damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    return currentHP - damage;\r\n}\n</code></pre>\n<p>그리고 위의 함수는 아래와 같은 형태로 사용된다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const damage = getDamage();\r\n\r\nconst currentHP = getCurrentHP();\r\n\r\nconst modifiedHP = modifyHP(currentHP, damage);\r\n\r\nsaveHP(modifiedHP);\n</code></pre>\n<p>만일 상태가 없는 함수를 사용한다면 상태를 불러와 함수를 호출하고 그 리턴값을 다른 함수를 통하여 저장해야 한다<br>\n<br>\n반면 HP감소 함수를 클로저로 구현하면 아래와 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function hp수정(maxHP) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    let currentHP = maxHP;\r\n\r\n    return function (damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        return currentHP - damage;\r\n    }\r\n};\r\n\r\nconst modifyHP = outer(100);\n</code></pre>\n<p>그리고 위의 클로저 함수는 아래와 같이 사용된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const damage = getDamage()\r\n\r\nconst modifiedHP = modifyHP(damage)\n</code></pre>\n<p>내부에서 상태를 저장하므로 외부에서 상태를 불러올 필요가 없고 외부 함수를 통하여 상태를 저장할 필요가 없다.<br>\n한마디로 클로저는 개발의 편의성을 제공한다.<br>\n<br>\n그러나 함수 외부에서 상태를 참조하는 것이 목적이라면 전역 변수를 참조하면 되는데 굳이 외부함수를 만들어 가면서까지 상태를 저장할 필요가 있는지 그 실용성에 의구심을 가질 수가 있다. 위에서 구현한 HP 감소 함수를 전역 변수를 사용하여 구현하면 다음과 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">let currentHP = maxHP;\r\n\r\nfunction modifyHP(damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    return currentHP - damage;\r\n}\n</code></pre>\n<p>위의 코드는 클로저에 비하여 직관적이고 코드량이 적다. 모든 면에서 클로저보다 이상적으로 보이기도 한다.<br>\n<br>\n소규모 프로젝트를 진행중이라면 이런 식의 코드 작성이 더 나은 선택일 수도 있다. 하지만 20명 이상이 참여하는 대규모 프론트엔드 프로젝트라면 이야기가 달라질 수도 있다.<br>\n<br>\n위에서 정의한 currentHP 변수는 전역변수이기 때문에 나 뿐만이 아닌 다른 모든 팀원이 접근할 수 있다. 따라서 다른 팀원이 currentHP 변수에 접근하지 않아야 한다는 보장이 필요하다. 만일 다른 팀원이 currentHP 변수에 접근하여 내가 의도한 것과 다른 방식으로 변수값을 조정하는 경우 플레이어의 hp가 의도치 않은 상황에 증가하거나 감소하는 상황이 발생하여 게임 진행 자체가 불가능하게 될 것이다. 이와 같은 상황을 방지하려면 전역변수를 생성할 때 마다 다른 모든 팀원을 대상으로 공지사항을 알려줘야 한다.</p>\n<blockquote>\n<p>currentHP는 제가 만든 변수이니 이 변수를 사용하지 말라.<br>\ncurrentMP도 접근하지 말라<br>\ncurrentPowerGauge 접근하면 안되고 …</p>\n</blockquote>\n<p>코드를 작성할 수록 전역 변수는 늘어난다. 프로그램 실행중의 에러를 방지하려면 이 모든것을 문서화 해야 할 것이다. 이 자체만으로도 어려운 일이지만 만일 나 뿐만이 아닌 다른 모든 팀원들이 전역 변수를 사용한다면? 접근해서는 안되는 수백개의 전역변수를 기억한 채로 코드를 작성해야 한다. 이것은 고역이고 가능하지도 않다.<br>\n<br>\n더 큰 문제는 누군가가 currentHP에 임의로 접근하여 의도치 않은 상황에 hp가 증가하거나 감소하는 경우, 디버깅 대상이 되는 코드는 프로젝트 내의 전체 코드가 된다. 프로그램 내에 어떠한 문맥에서도 전역변수에 접근할 수 있기 때문이다. 이 경우 어떻게 디버깅을 진행할 것인가 ? 팀원 한명한명을 불러서 네가 currentHP에 접근했는지 심문할 것인가? 사실 개발자는 자기가 작성한 코드를 일일이 기억할 수 없다. 따라서 ‘나는 currentHP를 건드리지 않았는데요’ 라고 어떤 개발자가 말했다고 해서 그 사람이 currentHP에 접근하지 않았다는 보장이 없다. 만일 전체 소스코드가 충분히 복잡하고 해당 버그를 재현하기도 어려운 상황이라면 최악의 상황에는 버그를 수정할 수 없는 상황까지 발생할 수 있다.<br>\n<br>\n이처럼 전역변수를 사용하는 데서 오는 코스트는 감당하기 어렵다. 개발자들은 디버깅 코스트를 최소화하기 위하여 오랜기간 고민하였고 그 결과 나온 개념이 함수형 프로그래밍 진형에서는 클로저이고 객체지향 프로그래밍 진형에서는 프라이빗(private) 멤버변수라는 형태로 고안되었다. 그 결과 변수가 오용될 수 있는 범위를 극적으로 줄일 수 있게 되었다. 더불어 상태값이 잘못 할당되어 프로그램이 오작동 될 때 디버깅 해야하는 코드 범위를 줄여 막대한 생산성 향상을 이끌어 내었다.</p>\n<p>— 끝</p>"
    },
    "url": "/posts/210505_closure",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/210505_closure.md")
  }
}, children);

});
</script><astro-root uid="Q1InR"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95"><p class="title">크로미움에서 requestAnimationFrame이 수행되는 과정</p></a></header><time>2021.05.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("Q1InR", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "크로미움에서 requestAnimationFrame이 수행되는 과정",
    "description": "rAF API의 작동과정",
    "publishDate": "2021.05.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "크로미움에서-requestanimationframe이-수행되는-과정",
        "text": "크로미움에서 requestAnimationFrame이 수행되는 과정"
      }, {
        "depth": 4,
        "slug": "참고",
        "text": "참고"
      }],
      "source": "\r\n### 크로미움에서 requestAnimationFrame이 수행되는 과정\r\n\r\n( 최종수정일 : 2021년 5월 3일 AM 9:29)\r\n\r\nrequestAnimationFrame 함수 줄여서 rAF를 이해하려면 rAF가 만들어진 배경을 이해하는 것이 좋다.\r\n\r\nrAF가 존재하기 전 웹페이지에서 매끄러운 애니메이션을 구현할 때는 setInterval 함수에 의존해야 했다.\r\n\r\n하지만 setInterval 함수는 크게 3가지 문제가 존재했다.\r\n\r\n첫째로 이 함수는 5회 이상 반복되는 주기부터 정밀도가 최소 4ms로 강제 조정된다.\r\n\r\n유저가 setInterval의 timeout주기를 1ms로 설정한다 하여도 5회 이상 반복되는 시점부터는 4ms로 강제 조정된다. 이를 타이머의 클램핑 기능이라고 한다.\r\n\r\n이는 WHATWG HTML Living Standard에 명시되어 있다\r\n\r\n> If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\r\n`(https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval)`\r\n\r\n그리고 이러한 명세는 크로미움에 반영되어 있다\r\n\r\n> // Step 11 of the algorithm at https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html requires that a timeout less than 4ms is increased to 4ms when the nesting level is greater than 5.\\\r\n> \\\r\n> constexpr int kMaxTimerNestingLevel = 5;\\\r\n> constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.cc)`\r\n\r\n이러한 조치는 setInterval 함수보다 낮은 우선순위를 가진 테스크들의 기아 상태를 방지하기 위하여 고안되었다.\r\n\r\n이러한 클램핑 기능은 기아 상태를 방지하는 차원에서는 효율적이지만 정밀한 타이머를 구현하는 데는 방해거리가 된다.\r\n\r\n두번째 문제 역시 정밀도 문제인데, setInterval의 두번째 인자인 timeout은 소수점 이하를 무시하고 정수로 해석된다.\r\n\r\n예를 들어서 60프레임을 구현하려는 의도로 1초를 60으로 나눈 16.666ms 를 setInterval의 timeout 인자로 넣는다 하더라도 실제 작동시에는 16ms로 인식된다.\r\n\r\n자바스크립트 코드 상에서 에러 메시지를 내뱉지는 않지만 블링크 엔진 내부에서는 소수점 이하가 무시된 값인 16으로 인자값을 받게 되기 때문이다.\r\n\r\n그 이유는 setInterval의 구현체의 timeout 인자 타입이 int이기 때문이다.\r\n\r\n다음은 setTimeout 구현체의 매개변수별 타입이다.\r\n\r\n```cpp\r\nint WindowOrWorkerGlobalScope::setInterval(\r\n\r\n    ScriptState* script_state,\r\n\r\n    EventTarget& event_target,\r\n\r\n    V8Function* handler,\r\n\r\n    int timeout,\r\n\r\n    const HeapVector<ScriptValue>& arguments)\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)`\r\n\r\n\r\n위에서 4번째 값이 setTimeout의 두번째 인자인 timeout 값이다.\r\n\r\n이처럼 소수점이 무시되기 때문에 1ms 미만의 정밀도를 제어할 수 없다.\r\n\r\n세번째로 setInterval 함수는 모니터의 주사율에 근거하여 프레임을 갱신할 수가 없다.\r\n\r\nrAF가 재정되기 이전의 대부분의 모니터는 주사율이 60Hz로 고정되어 있었다. 하지만 최근 출시되는 모니터는 75Hz, 120Hz, 144Hz, 240Hz로 주사율이 다양하다.\r\n\r\n가령 매끄러운 애니메이션을 위해 60프레임을 염두해 두고 16.66ms 단위로 화면을 갱신하기로 했다고 가정해 보자. 이 경우 코드는 아래와 같이 된다.\r\n\r\n```javascript\r\n// 두번째 매개변수의 소수점 이하를 무시하기 때문에 16.66을 반올림한 값을 대입한다\r\n\r\nsetInterval(animateFunction, 17) ;\r\n```\r\n\r\n위의 함수를 실행할 경우 가장 이상적인 시나리오대로 60프레임이 구현된다고 하더라도 주사율이 60Hz을 초과하는 모니터에서 그 이상의 프레임을 보장하기 어렵다.\r\n\r\n그렇다고 240Hz에 맞추어 4.16ms 단위로 화면을 갱신한다면 240hz미만의 모니터에서는 자원의 낭비가 심해진다.\r\n\r\n결국 모니터 주사율에 적응적으로 변화하는 갱신은 setInterval 함수로 해결할 수 없다.\r\n\r\n이와 같은 문제로 인하여 더욱 정밀한 프레임 갱신 방법론에 대한 요구가 있었고 그 결과로 requestAnimationFrame 함수가 탄생하였다.\r\n\r\nrequestAnimationFrame 은 위의 3가지 문제를 처리해 준다. 즉 다음과 같다.\r\n\r\n첫째로 타이머 수치가 임의로 클램핑되지 않는다.\r\n\r\n둘째로 정밀도를 나노초 단위로 제어가 가능하다.\r\n\r\n셋째로 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.\r\n\r\n모니터의 주사율에 근거하여 프레임이 가변적으로 갱신된다는 점은 흥미롭다. 실제로 그렇게 작동하는지 직접 확인해 보겠다.\r\n\r\n```html\r\n<html>\r\n   <body>\r\n      <script>\r\n         (()=>{\r\n         \tlet prev = performance.now() ;\r\n         \tlet cnt = 0 ; \r\n         \tfunction animateFunc(){\r\n         \r\n         \t\tlet curr = performance.now() ;\r\n         \t\tconsole.log(`${curr - prev} ms`) ;\r\n         \t\tprev = curr ;\r\n         \t\t\r\n         \t\tif(++cnt < 100) {\r\n         \t\t\trequestAnimationFrame(animateFunc) ; \r\n         \t\t}\r\n         \t}\r\n         \trequestAnimationFrame(animateFunc);\r\n         })()\r\n      <\/script>\r\n   </body>\r\n</html>\r\n```\r\n\r\n위의 코드는 rAF를 반복 호출한다. 그리고 이전에 호출된 rAF 콜백함수와의 인터벌을 console.log로 출력한다\r\n\r\n위의 코드를 먼저 아래의 60Hz 모니터에서 실행해 보았다\r\n\r\n![aaa](/assets/blog/210523_raf/raf1.png)\r\n\r\n결과는 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf2.png)\r\n\r\n값은 대체로 16.6ms에 근사한 값을 보여준다. 사실 실행한 컴퓨터의 CPU 성능이 좋지 않아서 오차가 비교적 크게 발생하였다. 이 오차는 단일 프로세서의 처리 속도가 빠를수록 감소한다.\r\n\r\n장비를 바꾸어서 144Hz 모니터에서 같은 코드를 수행하였다.\r\n\r\n![aaa](/assets/blog/210523_raf/raf3.png)\r\n\r\n결과는 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf4.png)\r\n\r\n144Hz는 1초에 144회 화면을 갱신하므로 1프레임이 갱신되는 주기는 약 6.94ms이다.\r\n\r\n위의 수치는 약 6.94ms에 근사한 수치를 보여준다. 각 프레임별로 오차가 적은 이유는 CPU의 성능이 앞선 60Hz 테스트에서 사용한 CPU보다 빠르기 때문이다.\r\n\r\n이처럼 모니터 주사율에 가변적으로 rAF 호출 주기가 변경되는 이유는 rAF 함수가 모니터에서 제공하는 vsync pulse를 기반으로 작동하기 때문이다.\r\n\r\nvertical sync pulse, 줄여서 vsync pulse는 모니터에서 제공하는 전기적 신호인데 이 신호는 모니터가 화면상에 새로운 픽셀을 뿌리는 주기와 연관이 있다.\r\n\r\n모니터는 화면상에 새로운 픽셀을 드로잉하고 다음번 픽셀의 드로잉을 준비하기 시작할 때 vertical sync pulse를 생성한다. 예를 들어 60Hz 주사율의 모니터는 1초에 60번 새로운 화면을 갱신하는데 이 갱신 주기는 일정하다. 따라서 1초를 60으로 나눈값인 16.66ms 간격으로 vsync pulse를 생성한다.\r\n\r\n이 전기적 신호는 그래픽카드가 감지할 수 있다. 이 감지된 신호를 기반으로 requestAnimationFrame의 콜백함수가 호출되기 때문에 타이머 수치가 클램핑되지 않고, 나노세컨드 단위로 정밀하며, 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.\r\n\r\n이러한 프로세스가 구체적으로 어떻게 구현되어 있을지 추측해 보자.\r\n\r\n크로미움에서는 탭을 하나 생성할 때 마다 렌더러 프로세스가 한개씩 생성된다. 각 탭은 하나의 렌더러 프로세스를 가지고 있다.\r\n\r\n이 렌더러 프로세스는 탭 안에 보이는 화면을 렌더링하는 역할을 수행한다.\r\n\r\n그러니 이 렌더러 프로세스 내부에 vsync pulse를 감지하는 스레드가 존재한다고 생각할 수 있다.\r\n\r\nvsync 스레드가 vsync를 감지하여 자바스크립트를 실행하는 메인 스레드에게 신호를 전파하고 이 신호를 받은 메인 스레드가 requestAnimationFrame의 콜백함수를 호출하는 방식으로 수행된다고 생각할 수 있다.\r\n\r\n그러나 렌더러 프로세스는 샌드박스화 되어 있으므로 vsync 신호를 보내는 gpu 디바이스에 직접 억세스할 수 없다.\r\n\r\n샌드박스란 일종의 제한된 환경이며 샌드박스 안에 존재하는 프로세스는 CPU와 메모리를 제외한 다른 리소스에 접근할 수 없다.\r\n\r\n따라서 렌더러 프로세스는 샌드박스 환경 밖에 있는 GPU 프로세스와의 IPC를 통하여 vsync신호를 전달받게 된다. 도식화하면 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf5.png)\r\n\r\n크로미움 브라우저 내부의 GPU 프로세스는 vsync 스레드를 가지고 있다. 이 스레드는 OS가 제공하는 vsync API를 이용하여 vsync 주기를 감지한다.\r\n\r\n예를들어 windows OS의 경우 vsync API는 IDXGIOutput 클래스가 제공하는데 이 클래스가 제공하는 waitForVBlank 등의 메소드를 사용하여 vsync 주기를 감지한다. 아래 코드는 windows용 vsync 스레드가 v싱크 신호 감지에 사용하는 메소드이다.\r\n\r\n```cpp\r\nvoid VSyncThreadWin::WaitForVSync() {\r\n\r\n  // .. 생략\r\n  const HMONITOR monitor = MonitorFromWindow(nullptr, MONITOR_DEFAULTTOPRIMARY);\r\n\r\n  if (primary_monitor_ != monitor) {\r\n    primary_monitor_ = monitor;\r\n    primary_output_ = DXGIOutputFromMonitor(monitor, d3d11_device_);\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  const bool wait_for_vblank_succeeded =\r\n      primary_output_ && SUCCEEDED(primary_output_->WaitForVBlank());\r\n\r\n  // .. 생략\r\n\r\n  if (!wait_for_vblank_succeeded ||\r\n      wait_for_vblank_elapsed_time < kVBlankIntervalThreshold) {\r\n    Sleep(static_cast<DWORD>(vsync_interval.InMillisecondsRoundedUp()));\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  if (!observers_.empty()) {\r\n    vsync_thread_.task_runner()->PostTask(\r\n        FROM_HERE,\r\n        base::BindOnce(&VSyncThreadWin::WaitForVSync, base::Unretained(this)));\r\n    const base::TimeTicks vsync_time = base::TimeTicks::Now();\r\n    for (auto* obs : observers_)\r\n      obs->OnVSync(vsync_time, vsync_interval);\r\n  } else {\r\n    is_idle_ = true;\r\n  }\r\n}\r\n```\r\n\r\n`< 참조 : ui/gl/vsync_thread_win.cc>`\r\n\r\n위의 코드에서 DXGIOutputFromMonitor함수는 프라이머리로 사용중인 모니터의 정보를 가져온다. 그리고 해당 모니터를 대상으로 WaitForVBlank 메소드를 호출하여 v싱크 주기를 감시한다. 만일 v싱크 주기가 감지된다면 옵저버인 DirectCompositionChildSurfaceWin 클래스의 OnVSync 메소드가 트리거되고 프레임 생성 파이프라인을 시작한다. 이 파이프라인의 시작신호를 BeginFrame이라고 한다.\r\n\r\n크로미움은 BeginFrame을 다음과 같이 정의하고 있다\r\n\r\n> BeginFrame is the mechanism that tells us that now is a good time to start making a frame\\\r\n> (BeginFrame은 메커니즘인데 이 메커니즘은 지금이 프레임의 생성을 시작하는 좋은 타이밍이라는 것을 알려준다.)\r\n\r\n`(cc/scheduler/scheduler.cc)`\r\n\r\nGPU 프로세스는 렌더러 프로세스에게 BeginFrame 신호를 보낸다. 이 때 BeginFrame은 하나의 테스크로서 간주되며 스케줄러에 의해 스케줄링된다. 이 BeginFrame 신호는 렌더러 프로세스의 impl 스레드에게 전달된다.\r\n\r\n사실 렌더러 프로세스에는 크게 2가지의 스레드가 존재한다. 메인스레드와 impl 스레드가 그것인데 각각의 스레드는 별도의 스케줄러를 가지고 있다.\r\n\r\nGPU 프로세서로부터 전달받는 BeginFrame 신호는 impl 스레드가 전달받으며 impl 스레드의 스케줄러에 의해 스케줄링된다. 이때 스케줄링되는 테스크는 impl 스레드에서 수행하는 BeginFrame이라는 의미에서 BeginImplFrame이라고 부른다. BeginImplFrame 테스크가 수행되는 시점에서 impl 스레드는 프레임 생산이 시작되었음을 인지한다.\r\n\r\nimpl 스레드는 BeginImplFrame 테스크의 수행도중 메인 스레드에게 BeginMainFrame 테스크를 수행하라는 메시지를 전송한다. 이 테스크를 수행하는 시점에서 메인 스레드는 프레임 생산이 시작되었음을 인지한다.\r\n\r\n지금까지의 과정을 요약하면 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf6.png)\r\n\r\n위의 과정은 매우 간략화된 형태이지만 사실 BeginMainFrame은 메인스레드의 이벤트 루프 내부에서 테스크의 형태로 실행된다.\r\n\r\n여기까지 이 글을 읽은 독자라면 이벤트 루프가 여러개의 테스크 큐를 대상으로 우선순위에 기반하여 수행된다는 사실을 알고있을 것이다.\r\n\r\n따라서 BeginMainFrame 또한 작업이 실행되기 전까지 특정한 테스크 큐에 저장되어 있다가 해당 테스크 큐의 순서가 오면 dequeue되어 수행된다. BeginMainFrame은 작업이 수행되기 전까지 컴포지터 테스크 큐에 저장된다.\r\n\r\n이 BeginMainFrame 테스크가 메인스레드 내부에서 하는 일을 요약하면 아래와 같다.\r\n\r\n가장 먼저 유저 입력에 대한 이벤트리스너를 수행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.\r\n\r\n곧이어 requestAnimationFrame의 콜백함수가 스케줄러에 등록되어 있다면 해당 함수를 실행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.\r\n\r\n이 시점에서 rAF 콜백함수가 종료되지만 변경사항이 바로 모니터에 적용되는 것은 아니며 모니터의 갱신까지는 몇가지 추가 단계를 필요로 한다.\r\n\r\nrAF의 종료이후 LocalFrameView 클래스의 UpdateLifeCycle 메소드를 수행한다. 이 테스크는 페이지의 최종 변경사항을 레이아웃 트리에 적용시킨다. 이 레이아웃 트리의 변경사항은 최종적으로 레이어 트리와 프로퍼티 트리를 생성한다.\r\n\r\n변경사항의 반영이 종료되면 레이어 트리의 커밋을 수행할 준비가 되었다는 신호인 NotifyReadyToCommit를 impl 스레드에게 전송한다. 이 메시지의 전송작업은 메인스레드의 프록시 클래스인 ProxyMain이 수행한다. 이 때 impl 스레드에게 뮤텍스를 보내며 메인 스레드는 블록킹 상태에 빠진다. 메인스레드가 블록킹 상태에 빠지는 이유는 impl 스레드가 레이어 트리를 복제하는 작업이 완료되기 전 까지는 레이어 트리를 수정해선 안되기 때문이다.\r\n\r\n여기까지가 메인스레드의 렌더링 작업이고 이후의 작업은 impl 스레드가 수행한다.\r\n\r\nNotifyReadyToCommit 신호를 전달받은 impl 스레드가 커밋 준비를 마친다면 ProxyImpl 클래스를 이용하여 메인 스레드의 데이터를 복제하여 컴포지터 스레드만이 접근할 수 있는 데이터를 생성한다. 만일 이러한 복제물을 생성하지 않은 채 메인스레드와 impl 스레드가 레이어 트리를 공유하여 사용한다면 메인스레드에서 변경작업 중인 레이어 트리의 변경작업이 완료되기도 전에 impl 스레드 측에서 임의로 디스플레이에 출력하는 사태가 발생할 수 있다. 이 경우 모니터의 티어링 현상이 발생할 수 있다.\r\n\r\n레이어 트리의 복제 작업이 완료되면 impl 스레드가 데이터의 복제가 완료되었다는 신호를 메인 스레드에게 건내주고 메인스레드는 블록킹 상태에서 벗어나 테스크를 재개할 수 있게된다. impl 스레드는 복제된 데이터를 기반으로 컴포지팅 작업을 수행한다. 컴포지팅은 화면상에 출력될 비트맵을 생성하는 작업이다. 비트맵의 생성이 완료되면 GPU 프로세스가 드로잉 작업을 수행하고 최종 결과물이 모니터에 드로잉된다.\r\n\r\n여기까지가 프레임생성의 풀 파이프라인이고 rAF의 콜백함수는 이러한 프레임 생성의 전체 파이프라인 중 BeginMainFrame 테스크의 일부분으로서 실행된다. 위의 설명은 전체 파이프라인을 매우 축약한 것이며 실제 과정은 더욱 디테일하다. 본 문서는 풀 파이프라인 중 rAF가 실행되는 과정에 집중하여 작성되었다.\r\n\r\n---\r\n\r\n#### 참고\r\n\r\n[Youtube - Life of a pixel (Chrome University 2019)](https://www.youtube.com/watch?v=m-J-tbAlFic)\r\n\r\n[웹사이트 : Chromium Code Search](https://source.chromium.org/chromium)\r\n\r\n[크로미움 문서 : How cc Works](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/how_cc_works.md)\r\n\r\n[크로미움 문서 : Blink Scheduler](https://chromium.googlesource.com/chromium/src/+/66.0.3359.158/third_party/WebKit/Source/platform/scheduler/README.md)",
      "html": "<h3 id=\"크로미움에서-requestanimationframe이-수행되는-과정\">크로미움에서 requestAnimationFrame이 수행되는 과정</h3>\n<p>( 최종수정일 : 2021년 5월 3일 AM 9:29)</p>\n<p>requestAnimationFrame 함수 줄여서 rAF를 이해하려면 rAF가 만들어진 배경을 이해하는 것이 좋다.</p>\n<p>rAF가 존재하기 전 웹페이지에서 매끄러운 애니메이션을 구현할 때는 setInterval 함수에 의존해야 했다.</p>\n<p>하지만 setInterval 함수는 크게 3가지 문제가 존재했다.</p>\n<p>첫째로 이 함수는 5회 이상 반복되는 주기부터 정밀도가 최소 4ms로 강제 조정된다.</p>\n<p>유저가 setInterval의 timeout주기를 1ms로 설정한다 하여도 5회 이상 반복되는 시점부터는 4ms로 강제 조정된다. 이를 타이머의 클램핑 기능이라고 한다.</p>\n<p>이는 WHATWG HTML Living Standard에 명시되어 있다</p>\n<blockquote>\n<p>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\r\n<code>(https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval)</code></p>\n</blockquote>\n<p>그리고 이러한 명세는 크로미움에 반영되어 있다</p>\n<blockquote>\n<p>// Step 11 of the algorithm at <a href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html\">https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html</a> requires that a timeout less than 4ms is increased to 4ms when the nesting level is greater than 5.<br>\n<br>\nconstexpr int kMaxTimerNestingLevel = 5;<br>\nconstexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);</p>\n</blockquote>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.cc)</code></p>\n<p>이러한 조치는 setInterval 함수보다 낮은 우선순위를 가진 테스크들의 기아 상태를 방지하기 위하여 고안되었다.</p>\n<p>이러한 클램핑 기능은 기아 상태를 방지하는 차원에서는 효율적이지만 정밀한 타이머를 구현하는 데는 방해거리가 된다.</p>\n<p>두번째 문제 역시 정밀도 문제인데, setInterval의 두번째 인자인 timeout은 소수점 이하를 무시하고 정수로 해석된다.</p>\n<p>예를 들어서 60프레임을 구현하려는 의도로 1초를 60으로 나눈 16.666ms 를 setInterval의 timeout 인자로 넣는다 하더라도 실제 작동시에는 16ms로 인식된다.</p>\n<p>자바스크립트 코드 상에서 에러 메시지를 내뱉지는 않지만 블링크 엔진 내부에서는 소수점 이하가 무시된 값인 16으로 인자값을 받게 되기 때문이다.</p>\n<p>그 이유는 setInterval의 구현체의 timeout 인자 타입이 int이기 때문이다.</p>\n<p>다음은 setTimeout 구현체의 매개변수별 타입이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int WindowOrWorkerGlobalScope::setInterval(\r\n\r\n    ScriptState* script_state,\r\n\r\n    EventTarget&amp; event_target,\r\n\r\n    V8Function* handler,\r\n\r\n    int timeout,\r\n\r\n    const HeapVector&lt;ScriptValue>&amp; arguments)\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)</code></p>\n<p>위에서 4번째 값이 setTimeout의 두번째 인자인 timeout 값이다.</p>\n<p>이처럼 소수점이 무시되기 때문에 1ms 미만의 정밀도를 제어할 수 없다.</p>\n<p>세번째로 setInterval 함수는 모니터의 주사율에 근거하여 프레임을 갱신할 수가 없다.</p>\n<p>rAF가 재정되기 이전의 대부분의 모니터는 주사율이 60Hz로 고정되어 있었다. 하지만 최근 출시되는 모니터는 75Hz, 120Hz, 144Hz, 240Hz로 주사율이 다양하다.</p>\n<p>가령 매끄러운 애니메이션을 위해 60프레임을 염두해 두고 16.66ms 단위로 화면을 갱신하기로 했다고 가정해 보자. 이 경우 코드는 아래와 같이 된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">// 두번째 매개변수의 소수점 이하를 무시하기 때문에 16.66을 반올림한 값을 대입한다\r\n\r\nsetInterval(animateFunction, 17) ;\n</code></pre>\n<p>위의 함수를 실행할 경우 가장 이상적인 시나리오대로 60프레임이 구현된다고 하더라도 주사율이 60Hz을 초과하는 모니터에서 그 이상의 프레임을 보장하기 어렵다.</p>\n<p>그렇다고 240Hz에 맞추어 4.16ms 단위로 화면을 갱신한다면 240hz미만의 모니터에서는 자원의 낭비가 심해진다.</p>\n<p>결국 모니터 주사율에 적응적으로 변화하는 갱신은 setInterval 함수로 해결할 수 없다.</p>\n<p>이와 같은 문제로 인하여 더욱 정밀한 프레임 갱신 방법론에 대한 요구가 있었고 그 결과로 requestAnimationFrame 함수가 탄생하였다.</p>\n<p>requestAnimationFrame 은 위의 3가지 문제를 처리해 준다. 즉 다음과 같다.</p>\n<p>첫째로 타이머 수치가 임의로 클램핑되지 않는다.</p>\n<p>둘째로 정밀도를 나노초 단위로 제어가 가능하다.</p>\n<p>셋째로 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.</p>\n<p>모니터의 주사율에 근거하여 프레임이 가변적으로 갱신된다는 점은 흥미롭다. 실제로 그렇게 작동하는지 직접 확인해 보겠다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;html>\r\n   &lt;body>\r\n      &lt;script>\r\n         (()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \tlet prev = performance.now() ;\r\n         \tlet cnt = 0 ; \r\n         \tfunction animateFunc()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \r\n         \t\tlet curr = performance.now() ;\r\n         \t\tconsole.log(`$ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000curr - prev} ms`) ;\r\n         \t\tprev = curr ;\r\n         \t\t\r\n         \t\tif(++cnt &lt; 100) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \t\t\trequestAnimationFrame(animateFunc) ; \r\n         \t\t}\r\n         \t}\r\n         \trequestAnimationFrame(animateFunc);\r\n         })()\r\n      &lt;/script>\r\n   &lt;/body>\r\n&lt;/html>\n</code></pre>\n<p>위의 코드는 rAF를 반복 호출한다. 그리고 이전에 호출된 rAF 콜백함수와의 인터벌을 console.log로 출력한다</p>\n<p>위의 코드를 먼저 아래의 60Hz 모니터에서 실행해 보았다</p>\n<p><img src=\"/assets/blog/210523_raf/raf1.png\" alt=\"aaa\"></p>\n<p>결과는 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf2.png\" alt=\"aaa\"></p>\n<p>값은 대체로 16.6ms에 근사한 값을 보여준다. 사실 실행한 컴퓨터의 CPU 성능이 좋지 않아서 오차가 비교적 크게 발생하였다. 이 오차는 단일 프로세서의 처리 속도가 빠를수록 감소한다.</p>\n<p>장비를 바꾸어서 144Hz 모니터에서 같은 코드를 수행하였다.</p>\n<p><img src=\"/assets/blog/210523_raf/raf3.png\" alt=\"aaa\"></p>\n<p>결과는 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf4.png\" alt=\"aaa\"></p>\n<p>144Hz는 1초에 144회 화면을 갱신하므로 1프레임이 갱신되는 주기는 약 6.94ms이다.</p>\n<p>위의 수치는 약 6.94ms에 근사한 수치를 보여준다. 각 프레임별로 오차가 적은 이유는 CPU의 성능이 앞선 60Hz 테스트에서 사용한 CPU보다 빠르기 때문이다.</p>\n<p>이처럼 모니터 주사율에 가변적으로 rAF 호출 주기가 변경되는 이유는 rAF 함수가 모니터에서 제공하는 vsync pulse를 기반으로 작동하기 때문이다.</p>\n<p>vertical sync pulse, 줄여서 vsync pulse는 모니터에서 제공하는 전기적 신호인데 이 신호는 모니터가 화면상에 새로운 픽셀을 뿌리는 주기와 연관이 있다.</p>\n<p>모니터는 화면상에 새로운 픽셀을 드로잉하고 다음번 픽셀의 드로잉을 준비하기 시작할 때 vertical sync pulse를 생성한다. 예를 들어 60Hz 주사율의 모니터는 1초에 60번 새로운 화면을 갱신하는데 이 갱신 주기는 일정하다. 따라서 1초를 60으로 나눈값인 16.66ms 간격으로 vsync pulse를 생성한다.</p>\n<p>이 전기적 신호는 그래픽카드가 감지할 수 있다. 이 감지된 신호를 기반으로 requestAnimationFrame의 콜백함수가 호출되기 때문에 타이머 수치가 클램핑되지 않고, 나노세컨드 단위로 정밀하며, 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.</p>\n<p>이러한 프로세스가 구체적으로 어떻게 구현되어 있을지 추측해 보자.</p>\n<p>크로미움에서는 탭을 하나 생성할 때 마다 렌더러 프로세스가 한개씩 생성된다. 각 탭은 하나의 렌더러 프로세스를 가지고 있다.</p>\n<p>이 렌더러 프로세스는 탭 안에 보이는 화면을 렌더링하는 역할을 수행한다.</p>\n<p>그러니 이 렌더러 프로세스 내부에 vsync pulse를 감지하는 스레드가 존재한다고 생각할 수 있다.</p>\n<p>vsync 스레드가 vsync를 감지하여 자바스크립트를 실행하는 메인 스레드에게 신호를 전파하고 이 신호를 받은 메인 스레드가 requestAnimationFrame의 콜백함수를 호출하는 방식으로 수행된다고 생각할 수 있다.</p>\n<p>그러나 렌더러 프로세스는 샌드박스화 되어 있으므로 vsync 신호를 보내는 gpu 디바이스에 직접 억세스할 수 없다.</p>\n<p>샌드박스란 일종의 제한된 환경이며 샌드박스 안에 존재하는 프로세스는 CPU와 메모리를 제외한 다른 리소스에 접근할 수 없다.</p>\n<p>따라서 렌더러 프로세스는 샌드박스 환경 밖에 있는 GPU 프로세스와의 IPC를 통하여 vsync신호를 전달받게 된다. 도식화하면 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf5.png\" alt=\"aaa\"></p>\n<p>크로미움 브라우저 내부의 GPU 프로세스는 vsync 스레드를 가지고 있다. 이 스레드는 OS가 제공하는 vsync API를 이용하여 vsync 주기를 감지한다.</p>\n<p>예를들어 windows OS의 경우 vsync API는 IDXGIOutput 클래스가 제공하는데 이 클래스가 제공하는 waitForVBlank 등의 메소드를 사용하여 vsync 주기를 감지한다. 아래 코드는 windows용 vsync 스레드가 v싱크 신호 감지에 사용하는 메소드이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void VSyncThreadWin::WaitForVSync() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n  const HMONITOR monitor = MonitorFromWindow(nullptr, MONITOR_DEFAULTTOPRIMARY);\r\n\r\n  if (primary_monitor_ != monitor) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    primary_monitor_ = monitor;\r\n    primary_output_ = DXGIOutputFromMonitor(monitor, d3d11_device_);\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  const bool wait_for_vblank_succeeded =\r\n      primary_output_ &amp;&amp; SUCCEEDED(primary_output_->WaitForVBlank());\r\n\r\n  // .. 생략\r\n\r\n  if (!wait_for_vblank_succeeded ||\r\n      wait_for_vblank_elapsed_time &lt; kVBlankIntervalThreshold) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    Sleep(static_cast&lt;DWORD>(vsync_interval.InMillisecondsRoundedUp()));\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  if (!observers_.empty()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    vsync_thread_.task_runner()->PostTask(\r\n        FROM_HERE,\r\n        base::BindOnce(&amp;VSyncThreadWin::WaitForVSync, base::Unretained(this)));\r\n    const base::TimeTicks vsync_time = base::TimeTicks::Now();\r\n    for (auto* obs : observers_)\r\n      obs->OnVSync(vsync_time, vsync_interval);\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    is_idle_ = true;\r\n  }\r\n}\n</code></pre>\n<p><code>&lt; 참조 : ui/gl/vsync_thread_win.cc></code></p>\n<p>위의 코드에서 DXGIOutputFromMonitor함수는 프라이머리로 사용중인 모니터의 정보를 가져온다. 그리고 해당 모니터를 대상으로 WaitForVBlank 메소드를 호출하여 v싱크 주기를 감시한다. 만일 v싱크 주기가 감지된다면 옵저버인 DirectCompositionChildSurfaceWin 클래스의 OnVSync 메소드가 트리거되고 프레임 생성 파이프라인을 시작한다. 이 파이프라인의 시작신호를 BeginFrame이라고 한다.</p>\n<p>크로미움은 BeginFrame을 다음과 같이 정의하고 있다</p>\n<blockquote>\n<p>BeginFrame is the mechanism that tells us that now is a good time to start making a frame<br>\n(BeginFrame은 메커니즘인데 이 메커니즘은 지금이 프레임의 생성을 시작하는 좋은 타이밍이라는 것을 알려준다.)</p>\n</blockquote>\n<p><code>(cc/scheduler/scheduler.cc)</code></p>\n<p>GPU 프로세스는 렌더러 프로세스에게 BeginFrame 신호를 보낸다. 이 때 BeginFrame은 하나의 테스크로서 간주되며 스케줄러에 의해 스케줄링된다. 이 BeginFrame 신호는 렌더러 프로세스의 impl 스레드에게 전달된다.</p>\n<p>사실 렌더러 프로세스에는 크게 2가지의 스레드가 존재한다. 메인스레드와 impl 스레드가 그것인데 각각의 스레드는 별도의 스케줄러를 가지고 있다.</p>\n<p>GPU 프로세서로부터 전달받는 BeginFrame 신호는 impl 스레드가 전달받으며 impl 스레드의 스케줄러에 의해 스케줄링된다. 이때 스케줄링되는 테스크는 impl 스레드에서 수행하는 BeginFrame이라는 의미에서 BeginImplFrame이라고 부른다. BeginImplFrame 테스크가 수행되는 시점에서 impl 스레드는 프레임 생산이 시작되었음을 인지한다.</p>\n<p>impl 스레드는 BeginImplFrame 테스크의 수행도중 메인 스레드에게 BeginMainFrame 테스크를 수행하라는 메시지를 전송한다. 이 테스크를 수행하는 시점에서 메인 스레드는 프레임 생산이 시작되었음을 인지한다.</p>\n<p>지금까지의 과정을 요약하면 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf6.png\" alt=\"aaa\"></p>\n<p>위의 과정은 매우 간략화된 형태이지만 사실 BeginMainFrame은 메인스레드의 이벤트 루프 내부에서 테스크의 형태로 실행된다.</p>\n<p>여기까지 이 글을 읽은 독자라면 이벤트 루프가 여러개의 테스크 큐를 대상으로 우선순위에 기반하여 수행된다는 사실을 알고있을 것이다.</p>\n<p>따라서 BeginMainFrame 또한 작업이 실행되기 전까지 특정한 테스크 큐에 저장되어 있다가 해당 테스크 큐의 순서가 오면 dequeue되어 수행된다. BeginMainFrame은 작업이 수행되기 전까지 컴포지터 테스크 큐에 저장된다.</p>\n<p>이 BeginMainFrame 테스크가 메인스레드 내부에서 하는 일을 요약하면 아래와 같다.</p>\n<p>가장 먼저 유저 입력에 대한 이벤트리스너를 수행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.</p>\n<p>곧이어 requestAnimationFrame의 콜백함수가 스케줄러에 등록되어 있다면 해당 함수를 실행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.</p>\n<p>이 시점에서 rAF 콜백함수가 종료되지만 변경사항이 바로 모니터에 적용되는 것은 아니며 모니터의 갱신까지는 몇가지 추가 단계를 필요로 한다.</p>\n<p>rAF의 종료이후 LocalFrameView 클래스의 UpdateLifeCycle 메소드를 수행한다. 이 테스크는 페이지의 최종 변경사항을 레이아웃 트리에 적용시킨다. 이 레이아웃 트리의 변경사항은 최종적으로 레이어 트리와 프로퍼티 트리를 생성한다.</p>\n<p>변경사항의 반영이 종료되면 레이어 트리의 커밋을 수행할 준비가 되었다는 신호인 NotifyReadyToCommit를 impl 스레드에게 전송한다. 이 메시지의 전송작업은 메인스레드의 프록시 클래스인 ProxyMain이 수행한다. 이 때 impl 스레드에게 뮤텍스를 보내며 메인 스레드는 블록킹 상태에 빠진다. 메인스레드가 블록킹 상태에 빠지는 이유는 impl 스레드가 레이어 트리를 복제하는 작업이 완료되기 전 까지는 레이어 트리를 수정해선 안되기 때문이다.</p>\n<p>여기까지가 메인스레드의 렌더링 작업이고 이후의 작업은 impl 스레드가 수행한다.</p>\n<p>NotifyReadyToCommit 신호를 전달받은 impl 스레드가 커밋 준비를 마친다면 ProxyImpl 클래스를 이용하여 메인 스레드의 데이터를 복제하여 컴포지터 스레드만이 접근할 수 있는 데이터를 생성한다. 만일 이러한 복제물을 생성하지 않은 채 메인스레드와 impl 스레드가 레이어 트리를 공유하여 사용한다면 메인스레드에서 변경작업 중인 레이어 트리의 변경작업이 완료되기도 전에 impl 스레드 측에서 임의로 디스플레이에 출력하는 사태가 발생할 수 있다. 이 경우 모니터의 티어링 현상이 발생할 수 있다.</p>\n<p>레이어 트리의 복제 작업이 완료되면 impl 스레드가 데이터의 복제가 완료되었다는 신호를 메인 스레드에게 건내주고 메인스레드는 블록킹 상태에서 벗어나 테스크를 재개할 수 있게된다. impl 스레드는 복제된 데이터를 기반으로 컴포지팅 작업을 수행한다. 컴포지팅은 화면상에 출력될 비트맵을 생성하는 작업이다. 비트맵의 생성이 완료되면 GPU 프로세스가 드로잉 작업을 수행하고 최종 결과물이 모니터에 드로잉된다.</p>\n<p>여기까지가 프레임생성의 풀 파이프라인이고 rAF의 콜백함수는 이러한 프레임 생성의 전체 파이프라인 중 BeginMainFrame 테스크의 일부분으로서 실행된다. 위의 설명은 전체 파이프라인을 매우 축약한 것이며 실제 과정은 더욱 디테일하다. 본 문서는 풀 파이프라인 중 rAF가 실행되는 과정에 집중하여 작성되었다.</p>\n<hr>\n<h4 id=\"참고\">참고</h4>\n<p><a href=\"https://www.youtube.com/watch?v=m-J-tbAlFic\">Youtube - Life of a pixel (Chrome University 2019)</a></p>\n<p><a href=\"https://source.chromium.org/chromium\">웹사이트 : Chromium Code Search</a></p>\n<p><a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/how_cc_works.md\">크로미움 문서 : How cc Works</a></p>\n<p><a href=\"https://chromium.googlesource.com/chromium/src/+/66.0.3359.158/third_party/WebKit/Source/platform/scheduler/README.md\">크로미움 문서 : Blink Scheduler</a></p>"
    },
    "url": "/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95.md")
  }
}, children);

});
</script><astro-root uid="2fhblU"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95"><p class="title">크로미움 웹브라우저에서 setTimeout이 실행되는 과정</p></a></header><time>2021.04.29</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2fhblU", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "크로미움 웹브라우저에서 setTimeout이 실행되는 과정",
    "description": "setTimeout API의 작동방식",
    "publishDate": "2021.04.29",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "크로미움-웹브라우저에서-settimeout이-실행되는-과정",
        "text": "크로미움 웹브라우저에서 setTimeout이 실행되는 과정"
      }],
      "source": "\r\n### 크로미움 웹브라우저에서 setTimeout이 실행되는 과정\r\n\r\n아래 코드는 setTimeout을 호출하는 코드이다\r\n\r\n```html\r\n<script>\r\n   f1() ;\r\n\r\n   setTimeout(()=>{\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() {\r\n     return 1 ;\r\n   }\r\n<\/script>\r\n\r\n```\r\n브라우저 내부에서 위의 코드가 실행될 때 아래와 같은 루틴으로 처리된다.\\\r\n\\\r\n`<script>` 내부는 자바스크립트 코드로 이루어져 있고 이 코드는 웹브라우저의 렌더러 엔진이 단독으로 처리할 수 없다. 따라서 자바스크립트 가상 머신에게 script 내부의 처리를 요청한다.\\\r\n\\\r\n크로미움에서 해당 작업은 v8이라는 이름의 자바스크립트 가상머신이 수행한다.\\\r\n\\\r\nv8은 먼저 f1 함수를 호출한다. f1의 수행이 종료되면 이어서 setTimeout 함수를 호출한다.\\\r\n\\\r\nsetTimeout 함수를 호출한 주체는 v8 자바스크립트 엔진이지만 setTimeout은 v8에 구현되어 있지 않다.\\\r\n\\\r\nv8은 ECMAScript 스펙의 구현체이지만 setTimeout은 ECMAScript의 스펙에 정의되어 있지 않기 때문이다.\\\r\n\\\r\nsetTimeout은 WHATWG에서 관리하는 HTML Living Standard 스펙에 정의되어 있다\\\r\n`([링크](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout))`\\\r\n\\\r\n이처럼 WHATWG HTML Living Standard 스펙에 정의되어 있는 자바스크립트 함수를 Web API라고 한다\\\r\n\\\r\n이러한 WebAPI는 웹브라우저의 렌더러 엔진에 구현되어 있다. 크로미움의 렌더러 엔진을 블링크라고 한다.\\\r\n\\\r\nv8엔진은 Blink IDL이라는 인터페이스를 통하여 블링크 엔진 내부에 구현된 WebAPI 함수의 실제 구현체를 호출한다.\\\r\n\\\r\nsetTimeout의 실제 구현체는 블링크 엔진 내부에 있는 WindowOrWorkerGlobalScope클래스의 SetTimeout메소드에 정의되어 있다.\\\r\n\\\r\n자바스크립트 코드 내부에서 setTimeout을 호출하는 순간 자바스크립트 코드 실행부는 일시 중지되고 제어권은 블링크 엔진에게 이전된다.\\\r\n\\\r\n블링크 엔진 내부에서 setTimeout 함수의 루틴이 종료되면 리턴값인 타이머 ID를 v8에게 반환하면서 자바스크립트 코드 실행부가 작업을 재개한다.\\\r\n\\\r\n다음은 `WindowOrWorkerGlobalScope::SetTimeout` 메소드이다\r\n\r\n```cpp\r\nint WindowOrWorkerGlobalScope::setTimeout(\r\n    ScriptState* script_state,\r\n    EventTarget& event_target,\r\n    V8Function* handler,\r\n    int timeout,\r\n    const HeapVector<ScriptValue>& arguments) {\r\n\r\n  ExecutionContext* execution_context = event_target.GetExecutionContext();\r\n  if (!IsAllowed(execution_context, false, g_empty_string))\r\n    return 0;\r\n  auto* action = MakeGarbageCollected<ScheduledAction>(\r\n      script_state, execution_context, handler, arguments);\r\n\r\n  return DOMTimer::Install(execution_context, action,\r\n                           base::TimeDelta::FromMilliseconds(timeout), true);\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)`\\\r\n\\\r\n위의 코드는 C++로 작성되었다. 이처럼 블링크 렌더러 엔진을 비롯한 대부분의 크로미움 소스는 C++로 작성되었다.\\\r\n\\\r\n위의 코드에서 마지막 return 직전에 호출되는 `DOMTimer::Install` 메소드는 타이머계열 메소드 (setInterval, setTimeout)의 수행에 사용된다. 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nint DOMTimer::Install(ExecutionContext* context,\r\n                      ScheduledAction* action,\r\n                      base::TimeDelta timeout,\r\n                      bool single_shot) {\r\n  int timeout_id = context->Timers()->InstallNewTimeout(context, action,\r\n                                                        timeout, single_shot);\r\n  return timeout_id;\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.h)`\r\n\\\r\n`DOMTimer::Install`메소드는 내부에서 `DOMTimerCoordinator` 인스턴스의 `InstallNewTimeout` 메소드를 호출한다.\\\r\n\\\r\n`DOMTimerCoordinator::InstallNewTimeout` 메소드는 실질적인 `setTimeout의` 구현체이다. 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nint DOMTimerCoordinator::InstallNewTimeout(ExecutionContext* context,\r\n                                           ScheduledAction* action,\r\n                                           base::TimeDelta timeout,\r\n                                           bool single_shot) {\r\n  // FIXME: DOMTimers depends heavily on ExecutionContext. Decouple them.\r\n  DCHECK_EQ(context->Timers(), this);\r\n  int timeout_id = NextID();\r\n  timers_.insert(timeout_id,\r\n                 MakeGarbageCollected<DOMTimer>(context, action, timeout,\r\n                                                single_shot, timeout_id));\r\n  return timeout_id;\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer_coordinator.cc)`\\\r\n\\\r\n`DOMTimerCoordinator::InstallNewTimeout` 메소드는 크게 2가지 작업을 수행한다.\\\r\n\\\r\n첫째로 콜백함수의 타이머 id를 생성한다. 이는 NextID() 메소드를 호출함으로서 수행된다.\\\r\n\\\r\n둘째로 콜백함수를 스케줄링한다. 해당 작업은 콜백함수를 테스크 큐에 삽입함으로서 수행된다. 테스크 큐라는 용어는 이벤트 루프에 대해 조사해 본 적이 있다면 들어본 적이 있을 것이다. 테스크 큐는 queue라는 자료구조의 구현체로서 수행할 테스크를 후입선출 방식으로 실행하는 자료구조를 의미한다. 여기에는 자바스크립트 `setTimeout` 함수의 첫번째 인자로 삽입된 콜백함수가 스케줄링된다.\\\r\n\\\r\n엄밀하게 이야기하면 콜백함수가 직접 스케줄링되지 않으며 콜백함수를 프로퍼티로 가진 DOMTimer 인스턴스가 스케줄링된다. 스케줄링되는 DOMTimer 인스턴스 내부에 setTimeout 콜백함수가 프로퍼티로 저장되어 있으며 이 프로퍼티의 이름은 action_이다.\\\r\n\\\r\n실제 테스크 수행시에는 최종적으로 해당 콜백함수가 실행된다.\\\r\n\\\r\n이 스케줄링 과정은 위의 `InstallNewTimeout` 메소드에서는 확인하기 어렵다. 위의 코드에서는 timers_.insert() 메소드를 호출하는 과정에서 두번째 인자로 DOMTimer 인스턴스가 전달되는 것을 확인할 수 있는데, 덕분에 timers_.insert() 를 호출하는 행위를 스케줄링 작업으로 오해할 수 있다. 사실 timers_ 는 자바스크립트에서 clearTimeout() 함수를 호출할 때 해당 테스크의 스케줄링을 취소하려는 목적으로 사용된다.\\\r\n\\\r\n실제 스케줄링 작업은 DOMTimer가 생성자를 호출할 때 이루어진다. DOMTimer 생성자의 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nDOMTimer::DOMTimer(ExecutionContext* context,\r\n                   ScheduledAction* action,\r\n                   base::TimeDelta timeout,\r\n                   bool single_shot,\r\n                   int timeout_id)\r\n    : ExecutionContextLifecycleObserver(context),\r\n      TimerBase(nullptr),\r\n      timeout_id_(timeout_id),\r\n      // Step 9:\r\n      nesting_level_(context->Timers()->TimerNestingLevel()),\r\n      action_(action) {\r\n  DCHECK_GT(timeout_id, 0);\r\n\r\n  // Step 10:\r\n  if (timeout < base::TimeDelta())\r\n    timeout = base::TimeDelta();\r\n\r\n  // Steps 12 and 13:\r\n  // Note: The implementation increments the nesting level before using it to\r\n  // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n  IncrementNestingLevel();\r\n\r\n  // Step 11:\r\n  // Note: The implementation uses >= instead of >, contrary to what the spec\r\n  // requires crbug.com/1108877.\r\n  if (nesting_level_ >= kMaxTimerNestingLevel && timeout < kMinimumInterval)\r\n    timeout = kMinimumInterval;\r\n\r\n  // Select TaskType based on nesting level.\r\n  TaskType task_type;\r\n  if (timeout.is_zero()) {\r\n    task_type = TaskType::kJavascriptTimerImmediate;\r\n    DCHECK_LT(nesting_level_, kMaxTimerNestingLevel);\r\n  } else if (nesting_level_ >= kMaxTimerNestingLevel) {\r\n    task_type = TaskType::kJavascriptTimerDelayedHighNesting;\r\n  } else {\r\n    task_type = TaskType::kJavascriptTimerDelayedLowNesting;\r\n  }\r\n  MoveToNewTaskRunner(context->GetTaskRunner(task_type));\r\n\r\n  if (single_shot) {\r\n    StartOneShot(timeout, FROM_HERE);\r\n  } else {\r\n    // TODO(crbug.com/402694): Don't clamp interval timers to 1ms here\r\n    timeout = std::max(timeout, base::TimeDelta::FromMilliseconds(1));\r\n    StartRepeating(timeout, FROM_HERE);\r\n  }\r\n\r\n // ...\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.cc )`\r\n\\\r\n소스는 매우 장황하고 이해하기 어렵다. 돔타이머 생성자의 루틴은 크게 두가지 작업으로 나뉜다\\\r\n\\\r\n먼저 자바스크립트 setTimeout의 두번째 인자로 삽입된 timeout 수치를 재조정한다.\\\r\n\\\r\n그 이후 조정된 timeout수치를 참고하여 스케줄링을 수행한다.\\\r\n\\\r\n여기서 timeout수치를 재조정한다는 게 무슨 말인지 의아할 수 있다.\\\r\n\\\r\nsetTimeout함수는 유저가 입력한 timeout수치가 지나치게 낮으면 이를 재조정하도록 설계되어 있다.\\\r\n\\\r\n이 규칙은 WHATWG HTML Living Standard에 명시되어 있다 ([링크](html.spec.whatwg.org/multipage/timers-and-user-prompts.html))\\\r\n\\\r\n위의 소스코드에서 Step 9, Step 10, Step 11 등의 주석을 확인할 수 있는데 이는 HTML 리빙 스탠다드에 명시되어 있는 타이머 초기화 스탭을 구현하는 것을 의미한다.\\\r\n\\\r\n예를 들어 스탭 11의 명세는 아래와 같다.\r\n\r\n> If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\\\r\n> (중첩 레벨이 5보다 크고 timeout수치가 4 미만인 경우, timeout수치를 4로 재조정한다)\r\n\r\ntimeout 수치를 재조정 작업이 완료되면 스케줄링에 필요한 모든 작업이 완료되었고 소스의 아랫부분에서 확인할 수 있는 것처럼 StartOneShot 메소드를 호출한다. 이는 1회만 호출하는 원샷 타이머의 형태로 스케줄링을 진행하겠다는 뜻이다.\\\r\n\\\r\nStartOneShot 메소드 내부에서 몇번의 서브루틴이 있으며 최종적으로 TimerTaskRunner가 postDelayedTask메소드를 호출하여 콜백함수를 테스크 큐에 enqueue함으로서 스케줄링이 수행된다. 이는 아래 소스에서 확인할 수 있다\\\r\n\r\n```cpp\r\nvoid TimerBase::SetNextFireTime(base::TimeTicks now, base::TimeDelta delay) {\r\n\r\n    //  ..생략\r\n\r\n    web_task_runner_->PostDelayedTask(\r\n        location_, BindTimerClosure(weak_ptr_factory_.GetWeakPtr()), delay);\r\n  }\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/platform/timer.cc)`\\\r\n\\\r\n위의 코드에서 PostDelayedTask 메소드의 첫번째 인자인 location_은 DOMTimer 인스턴스이며 해당 인스턴스에 setTimeout의 콜백함수가 저장되어 있다. 세번째 인자인 delay은 타이머 초기화 스탭으로 재조정된 timeout 수치이다.\\\r\n\\\r\nPostDelayedTask라는 용어에서 post는 테스크를 큐에 삽입하는 행위이고 DelayedTask는 해당 테스크가 시간차를 두고 실행되는 테스크라는 것을 의미한다.\\\r\n\\\r\n결론적으로 setTimeout의 콜백함수는 TimerTask로 분류되며 해당 테스크는 TimerTaskRunner 인스턴스가 컨트롤한다\\\r\n\\\r\n여기서 TimerTaskRunner 인스턴스가 컨트롤하는 테스크 큐를 Frame Throttleable 테스크 큐라고 부른다.\\\r\n\\\r\nFrame Throttleable 테스크 큐는 블링크 렌더러 엔진의 메인 스레드 스케줄러가 관리하는 약 19여개의 테스크 큐 중 하나로서 setInterval, setTimeout과 같은 자바스크립트 수준의 타이머를 관리한다.\\\r\n\\\r\n메인 스레드 스케줄러는 Frame Throttleable 테스크 큐 외에도 약 19여개의 테스크 큐를 관리한다.\\\r\n\\\r\n아래는 메인스레드 테스크 큐의 종류이다.\r\n\r\n```cpp\r\nenum class QueueType {\r\n  kControl = 0,\r\n  kDefault = 1,\r\n  kFrameLoading = 5,\r\n  kCompositor = 8,\r\n  kIdle = 9,\r\n  kTest = 10,\r\n  kFrameLoadingControl = 11,\r\n  kFrameThrottleable = 12,\r\n  kFrameDeferrable = 13,\r\n  kFramePausable = 14,\r\n  kFrameUnpausable = 15,\r\n  kV8 = 16,\r\n  kInput = 18,\r\n  kDetached = 19,\r\n  kWebScheduling = 24,\r\n  kNonWaking = 25,\r\n  kIPCTrackingForCachedPages = 26,\r\n  kOther = 23,\r\n  kCount = 27\r\n};\r\n```\r\n`(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)`\\\r\n\\\r\n위 코드에서 각 QueueType 에 할당된 정수는 코드 내부적으로 가독성을 올리기 위한 수단이며 테스크 우선순위와는 무관하다.\\\r\n\\\r\n물론 각 테스크 큐는 각자의 고유한 우선순위를 가지고 있다. 메인 스케줄러는 이러한 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다. 각 테스크 큐의 우선순위는 아래에서 설명하겠다.\\\r\n\\\r\n여기서부터 조금 더 깊이 들어가보겠다\\\r\n\\\r\nsetTimeout의 콜백함수가 스케줄링 되는 테스크 큐는 Frame Throttleable 테스크 큐 이지만 더 정확히 이야기하면 Frame Throttleable 테스크 큐 내부의 delayed_incoming_queue에 삽입된다.\\\r\n\\\r\n조금 혼란이 올 수가 있는데, 하나의 테스크 큐 내부에는 4가지 종류의 테스크 큐가 있다\r\n\r\n```\r\n1. immediate_incoming_queue\r\n2. immediate_work_queue\r\n3. delayed_incoming_queue\r\n4. delayed_work_queue\r\n```\r\n\r\n이 중 타이머 수행에는 앞에 delayed라는 이름이 붙여진 2개의 테스크 큐가 사용된다.\\\r\n\\\r\nsetTimeout의 콜백함수는 먼저 delayed_incoming_queue에 삽입된다.\\\r\n\\\r\ndelayed_incoming_queue는 유저가 인터벌 값으로 설정한 밀리세컨드 값을 참조하여 해당 콜백함수가 호출되는 시점이 되면 delayed_work_queue로 이전한다.\\\r\n\\\r\ndelayed_work_queue에 이전된 함수는 테스크를 수행할 준비가 되었다는 뜻이며 이는 블링크의 메인스레드 스케줄러에 의해 실행될 수 있다.\\\r\n\\\r\n이처럼 delayed_incoming_queue의 테스크를 delayed_work_queue로 옮기는 작업은 TimeDomain 클래스가 담당하며 TimeDomain 클래스가 UpdateDelayedWorkQueue메소드를 호출함으로서 이전이 수행된다. TimeDomain 클래스는 OS가 제공하는 시스템 틱 API를 호출하여 현재시간을 계산한다.\\\r\n\\\r\nwindows OS의 경우 시스템 틱을 호출하는 루틴은 time_win.cc에 정의되어 있다.\\\r\n\\\r\n여기까지가 setTimeout의 콜백함수를 스케줄링 하는 과정이었다. 다시 자바스크립트의 코드 실행부로 돌아가보겠다.\r\n\r\n```html\r\n   f1()\r\n\r\n   setTimeout(()=>{\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() {\r\n     return 1\r\n   }\r\n```\r\nsetTimeout의 호출이후 자바스크립트의 메인 프로그램이 종료된다. 메인 프로그램의 종료이후 제어권은 embedder(임베더)에게 이전된다.\\\r\n\\\r\n임베더는 자바스크립트의 코드실행을 호출한 주체를 일컫는 데 웹브라우저의 경우 임베더는 렌더러 엔진의 메인스레드이다.\\\r\n즉 제어권이 렌더러 엔진인 블링크의 메인 스레드에게 이전된다. 제어권이 이전되면 렌더러 엔진은 자바스크립트의 마이크로테스크 큐를 실행할 조건이 되는지 검사한다.\\\r\n\\\r\n여기서 자바스크립트의 마이크로테스크 큐를 실행하는 주체가 자바스크립트 엔진이 아닌 자바스크립트 엔진의 임베더라는 사실을 알 수 있다.\\\r\n\\\r\n콜스택의 depth가 0인지를 체크하여 0이라면 마이크로테스크 큐가 소진될 때 까지 반복하여 마이크로테스크를 수행한다.\\\r\n\\\r\n마이크로테스크 작업이 모두 종료되면 블링크 메인스레드의 스케줄러가 스케줄링 정책에 입각하여 다음 테스크를 선택하는 루틴을 수행한다. 여기서부터 흔히 말하는 이벤트루프 단계가 수행된다.\\\r\n\\\r\n위에서 언급했듯이 메인스레드의 스케줄러는 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다.\\\r\n\\\r\n여기서 우리는 setTimeout의 콜백함수가 스케줄링 되어있는 Frame Throttleable 테스크 큐가 언제 실행되는지에 관심이 있다.\\\r\n\\\r\nFrame Throttleable 테스크 큐의 우선순위는 0~11까지 책정되어 있는 우선순위 값 중 7이다. 숫자값이 클수록 우선순위가 높다.\r\n\r\n```cpp\r\nenum class PrioritisationType {\r\n  kInternalScriptContinuation = 0,\r\n  kBestEffort = 1,\r\n  kRegular = 2,\r\n  kLoading = 3,\r\n  kLoadingControl = 4,\r\n  kFindInPage = 5,\r\n  kExperimentalDatabase = 6,\r\n  kJavaScriptTimer = 7,\r\n  kHighPriorityLocalFrame = 8,\r\n  kCompositor = 9,  // Main-thread only.\r\n  kInput = 10,\r\n\r\n  kCount = 11\r\n};\r\n```\r\n\r\n`(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)`\\\r\n\\\r\n위의 코드에서 `kJavaScriptTimer는` `Frame Throttleable 테스크 큐`의 우선순위이다.\\\r\n\\\r\n따라서 값이 7보다 높은 테스크 큐에 예약된 테스크가 이미 존재하는 상황에서는 setTimeout의 콜백함수는 영원히 실행되지 않는다.\\\r\n\\\r\n이런 상황을 기아상태라고 한다.\\\r\n\\\r\n우선순위가 7보다 높은 테스크 큐에는 컴포지터 테스크 큐와 유저인풋 테스크 큐 등이 존재한다.\\\r\n\\\r\n만일 우선순위가 7보다 높은 테스크 큐에 테스크가 없다면 `Frame Throttleable 테스크 큐` 내부의 `immediate_work_queue`와 `delayed_work_queue`에 수행할 테스크가 존재하는지 체크한다.\\\r\n\\\r\n만일 테스크가 존재한다면 해당 테스크를 수행한다.\\\r\n\\\r\n만일 존재하지 않는다면 우선순위가 7보다 낮은 테스크 큐에 테스크가 존재하는지 체크한다.\\\r\n\\\r\n블링크의 테스크 스케줄링은 위와 같은 방식으로 수행된다. 이것이 흔히 말하는 이벤트 루프의 민낯이다.\\\r\n\\\r\n1000ms가 지나서 `delayed_work_queue`에 수행할 테스크가 적재되었다면 스케줄러는 해당 테스크를 수행한다.\\\r\n\\\r\n위에서 setTimeout의 콜백함수는 DOMTimer 인스턴스의 형태로 스케줄링 된다고 언급하였다.\\\r\n\\\r\nDOMTimer는 Fired 메소드를 호출하여 해당 콜백함수가 트리거 됨을 알린다. Fired 메소드의 코드는 아래와 같다\r\n\r\n```cpp\r\n\r\nvoid DOMTimer::Fired() {\r\n\r\n  // .. 생략\r\n\r\n  // Simple case for non-one-shot timers.\r\n  if (IsActive()) {\r\n    DCHECK(is_interval);\r\n\r\n    // Steps 12 and 13:\r\n    // Note: The implementation increments the nesting level before using it to\r\n    // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n    IncrementNestingLevel();\r\n\r\n    // Make adjustments when the nesting level becomes >= |kMaxNestingLevel|.\r\n    // Note: The implementation uses >= instead of >, contrary to what the spec\r\n    // requires crbug.com/1108877.\r\n    if (nesting_level_ == kMaxTimerNestingLevel) {\r\n      // Move to the TaskType that corresponds to nesting level >=\r\n      // |kMaxNestingLevel|.\r\n      MoveToNewTaskRunner(\r\n          context->GetTaskRunner(TaskType::kJavascriptTimerDelayedHighNesting));\r\n      // Step 11:\r\n      if (RepeatInterval() < kMinimumInterval)\r\n        AugmentRepeatInterval(kMinimumInterval - RepeatInterval());\r\n    }\r\n\r\n    DCHECK(nesting_level_ < kMaxTimerNestingLevel ||\r\n           RepeatInterval() >= kMinimumInterval);\r\n\r\n    // No access to member variables after this point, it can delete the timer.\r\n    action_->Execute(context);\r\n\r\n    context->Timers()->SetTimerNestingLevel(0);\r\n\r\n    return;\r\n  }\r\n```\r\n\r\n여전히 소스는 장황하고 이해하기 어렵다. 맨 아래에서 세번째 명령어인 `action_->Execute(context) ;` 부분은 실질적인 콜백함수의 호출로 이어진다. action_ 프로퍼티는 `ScheduledAction` 클래스의 인스턴스인데 해당 인스턴스는 V8 엔진과 블링크 렌더러 엔진의 브릿지 역할을 수행한다\r\n\r\n```cpp\r\nvoid ScheduledAction::Execute(ExecutionContext* context) {\r\n\r\n  // .. 생략\r\n  script->RunScriptOnScriptStateAndReturnValue(script_state_->Get());\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/bindings/core/v8/scheduled_action.cc)`\\\r\n\\\r\n위의 소스코드에서 `RunScriptOnScriptStateAndReturnValue` 메소드는 직접적인 스크립트의 수행을 V8에게 요청한다.\\\r\n\\\r\n이 작업은 `V8ScriptRunner`클래스가 `CallFunction`을 호출하여 수행된다.\\\r\n\\\r\n이로서 자바스크립트 엔진에게 제어권이 넘어가게 되고 setTimeout의 첫번째 인자인 콜백 함수가 호출된다.\\\r\n\\\r\n이로서 setTimeout의 실행 사이클은 종료된다\\\r\n\\\r\n위와 같은 사실로부터 몇가지 사실을 도출할 수 있다.\\\r\n\r\n> 첫번째, 렌더러 엔진 내부에서 렌더링 과정의 수행과 자바스크립트 코드 실행은 같은 스레드에서 수행된다.\\\r\n> 두번째, 마이크로테스크 큐의 실행은 렌더러 엔진의 스케줄링 과정에 포함되어 있지 않다.\\\r\n> 세번째, 자바스크립트 코드로 호출 가능한 WebAPI는 자바스크립트 엔진 내부에 구현되어 있지 않으며 렌더러 엔진에 구현되어 있다\r\n\r\n따라서 WebAPI는 렌더러 엔진을 구현한 프로그래밍 언어로 실행된다. 크로미움의 경우 WebAPI는 C++ 코드로 실행된다.\\\r\n\\\r\n네번째, 이벤트 루프는 자바스크립트 코드를 수행하는 것을 포함하여 더 넒은 범위의 테스크를 포함한다.\\\r\n\\\r\n이러한 이벤트 루프는 렌더러의 메인 스레드 내부의 스케줄링 정책에 의해 수행된다.\\\r\n\\\r\nHTML Living Standard는 이벤트 루프를 다음과 같이 정의한다\r\n\r\n> To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section.\\\r\n> Each agent has an associated event loop, which is unique to that agent.\r\n\r\n위의 문장을 해석하면 아래와 같다\r\n\r\n> 이벤트, 사용자와의 상호 작용, 스크립트의 실행, 화면 렌더링, 네트워킹 등을 조정하려면 유저 에이전트(웹 브라우저)는 이 절에 설명된 대로 이벤트 루프를 사용해야 한다.\\\r\n> 유저 에이전트는 각 에이전트 고유의 이벤트 루프를 가지고 있다.\r\n\r\n-- 참고 : whatwg.org",
      "html": "<h3 id=\"크로미움-웹브라우저에서-settimeout이-실행되는-과정\">크로미움 웹브라우저에서 setTimeout이 실행되는 과정</h3>\n<p>아래 코드는 setTimeout을 호출하는 코드이다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;script>\r\n   f1() ;\r\n\r\n   setTimeout(()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     return 1 ;\r\n   }\r\n&lt;/script>\r\n\n</code></pre>\n<p>브라우저 내부에서 위의 코드가 실행될 때 아래와 같은 루틴으로 처리된다.<br>\n<br>\n<code>&lt;script></code> 내부는 자바스크립트 코드로 이루어져 있고 이 코드는 웹브라우저의 렌더러 엔진이 단독으로 처리할 수 없다. 따라서 자바스크립트 가상 머신에게 script 내부의 처리를 요청한다.<br>\n<br>\n크로미움에서 해당 작업은 v8이라는 이름의 자바스크립트 가상머신이 수행한다.<br>\n<br>\nv8은 먼저 f1 함수를 호출한다. f1의 수행이 종료되면 이어서 setTimeout 함수를 호출한다.<br>\n<br>\nsetTimeout 함수를 호출한 주체는 v8 자바스크립트 엔진이지만 setTimeout은 v8에 구현되어 있지 않다.<br>\n<br>\nv8은 ECMAScript 스펙의 구현체이지만 setTimeout은 ECMAScript의 스펙에 정의되어 있지 않기 때문이다.<br>\n<br>\nsetTimeout은 WHATWG에서 관리하는 HTML Living Standard 스펙에 정의되어 있다<br>\n<code>([링크](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout))</code><br>\n<br>\n이처럼 WHATWG HTML Living Standard 스펙에 정의되어 있는 자바스크립트 함수를 Web API라고 한다<br>\n<br>\n이러한 WebAPI는 웹브라우저의 렌더러 엔진에 구현되어 있다. 크로미움의 렌더러 엔진을 블링크라고 한다.<br>\n<br>\nv8엔진은 Blink IDL이라는 인터페이스를 통하여 블링크 엔진 내부에 구현된 WebAPI 함수의 실제 구현체를 호출한다.<br>\n<br>\nsetTimeout의 실제 구현체는 블링크 엔진 내부에 있는 WindowOrWorkerGlobalScope클래스의 SetTimeout메소드에 정의되어 있다.<br>\n<br>\n자바스크립트 코드 내부에서 setTimeout을 호출하는 순간 자바스크립트 코드 실행부는 일시 중지되고 제어권은 블링크 엔진에게 이전된다.<br>\n<br>\n블링크 엔진 내부에서 setTimeout 함수의 루틴이 종료되면 리턴값인 타이머 ID를 v8에게 반환하면서 자바스크립트 코드 실행부가 작업을 재개한다.<br>\n<br>\n다음은 <code>WindowOrWorkerGlobalScope::SetTimeout</code> 메소드이다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int WindowOrWorkerGlobalScope::setTimeout(\r\n    ScriptState* script_state,\r\n    EventTarget&amp; event_target,\r\n    V8Function* handler,\r\n    int timeout,\r\n    const HeapVector&lt;ScriptValue>&amp; arguments) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  ExecutionContext* execution_context = event_target.GetExecutionContext();\r\n  if (!IsAllowed(execution_context, false, g_empty_string))\r\n    return 0;\r\n  auto* action = MakeGarbageCollected&lt;ScheduledAction>(\r\n      script_state, execution_context, handler, arguments);\r\n\r\n  return DOMTimer::Install(execution_context, action,\r\n                           base::TimeDelta::FromMilliseconds(timeout), true);\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)</code><br>\n<br>\n위의 코드는 C++로 작성되었다. 이처럼 블링크 렌더러 엔진을 비롯한 대부분의 크로미움 소스는 C++로 작성되었다.<br>\n<br>\n위의 코드에서 마지막 return 직전에 호출되는 <code>DOMTimer::Install</code> 메소드는 타이머계열 메소드 (setInterval, setTimeout)의 수행에 사용된다. 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int DOMTimer::Install(ExecutionContext* context,\r\n                      ScheduledAction* action,\r\n                      base::TimeDelta timeout,\r\n                      bool single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  int timeout_id = context->Timers()->InstallNewTimeout(context, action,\r\n                                                        timeout, single_shot);\r\n  return timeout_id;\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.h)</code>\r\n<br>\n<code>DOMTimer::Install</code>메소드는 내부에서 <code>DOMTimerCoordinator</code> 인스턴스의 <code>InstallNewTimeout</code> 메소드를 호출한다.<br>\n<br>\n<code>DOMTimerCoordinator::InstallNewTimeout</code> 메소드는 실질적인 <code>setTimeout의</code> 구현체이다. 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int DOMTimerCoordinator::InstallNewTimeout(ExecutionContext* context,\r\n                                           ScheduledAction* action,\r\n                                           base::TimeDelta timeout,\r\n                                           bool single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  // FIXME: DOMTimers depends heavily on ExecutionContext. Decouple them.\r\n  DCHECK_EQ(context->Timers(), this);\r\n  int timeout_id = NextID();\r\n  timers_.insert(timeout_id,\r\n                 MakeGarbageCollected&lt;DOMTimer>(context, action, timeout,\r\n                                                single_shot, timeout_id));\r\n  return timeout_id;\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer_coordinator.cc)</code><br>\n<br>\n<code>DOMTimerCoordinator::InstallNewTimeout</code> 메소드는 크게 2가지 작업을 수행한다.<br>\n<br>\n첫째로 콜백함수의 타이머 id를 생성한다. 이는 NextID() 메소드를 호출함으로서 수행된다.<br>\n<br>\n둘째로 콜백함수를 스케줄링한다. 해당 작업은 콜백함수를 테스크 큐에 삽입함으로서 수행된다. 테스크 큐라는 용어는 이벤트 루프에 대해 조사해 본 적이 있다면 들어본 적이 있을 것이다. 테스크 큐는 queue라는 자료구조의 구현체로서 수행할 테스크를 후입선출 방식으로 실행하는 자료구조를 의미한다. 여기에는 자바스크립트 <code>setTimeout</code> 함수의 첫번째 인자로 삽입된 콜백함수가 스케줄링된다.<br>\n<br>\n엄밀하게 이야기하면 콜백함수가 직접 스케줄링되지 않으며 콜백함수를 프로퍼티로 가진 DOMTimer 인스턴스가 스케줄링된다. 스케줄링되는 DOMTimer 인스턴스 내부에 setTimeout 콜백함수가 프로퍼티로 저장되어 있으며 이 프로퍼티의 이름은 action_이다.<br>\n<br>\n실제 테스크 수행시에는 최종적으로 해당 콜백함수가 실행된다.<br>\n<br>\n이 스케줄링 과정은 위의 <code>InstallNewTimeout</code> 메소드에서는 확인하기 어렵다. 위의 코드에서는 timers_.insert() 메소드를 호출하는 과정에서 두번째 인자로 DOMTimer 인스턴스가 전달되는 것을 확인할 수 있는데, 덕분에 timers_.insert() 를 호출하는 행위를 스케줄링 작업으로 오해할 수 있다. 사실 timers_ 는 자바스크립트에서 clearTimeout() 함수를 호출할 때 해당 테스크의 스케줄링을 취소하려는 목적으로 사용된다.<br>\n<br>\n실제 스케줄링 작업은 DOMTimer가 생성자를 호출할 때 이루어진다. DOMTimer 생성자의 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">DOMTimer::DOMTimer(ExecutionContext* context,\r\n                   ScheduledAction* action,\r\n                   base::TimeDelta timeout,\r\n                   bool single_shot,\r\n                   int timeout_id)\r\n    : ExecutionContextLifecycleObserver(context),\r\n      TimerBase(nullptr),\r\n      timeout_id_(timeout_id),\r\n      // Step 9:\r\n      nesting_level_(context->Timers()->TimerNestingLevel()),\r\n      action_(action) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  DCHECK_GT(timeout_id, 0);\r\n\r\n  // Step 10:\r\n  if (timeout &lt; base::TimeDelta())\r\n    timeout = base::TimeDelta();\r\n\r\n  // Steps 12 and 13:\r\n  // Note: The implementation increments the nesting level before using it to\r\n  // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n  IncrementNestingLevel();\r\n\r\n  // Step 11:\r\n  // Note: The implementation uses >= instead of >, contrary to what the spec\r\n  // requires crbug.com/1108877.\r\n  if (nesting_level_ >= kMaxTimerNestingLevel &amp;&amp; timeout &lt; kMinimumInterval)\r\n    timeout = kMinimumInterval;\r\n\r\n  // Select TaskType based on nesting level.\r\n  TaskType task_type;\r\n  if (timeout.is_zero()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerImmediate;\r\n    DCHECK_LT(nesting_level_, kMaxTimerNestingLevel);\r\n  } else if (nesting_level_ >= kMaxTimerNestingLevel) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerDelayedHighNesting;\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerDelayedLowNesting;\r\n  }\r\n  MoveToNewTaskRunner(context->GetTaskRunner(task_type));\r\n\r\n  if (single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    StartOneShot(timeout, FROM_HERE);\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    // TODO(crbug.com/402694): Don't clamp interval timers to 1ms here\r\n    timeout = std::max(timeout, base::TimeDelta::FromMilliseconds(1));\r\n    StartRepeating(timeout, FROM_HERE);\r\n  }\r\n\r\n // ...\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.cc )</code>\r\n<br>\n소스는 매우 장황하고 이해하기 어렵다. 돔타이머 생성자의 루틴은 크게 두가지 작업으로 나뉜다<br>\n<br>\n먼저 자바스크립트 setTimeout의 두번째 인자로 삽입된 timeout 수치를 재조정한다.<br>\n<br>\n그 이후 조정된 timeout수치를 참고하여 스케줄링을 수행한다.<br>\n<br>\n여기서 timeout수치를 재조정한다는 게 무슨 말인지 의아할 수 있다.<br>\n<br>\nsetTimeout함수는 유저가 입력한 timeout수치가 지나치게 낮으면 이를 재조정하도록 설계되어 있다.<br>\n<br>\n이 규칙은 WHATWG HTML Living Standard에 명시되어 있다 (<a href=\"html.spec.whatwg.org/multipage/timers-and-user-prompts.html\">링크</a>)<br>\n<br>\n위의 소스코드에서 Step 9, Step 10, Step 11 등의 주석을 확인할 수 있는데 이는 HTML 리빙 스탠다드에 명시되어 있는 타이머 초기화 스탭을 구현하는 것을 의미한다.<br>\n<br>\n예를 들어 스탭 11의 명세는 아래와 같다.</p>\n<blockquote>\n<p>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.<br>\n(중첩 레벨이 5보다 크고 timeout수치가 4 미만인 경우, timeout수치를 4로 재조정한다)</p>\n</blockquote>\n<p>timeout 수치를 재조정 작업이 완료되면 스케줄링에 필요한 모든 작업이 완료되었고 소스의 아랫부분에서 확인할 수 있는 것처럼 StartOneShot 메소드를 호출한다. 이는 1회만 호출하는 원샷 타이머의 형태로 스케줄링을 진행하겠다는 뜻이다.<br>\n<br>\nStartOneShot 메소드 내부에서 몇번의 서브루틴이 있으며 최종적으로 TimerTaskRunner가 postDelayedTask메소드를 호출하여 콜백함수를 테스크 큐에 enqueue함으로서 스케줄링이 수행된다. 이는 아래 소스에서 확인할 수 있다\\</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void TimerBase::SetNextFireTime(base::TimeTicks now, base::TimeDelta delay) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    //  ..생략\r\n\r\n    web_task_runner_->PostDelayedTask(\r\n        location_, BindTimerClosure(weak_ptr_factory_.GetWeakPtr()), delay);\r\n  }\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/timer.cc)</code><br>\n<br>\n위의 코드에서 PostDelayedTask 메소드의 첫번째 인자인 location_은 DOMTimer 인스턴스이며 해당 인스턴스에 setTimeout의 콜백함수가 저장되어 있다. 세번째 인자인 delay은 타이머 초기화 스탭으로 재조정된 timeout 수치이다.<br>\n<br>\nPostDelayedTask라는 용어에서 post는 테스크를 큐에 삽입하는 행위이고 DelayedTask는 해당 테스크가 시간차를 두고 실행되는 테스크라는 것을 의미한다.<br>\n<br>\n결론적으로 setTimeout의 콜백함수는 TimerTask로 분류되며 해당 테스크는 TimerTaskRunner 인스턴스가 컨트롤한다<br>\n<br>\n여기서 TimerTaskRunner 인스턴스가 컨트롤하는 테스크 큐를 Frame Throttleable 테스크 큐라고 부른다.<br>\n<br>\nFrame Throttleable 테스크 큐는 블링크 렌더러 엔진의 메인 스레드 스케줄러가 관리하는 약 19여개의 테스크 큐 중 하나로서 setInterval, setTimeout과 같은 자바스크립트 수준의 타이머를 관리한다.<br>\n<br>\n메인 스레드 스케줄러는 Frame Throttleable 테스크 큐 외에도 약 19여개의 테스크 큐를 관리한다.<br>\n<br>\n아래는 메인스레드 테스크 큐의 종류이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum class QueueType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  kControl = 0,\r\n  kDefault = 1,\r\n  kFrameLoading = 5,\r\n  kCompositor = 8,\r\n  kIdle = 9,\r\n  kTest = 10,\r\n  kFrameLoadingControl = 11,\r\n  kFrameThrottleable = 12,\r\n  kFrameDeferrable = 13,\r\n  kFramePausable = 14,\r\n  kFrameUnpausable = 15,\r\n  kV8 = 16,\r\n  kInput = 18,\r\n  kDetached = 19,\r\n  kWebScheduling = 24,\r\n  kNonWaking = 25,\r\n  kIPCTrackingForCachedPages = 26,\r\n  kOther = 23,\r\n  kCount = 27\r\n};\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)</code><br>\n<br>\n위 코드에서 각 QueueType 에 할당된 정수는 코드 내부적으로 가독성을 올리기 위한 수단이며 테스크 우선순위와는 무관하다.<br>\n<br>\n물론 각 테스크 큐는 각자의 고유한 우선순위를 가지고 있다. 메인 스케줄러는 이러한 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다. 각 테스크 큐의 우선순위는 아래에서 설명하겠다.<br>\n<br>\n여기서부터 조금 더 깊이 들어가보겠다<br>\n<br>\nsetTimeout의 콜백함수가 스케줄링 되는 테스크 큐는 Frame Throttleable 테스크 큐 이지만 더 정확히 이야기하면 Frame Throttleable 테스크 큐 내부의 delayed_incoming_queue에 삽입된다.<br>\n<br>\n조금 혼란이 올 수가 있는데, 하나의 테스크 큐 내부에는 4가지 종류의 테스크 큐가 있다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. immediate_incoming_queue\r\n2. immediate_work_queue\r\n3. delayed_incoming_queue\r\n4. delayed_work_queue\n</code></pre>\n<p>이 중 타이머 수행에는 앞에 delayed라는 이름이 붙여진 2개의 테스크 큐가 사용된다.<br>\n<br>\nsetTimeout의 콜백함수는 먼저 delayed_incoming_queue에 삽입된다.<br>\n<br>\ndelayed_incoming_queue는 유저가 인터벌 값으로 설정한 밀리세컨드 값을 참조하여 해당 콜백함수가 호출되는 시점이 되면 delayed_work_queue로 이전한다.<br>\n<br>\ndelayed_work_queue에 이전된 함수는 테스크를 수행할 준비가 되었다는 뜻이며 이는 블링크의 메인스레드 스케줄러에 의해 실행될 수 있다.<br>\n<br>\n이처럼 delayed_incoming_queue의 테스크를 delayed_work_queue로 옮기는 작업은 TimeDomain 클래스가 담당하며 TimeDomain 클래스가 UpdateDelayedWorkQueue메소드를 호출함으로서 이전이 수행된다. TimeDomain 클래스는 OS가 제공하는 시스템 틱 API를 호출하여 현재시간을 계산한다.<br>\n<br>\nwindows OS의 경우 시스템 틱을 호출하는 루틴은 time_win.cc에 정의되어 있다.<br>\n<br>\n여기까지가 setTimeout의 콜백함수를 스케줄링 하는 과정이었다. 다시 자바스크립트의 코드 실행부로 돌아가보겠다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">   f1()\r\n\r\n   setTimeout(()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     return 1\r\n   }\n</code></pre>\n<p>setTimeout의 호출이후 자바스크립트의 메인 프로그램이 종료된다. 메인 프로그램의 종료이후 제어권은 embedder(임베더)에게 이전된다.<br>\n<br>\n임베더는 자바스크립트의 코드실행을 호출한 주체를 일컫는 데 웹브라우저의 경우 임베더는 렌더러 엔진의 메인스레드이다.<br>\n즉 제어권이 렌더러 엔진인 블링크의 메인 스레드에게 이전된다. 제어권이 이전되면 렌더러 엔진은 자바스크립트의 마이크로테스크 큐를 실행할 조건이 되는지 검사한다.<br>\n<br>\n여기서 자바스크립트의 마이크로테스크 큐를 실행하는 주체가 자바스크립트 엔진이 아닌 자바스크립트 엔진의 임베더라는 사실을 알 수 있다.<br>\n<br>\n콜스택의 depth가 0인지를 체크하여 0이라면 마이크로테스크 큐가 소진될 때 까지 반복하여 마이크로테스크를 수행한다.<br>\n<br>\n마이크로테스크 작업이 모두 종료되면 블링크 메인스레드의 스케줄러가 스케줄링 정책에 입각하여 다음 테스크를 선택하는 루틴을 수행한다. 여기서부터 흔히 말하는 이벤트루프 단계가 수행된다.<br>\n<br>\n위에서 언급했듯이 메인스레드의 스케줄러는 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다.<br>\n<br>\n여기서 우리는 setTimeout의 콜백함수가 스케줄링 되어있는 Frame Throttleable 테스크 큐가 언제 실행되는지에 관심이 있다.<br>\n<br>\nFrame Throttleable 테스크 큐의 우선순위는 0~11까지 책정되어 있는 우선순위 값 중 7이다. 숫자값이 클수록 우선순위가 높다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum class PrioritisationType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  kInternalScriptContinuation = 0,\r\n  kBestEffort = 1,\r\n  kRegular = 2,\r\n  kLoading = 3,\r\n  kLoadingControl = 4,\r\n  kFindInPage = 5,\r\n  kExperimentalDatabase = 6,\r\n  kJavaScriptTimer = 7,\r\n  kHighPriorityLocalFrame = 8,\r\n  kCompositor = 9,  // Main-thread only.\r\n  kInput = 10,\r\n\r\n  kCount = 11\r\n};\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)</code><br>\n<br>\n위의 코드에서 <code>kJavaScriptTimer는</code> <code>Frame Throttleable 테스크 큐</code>의 우선순위이다.<br>\n<br>\n따라서 값이 7보다 높은 테스크 큐에 예약된 테스크가 이미 존재하는 상황에서는 setTimeout의 콜백함수는 영원히 실행되지 않는다.<br>\n<br>\n이런 상황을 기아상태라고 한다.<br>\n<br>\n우선순위가 7보다 높은 테스크 큐에는 컴포지터 테스크 큐와 유저인풋 테스크 큐 등이 존재한다.<br>\n<br>\n만일 우선순위가 7보다 높은 테스크 큐에 테스크가 없다면 <code>Frame Throttleable 테스크 큐</code> 내부의 <code>immediate_work_queue</code>와 <code>delayed_work_queue</code>에 수행할 테스크가 존재하는지 체크한다.<br>\n<br>\n만일 테스크가 존재한다면 해당 테스크를 수행한다.<br>\n<br>\n만일 존재하지 않는다면 우선순위가 7보다 낮은 테스크 큐에 테스크가 존재하는지 체크한다.<br>\n<br>\n블링크의 테스크 스케줄링은 위와 같은 방식으로 수행된다. 이것이 흔히 말하는 이벤트 루프의 민낯이다.<br>\n<br>\n1000ms가 지나서 <code>delayed_work_queue</code>에 수행할 테스크가 적재되었다면 스케줄러는 해당 테스크를 수행한다.<br>\n<br>\n위에서 setTimeout의 콜백함수는 DOMTimer 인스턴스의 형태로 스케줄링 된다고 언급하였다.<br>\n<br>\nDOMTimer는 Fired 메소드를 호출하여 해당 콜백함수가 트리거 됨을 알린다. Fired 메소드의 코드는 아래와 같다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">\r\nvoid DOMTimer::Fired() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n\r\n  // Simple case for non-one-shot timers.\r\n  if (IsActive()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    DCHECK(is_interval);\r\n\r\n    // Steps 12 and 13:\r\n    // Note: The implementation increments the nesting level before using it to\r\n    // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n    IncrementNestingLevel();\r\n\r\n    // Make adjustments when the nesting level becomes >= |kMaxNestingLevel|.\r\n    // Note: The implementation uses >= instead of >, contrary to what the spec\r\n    // requires crbug.com/1108877.\r\n    if (nesting_level_ == kMaxTimerNestingLevel) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n      // Move to the TaskType that corresponds to nesting level >=\r\n      // |kMaxNestingLevel|.\r\n      MoveToNewTaskRunner(\r\n          context->GetTaskRunner(TaskType::kJavascriptTimerDelayedHighNesting));\r\n      // Step 11:\r\n      if (RepeatInterval() &lt; kMinimumInterval)\r\n        AugmentRepeatInterval(kMinimumInterval - RepeatInterval());\r\n    }\r\n\r\n    DCHECK(nesting_level_ &lt; kMaxTimerNestingLevel ||\r\n           RepeatInterval() >= kMinimumInterval);\r\n\r\n    // No access to member variables after this point, it can delete the timer.\r\n    action_->Execute(context);\r\n\r\n    context->Timers()->SetTimerNestingLevel(0);\r\n\r\n    return;\r\n  }\n</code></pre>\n<p>여전히 소스는 장황하고 이해하기 어렵다. 맨 아래에서 세번째 명령어인 <code>action_->Execute(context) ;</code> 부분은 실질적인 콜백함수의 호출로 이어진다. action_ 프로퍼티는 <code>ScheduledAction</code> 클래스의 인스턴스인데 해당 인스턴스는 V8 엔진과 블링크 렌더러 엔진의 브릿지 역할을 수행한다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void ScheduledAction::Execute(ExecutionContext* context) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n  script->RunScriptOnScriptStateAndReturnValue(script_state_->Get());\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/bindings/core/v8/scheduled_action.cc)</code><br>\n<br>\n위의 소스코드에서 <code>RunScriptOnScriptStateAndReturnValue</code> 메소드는 직접적인 스크립트의 수행을 V8에게 요청한다.<br>\n<br>\n이 작업은 <code>V8ScriptRunner</code>클래스가 <code>CallFunction</code>을 호출하여 수행된다.<br>\n<br>\n이로서 자바스크립트 엔진에게 제어권이 넘어가게 되고 setTimeout의 첫번째 인자인 콜백 함수가 호출된다.<br>\n<br>\n이로서 setTimeout의 실행 사이클은 종료된다<br>\n<br>\n위와 같은 사실로부터 몇가지 사실을 도출할 수 있다.\\</p>\n<blockquote>\n<p>첫번째, 렌더러 엔진 내부에서 렌더링 과정의 수행과 자바스크립트 코드 실행은 같은 스레드에서 수행된다.<br>\n두번째, 마이크로테스크 큐의 실행은 렌더러 엔진의 스케줄링 과정에 포함되어 있지 않다.<br>\n세번째, 자바스크립트 코드로 호출 가능한 WebAPI는 자바스크립트 엔진 내부에 구현되어 있지 않으며 렌더러 엔진에 구현되어 있다</p>\n</blockquote>\n<p>따라서 WebAPI는 렌더러 엔진을 구현한 프로그래밍 언어로 실행된다. 크로미움의 경우 WebAPI는 C++ 코드로 실행된다.<br>\n<br>\n네번째, 이벤트 루프는 자바스크립트 코드를 수행하는 것을 포함하여 더 넒은 범위의 테스크를 포함한다.<br>\n<br>\n이러한 이벤트 루프는 렌더러의 메인 스레드 내부의 스케줄링 정책에 의해 수행된다.<br>\n<br>\nHTML Living Standard는 이벤트 루프를 다음과 같이 정의한다</p>\n<blockquote>\n<p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section.<br>\nEach agent has an associated event loop, which is unique to that agent.</p>\n</blockquote>\n<p>위의 문장을 해석하면 아래와 같다</p>\n<blockquote>\n<p>이벤트, 사용자와의 상호 작용, 스크립트의 실행, 화면 렌더링, 네트워킹 등을 조정하려면 유저 에이전트(웹 브라우저)는 이 절에 설명된 대로 이벤트 루프를 사용해야 한다.<br>\n유저 에이전트는 각 에이전트 고유의 이벤트 루프를 가지고 있다.</p>\n</blockquote>\n<p>— 참고 : whatwg.org</p>"
    },
    "url": "/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95",
    "file": new URL("file:///D:/project/%EB%A6%AC%EB%88%85%EC%8A%A4%ED%8F%B4%EB%8D%94/myblog_astro/src/pages/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95.md")
  }
}, children);

});
</script><hr class="astro-ldKR6c5M"><p class="astro-ldKR6c5M"><a href="/aboutme" class="astro-ldKR6c5M">주인장 소개</a></p><p class="astro-ldKR6c5M"><a href="https://devkr.info" class="astro-ldKR6c5M">devkr.info로 가기</a></p><p class="astro-ldKR6c5M"><a href="/en" class="astro-ldKR6c5M">go english page</a></p><hr class="astro-ldKR6c5M"><footer class="astro-ldKR6c5M">powered by 
          <svg class="logo astro-RnEq1mMV astro-ldKR6c5M" height="1em" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><style type="text/css">
            #flame.astro-RnEq1mMV.astro-ldKR6c5M {
              fill: #ff5d01;
            }
            #a.astro-RnEq1mMV.astro-ldKR6c5M {
              fill: white;
            }
          </style><title>Astro</title><path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z" class="astro-RnEq1mMV astro-ldKR6c5M"></path><path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z" class="astro-RnEq1mMV astro-ldKR6c5M"></path></svg>
        , github pages
    </footer></div></body></html>