<!DOCTYPE html><html lang="ko"><head><link rel="stylesheet" href="/index.css"><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>LKB BLOG</title><meta name="title" content="LKB BLOG"><meta name="description" content=""><link rel="stylesheet" href="/_astro/common-ZEJS2I.css" type="text/css"><style type="text/css">astro-root, astro-fragment { display: contents; }</style></head><body><div class="wrapper astro-ldKR6c5M"><img id="logo" src="/icon_blog.png" height="50rem" class="astro-ldKR6c5M"><br class="astro-ldKR6c5M">
    LeeKb의 블로그
    <hr class="astro-ldKR6c5M"><astro-root uid="ZG86oO"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload"><p class="title">[html 최적화] preload, prefetch 등에 대하여</p></a></header><time>2021.11.17</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("ZG86oO", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "[html 최적화] preload, prefetch 등에 대하여",
    "description": "preload, prefetch, prerender, pre어쩌고",
    "publishDate": "2021.11.17",
    "astro": {
      "headers": [{
        "depth": 2,
        "slug": "html-최적화-preload-prefetch-등에-대하여",
        "text": "[html 최적화] preload, prefetch 등에 대하여"
      }, {
        "depth": 4,
        "slug": "q-html-파일에서-외부-리소스를-불러오는-방법이-있는가",
        "text": "Q. html 파일에서 외부 리소스를 불러오는 방법이 있는가?"
      }, {
        "depth": 4,
        "slug": "q-link-엘리먼트를-어떻게-기입하면-외부-리소스를-참고할-수-있는가",
        "text": "Q. link 엘리먼트를 어떻게 기입하면 외부 리소스를 참고할 수 있는가?"
      }, {
        "depth": 4,
        "slug": "q-리소스를-처리하는-전략이-무슨뜻인가",
        "text": "Q. 리소스를 처리하는 전략이 무슨뜻인가?"
      }, {
        "depth": 4,
        "slug": "q-말이-너무-추상적인데-리소스를-처리하는-전략에-구체적인-예가-있는가",
        "text": "Q. 말이 너무 추상적인데 리소스를 처리하는 전략에 구체적인 예가 있는가?"
      }, {
        "depth": 4,
        "slug": "q-그렇다면-link-relpreload가-붙은-엘리먼트는-모두-css와-같은-방식으로-다운로드가-수행되는가",
        "text": "Q. 그렇다면 <link rel=\"preload\">가 붙은 엘리먼트는 모두 css와 같은 방식으로 다운로드가 수행되는가?"
      }, {
        "depth": 4,
        "slug": "q-우선순위가-뭔가-우선순위가-높은-순서대로-다운로드-받는다고-했는데-한개씩-순서대로-다운받는가-",
        "text": "Q. 우선순위가 뭔가? 우선순위가 높은 순서대로 다운로드 받는다고 했는데 한개씩 순서대로 다운받는가 ?"
      }, {
        "depth": 4,
        "slug": "q-그런데-왜-동접을-6개-파일로-제한하는가--요즘같은-초고속-인터넷-환경에-그런-제약이-굳이-필요한가-",
        "text": "Q. 그런데 왜 동접을 6개 파일로 제한하는가 ? 요즘같은 초고속 인터넷 환경에 그런 제약이 굳이 필요한가 ?"
      }, {
        "depth": 4,
        "slug": "q-프리로드가-적용된-link가-css-요청하고-비슷하게-작동하는건-알겠다-이런-프리로드를-구체적으로-어떤-상황에-적용할-수-있는가",
        "text": "Q. 프리로드가 적용된 link가 css 요청하고 비슷하게 작동하는건 알겠다. 이런 프리로드를 구체적으로 어떤 상황에 적용할 수 있는가?"
      }, {
        "depth": 4,
        "slug": "또-다른-전략--프리커넥트-preconnect",
        "text": "또 다른 전략 : 프리커넥트 (preconnect)"
      }, {
        "depth": 4,
        "slug": "dns-프리패치-dns-prefetch",
        "text": "DNS 프리패치 (dns-prefetch)"
      }, {
        "depth": 4,
        "slug": "프리패치-prefetch",
        "text": "프리패치 (prefetch)"
      }, {
        "depth": 4,
        "slug": "프리랜더-prerender",
        "text": "프리랜더 (prerender)"
      }, {
        "depth": 4,
        "slug": "q-노-스테이트-프리패치nostate-prefetch가-뭔가",
        "text": "Q. 노 스테이트 프리패치(nostate prefetch)가 뭔가?"
      }, {
        "depth": 4,
        "slug": "q-노-스테이트-프리패치nostate-prefetch를-어떻게-사용할-수-있는가",
        "text": "Q. 노 스테이트 프리패치(nostate prefetch)를 어떻게 사용할 수 있는가?"
      }],
      "source": "\r\n## [html 최적화] preload, prefetch 등에 대하여\r\n\r\n먼저 쉬운 이야기부터 하자\r\n\r\n#### Q. html 파일에서 외부 리소스를 불러오는 방법이 있는가?\r\n\r\nA. 방법이 있다. `<head>` 내부에서 `링크(link)` 엘리먼트를 사용하면 외부 리소스를 불러올 수 있다. 링크는 말그대로 연결해 준다는 뜻이다. html파일과 외부 리소스를 연결해 준다. 연결된 리소스는 연결 즉시 자동으로 반영되기도 하고 내가 리소스를 직접 가져다가 써야 하는 경우도 있다. css의 경우는 링크하는 것 만으로도 자동으로 반영된다\r\n\r\n#### Q. `link` 엘리먼트를 어떻게 기입하면 외부 리소스를 참고할 수 있는가?\r\n\r\nA. 예를 들어 `<link rel=\"stylesheet\" href=\"/style.css\" >` 과 같은 포멧으로 사용할 수 있다. rel 어트리뷰트는 관계(relationship)의 약자인데 현재 문서와 연결할 리소스의 관계가 어떠한지를 기입한다. 무슨말이냐면 `rel=\"stylesheet\"`이라고 기입된 코드는 `html에서 해당 리소스를 스타일시트의 형태로 참고한다`는 뜻으로 해석할 수 있다\r\n또 다른 예인 `<link rel=\"icon\" href=\"favicon.ico\">`는 `html에서 해당 리소스를 아이콘의 형태로 참고한다`는 뜻이다. 이처럼 리소스의 타입을 지정하여 관계를 표기하는 것이 일반적이었다. 과거형을 쓰는 이유는 현재에는 타입에 한정짓지 않고 다른 방식으로도 관계를 표현하기 때문이다. 요즘에는 `리소스를 처리하는 전략`을 기입하여 관계를 지정하기도 한다.\r\n\r\n#### Q. `리소스를 처리하는 전략`이 무슨뜻인가?\r\n\r\nA. 말 그대로 리소스를 어떤 방식으로 처리하는지를 나타낸다. 예를 들어 원래 다운받게 되는 타이밍보다 더 앞당겨 다운로드를 받을지, 아니면 리소스를 다운받아 미리 렌더링해놓고 대기하고 있을지 등 다양한 리소스 처리방식 중 하나를 선택할 수 있다.\r\n`리소스를 처리하는 전략`은 `관계`라고 볼 수 없지만 표준 스펙이 그러하니 그냥 그려러니 하는것이 좋겠다.\r\n\r\n#### Q. 말이 너무 추상적인데 `리소스를 처리하는 전략`에 구체적인 예가 있는가?\r\n\r\nA. link의 rel 어트리뷰트에는 `프리로드(preload)` 라는 옵션을 줄 수 있다. 프리로드는 그 이름이 의미하는 대로 먼저 로드하겠다는 뜻이지만 `먼저 로드`한다는 말은 너무 추상적이라 크게 와닿지는 않는다\\\r\n프리로드는 `마치 css처럼 리소스를 빨리 다운로드 받고 사용하지는 않겠다`는 뜻으로 이해하면 편하다. 비록 이 정의가 정확하지는 않더라도 감을 익히는데는 도움을 준다. 그리고 preload의 `load`는 `사용하기 위한 모든 조건이 갖추어졌지만 아직 사용하지는 않은 상황`을 뜻한다. 이게 내가 아는 가장 쉬운 설명이다.\\\r\n\\\r\n하지만 위의 설명을 듣고도 의문점이 생길 수 있다\r\n\r\n1. css처럼 리소스를 빨리 다운로드 받는다는 말이 무슨말인가? 어떻게 다운로드 받는게 css처럼 다운로드 받는다는 건가?\r\n1. 어떤 자원을 css처럼 빨리 다운로드 받아야 하는가?\r\n\r\n자 하나씩 설명해보자. 먼저 프리로드를 사용하지 않고 css를 다운로드 받는 코드를 준비했다\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <link\r\n      href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"\r\n      rel=\"stylesheet\"\r\n    />\r\n  </head>\r\n  <script>\r\n    alert(\"after head\");\r\n  <\/script>\r\n  <body>\r\n    1234567890\r\n  </body>\r\n</html>\r\n```\r\n\r\n크롬을 켜고 개발자 도구의 Network 탭으로 들어간 뒤에 위의 페이지를 로딩해 보면 아래와 같다\r\n\r\n![aaa](/assets/blog/211117_웹최적화_preload/after_head.png)\r\n\r\n위의 사진은 alert창이 뜨는 시점을 캡쳐해두었다. 즉 위의 소스에서 alert은 head 엘리먼트가 끝나고 body 엘리먼트가 시작되기 중간 지점이다. 그런 상황에서 이미지 중간의 네트워크 요청란을 보면 `boot...`라는 항목이 보일것이다. `bootstrap.min.css`파일을 요청하는 대목인데 여기서 한가지 힌트를 얻을 수 있다. 즉 html 파싱이 채 끝나기도 전에 `head 엘리먼트`의 파싱이 종료된 상황에서 `<link rel=\"stylesheet\">`를 확인하고 css파일의 다운로드 요청을 수행한 것이다. 즉 css의 다운로드 요청은 `head`부분의 파싱이 종료되자 마자 수행된다.\r\n\r\n#### Q. 그렇다면 `<link rel=\"preload\">`가 붙은 엘리먼트는 모두 css와 같은 방식으로 다운로드가 수행되는가?\r\n\r\nA. 비슷하긴 하지만 조금씩 다르다. 먼저 html의 `head` 안에 삽입되어서 head 엘리먼트의 파싱이 종료되자 마자 다운로드가 실행되는 점은 같다. 하지만 다운로드의 우선순위가 다를 수 있다. 리소스는 그 리소스의 타입별로 고유의 우선순위가 부여된다. 이 우선순위는 바꿀 수 없으며 반드시 우선순위가 높은 순서대로 리소스 다운로드가 실행된다. css의 우선순위는 가장높음(highest)이라서 대부분의 경우 head의 파싱이 종료되자 마자 다운로드가 수행된다. 반면 이미지 파일은 우선순위가 낮음(low)이라서 우선순위가 높은 파일들이 많을 경우 바로 다운로드를 수행하지 않고 대기한다\r\n\r\n#### Q. 우선순위가 뭔가? 우선순위가 높은 순서대로 다운로드 받는다고 했는데 한개씩 순서대로 다운받는가 ?\r\n\r\nA. 이걸 이해하려면 웹브라우저의 `연결수 제한`의 개념을 이해해야 한다. 웹브라우저는 같은 도메인에서 동시에 6개의 다운로드가 가능하도록 설계되어 있다. 예를 들어 `www.naver.com`에서 이미지를 다운로드 받는다고 하면 동시에 6개의 이미지만 다운로드가 가능한 것이다. 만일 8개의 이미지를 다운로드 받는다고 하면 먼저 6개의 다운로드를 동시에 수행하고 그 중 하나가 끝나면 나머지 이미지를 다운로드 받는 방식으로 진행된다. 같은 도메인에서 6개를 초과하는 동시 다운로드는 수행될 수 없다.\\\r\n사실 동시 다운로드 제한수는 웹브라우저와 웹브라우저의 버전별로 어느정도 차이가 있다. 본인이 사용하는 크롬 버전 95기준으로는 6개라서 동접제한이 6개라고 설명한 것이다.\\\r\n자 방금 설명한 동접 제한을 바탕으로 우선순위를 설명해보자. 아래와 같은 코드가 있다\r\n\r\n```html\r\n<\r\n<html>\r\n  <head>\r\n    <!-- css 3개 -->\r\n    <link\r\n      rel=\"stylesheet\"\r\n      href=\"https://ssl.pstatic.net/sstatic/search/pc/css/sp_autocomplete_210318.css\"\r\n    />\r\n    <link\r\n      rel=\"stylesheet\"\r\n      type=\"text/css\"\r\n      href=\"https://ssl.pstatic.net/tveta/libs/assets/css/pc/main/min/main_topic_darkmode.min.css?20200601\"\r\n    />\r\n    <link\r\n      rel=\"stylesheet\"\r\n      type=\"text/css\"\r\n      href=\"https://ssl.pstatic.net/tveta/libs/assets/css/pc/main/min/rollingboard_imagerolling_350.min.css?20180427\"\r\n    />\r\n\r\n    <!-- 스크립트 3개  -->\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/share/js/naver_sharebutton.js\"\r\n    />\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/static.gn/js/clickcrD.js\"\r\n    />\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/sstatic/au/s/pc/_common/ime/nhn.ime_search_140825.js\"\r\n    />\r\n\r\n    <!--  이미지 4개  -->\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/pwe/nm/bn/bn_login_02_150128.png\"\r\n    />\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/blank.gif\"\r\n    />\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/common/gnb/one/sp_gnb_v14.png\"\r\n    />\r\n    <link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/mimgnews/image/420/2018/07/17/093447877_09.TY-01.jpg\"\r\n    />\r\n  </head>\r\n  <body>\r\n    1234567890\r\n  </body>\r\n</html>\r\n```\r\n\r\nhead부분에 link가 총 10개 있다. css 링크가 3개이고 스크립트 링크가 3개, 이미지 링크가 4개 있다. 그리고 이 링크의 서버는 모두 `ssl.pstatic.net`로 동일하다. 앞서 말한대로 크롬 95 기준으로 같은 서버에 가능한 동접수는 6개이다. 따라서 10개를 동시에 다운로드 받을 수 없으며 먼저 6개를 선택해야 한다. 자 6개를 선택해 보자\\\r\n위에서 말한 대로 css파일은 우선순위가 가장높음(highest)이고 스크립트 파일은 높음(high)이며 이미지 파일은 우선순위가 낮음(low)이다. 따라서 우선순위는 아래와 같다\r\n\r\n1. 처음 선언한 css 파일\r\n1. 두번째 선언한 css파일\r\n1. 세번째 선언한 css파일\r\n1. 처음 선언한 스크립트 파일\r\n1. 두번째 선언한 스크립트 파일\r\n1. 세번째 선언한 스크립트 파일\r\n1. 처음 선언한 이미지 파일\r\n1. 두번째 선언한 이미지 파일\r\n1. 세번째 선언한 이미지 파일\r\n1. 네번째 선언한 이미지 파일\r\n\r\n위에서 1부터 6번까지가 동시에 다운로드 될 것으로 예상된다. 정말 그럴까 ? 아래는 크롬 개발자 도구의 네트워크 탭에서 워터폴을 표시한 내용이다\r\n\r\n![download_waterfall](/assets/blog/211117_웹최적화_preload/download_waterfall2.png)\r\n\r\n예상대로 우선순위 상위 6개 파일인 css와 스크립트 파일들이 동시에 다운로드 되는것이 보인다. 우선순위가 낮은 이미지 파일의 다운로드는 6개 중 하나의 다운로드가 종료된 2.4초 이후에 수행되었다\r\n\r\n#### Q. 그런데 왜 동접을 6개 파일로 제한하는가 ? 요즘같은 초고속 인터넷 환경에 그런 제약이 굳이 필요한가 ?\r\n\r\nA. 사실 동접 제한은 클라이언트 입장에서 생각하면 이해하기 어렵다. 요즘 인터넷은 충분히 빨라서 6개가 아닌 60개 동시요청도 무리없이 수행할 수 있는 수준이다. 하지만 서버에 입장에서 생각해보라. 만일 다운로드 받을 이미지가 60개가 있어서 60개를 동시에 요청한다고 가정하자. 60은 6의 10배이고 이론상으로는 10배 많은 동시 요청이 발생할 수 있는 것이다. 이런 많은수의 요청이 서버에 과부하를 주어서 퍼포먼스 저하를 야기할 수 있기 때문에 동접을 제한한 것으로 추정된다\r\n\r\n#### Q. 프리로드가 적용된 link가 css 요청하고 비슷하게 작동하는건 알겠다. 이런 프리로드를 구체적으로 어떤 상황에 적용할 수 있는가?\r\n\r\nA. 프리로드가 흔하게 쓰이는 상황은 웹폰트를 다운로드하는 상황이다. 이 웹폰트를 적용하는 가장 흔한 방법은 css파일 내부의 폰트페이스(font-face)에서 외부 리소스로 읽어들이는 방식이다.\r\n구체적인 코드의 예시를 들어보자\r\n\r\n```css\r\n@font-face {\r\n  font-family: \"Bitstream Vera Serif Bold\";\r\n  src: url(\"https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\r\n}\r\n```\r\n\r\n위의 코드는 베라 세리프(`Vera Serif`)라는 폰트를 불러온다. 이 코드가 실행되려면 아래와 같은 과정을 거친다.\r\n\r\n1. 먼저 css를 다운로드 받는다\r\n1. css를 파싱한다\r\n1. font-face에서 src를 발견하면 해당 url에서 리소스를 다운로드 받는다\r\n\r\n위와 같은 과정은 크게 `css다운로드 이후 -> 폰트 다운로드`라는 두 단계로 나뉜다. 하지만 웹폰트를 적용할 때 얼마나 빨리 웹폰트가 웹페이지에 적용되는지는 중요한 문제다. 그러므로 이러한 과정을 더 빠르게 단축시키고 싶다. 가령 css와 폰트파일을 동시에 다운로드 받은 뒤에 css파일에서 다운로드 받은 폰트파일을 바로 적용시키면 `css다운로드 이후 -> 폰트 다운로드` 라는 2개의 스탭을 거치지 않아도 되지 않은가. 그렇다. 이게 프리로드의 존재목적이다. 프리로드를 사용하면 css와 폰트파일을 동시에 다운로드 받을 수 있다. 가령 아래와 같다\r\n\r\n```html\r\n<!-- high 우선순위로 지정됨 -->\r\n<link\r\n  rel=\"preload\"\r\n  href=\"https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\"\r\n  as=\"font\"\r\n  type=\"font/woff2\"\r\n  crossorigin=\"anonymous\"\r\n/>\r\n\r\n<!-- highest 우선순위로 지정됨 -->\r\n<link rel=\"stylesheet\" href=\"/style.css\" />\r\n```\r\n\r\n위의 코드는 다운받을 파일이 2개 뿐이므로 이들 두개는 동시에 다운로드가 진행된다. 그 결과 웹사이트 상에 폰트의 적용이 더욱 빨라질 수 있다.\r\n이와 같은 웹 폰트는 하나의 예시일 뿐이며 css내에서 이미지를 다운받거나 비디오를 다운로드 받는 상황에도 똑같이 적용할 수 있다\r\n\r\n그리고 `프리로드` 사용시에 주의할 점은 `프리로드로 다운받는 것 만으로는 해당 리소스를 직접적으로 사용하지 않는다`는 점이다. 이 프리로드된 파일은 css등의 다른 리소스에서 추가적으로 호출되어야 한다. 만일 해당 자원을 호출하지 않으면 웹브라우저에서 경고 메시지를 보낸다. 크롬의 개발자 도구를 열면 이렇게 프리로드로 호출하고 나서 사용되지 않는 리소스에 대한 경고창을 확인할 수 있다\r\n\r\n![NOSTATE PREFETCH 스크린샷](/assets/blog/211117_웹최적화_preload/preload_error.png)\r\n\r\n위의 내용을 해석하면 `리소스가 프리로드 되었지만 몇초이내에 windows의 로드 이벤트에서 사용되지 않았다. 아마도 as값을 잘못 기입한거 같으니까 as 값이 적절한지 확인해. 그게 아니라면 이게 당신이 의도해서 프리로드한 리소스가 맞는가? 한번 확인해봐라`\\\r\n이런 경고창은 두가지 의미에서 이롭다. 첫째로 내가 작성한 코드가 의도한대로 동작하지 않았다는 것을 알려준다. 즉 웹브라우저가 디버거 역할을 한 것이다.\\\r\n둘째로는 리소스가 프리로드 되고 사용되지 않음으로서 다른 리소스의 다운로드 우선순위가 밀려날 수 있으므로 퍼포먼스 최적화에 악영향을 주니 만일 당신이 사용하지 않는 파일은 프리로드를 걷어내라는 최적화 지침을 내려준다. 이런 지침을 참고하여 개발하면 크롬의 개발자 도구를 훌륭한 디버깅 툴로 이용할 수 있다\r\n\r\n#### 또 다른 전략 : 프리커넥트 (preconnect)\r\n\r\n프리커넥트를 직역하면 서버와 `미리 연결`해 놓는다는 뜻이다. 서버와 연결이라는 과정이 생소할 수 있는데 간단히 말하면 필요한 데이터를 받기 위한 선행과정이다. 자원을 서버에 요청할 때 요청한다고 바로 받아지는건 아니고 `연결`이라는 과정이 필요하다\r\n\r\n이건 미리 서버와 `미리 연결을 완료해 놓고` 필요하면 TCP 핸드쉐이킹 같은 연결과정을 생략한 채 바로 다운받을 수 있도록 준비해 놓겠다는 뜻이다\r\n\r\n프리커넥트는 프리로드와는 다르다. 프리로드는 특정한 자원을 다운로드 한다. 그러나 프리로드는 특정한 자원을 다운로드 하지 않는다. 그저 서버와 미리 연결을 해놓을 뿐이다.\r\n\r\n의아하지 않은가. 왜 바로 다운로드를 받지 않고 `연결만` 해 놓을까? 그건 어떤 데이터를 받아올지 아직 결정되지 않은 상황이기 때문이다. 유저가 요청할 리소스의 URL이 상황에 따라서 변경되는 상황이 있다. 프리커넥트는 그런 상황에 쓴다\r\n\r\n예를 들어보자. 구직자인 당신은 원서지원 사이트인 `원서지원.com`에 접속했다. 어떤 기업에 원서를 지원하려 하는데 삼성에 지원할 수도 있고 엘지에 지원할 수도 있다. 만일 삼성에 지원한다면 `양식모음.com/form/samsung`에서 제공하는 지원양식을 다운받아야 한다. 그리고 엘지에 지원한다면 `양식모음.com/form/lg` 라는 URL에서 지원양식을 다운받아야 한다. 자 이런 상황은 지원자가 구체적으로 어떤 회사에 지원할지 예측할 수 없다. 이 때 프리커넥트를 사용하지 않았다고 가정해 보자. 만일 삼성 지원자가 `양식 다운받기` 버튼을 클릭해서 `양식모음.com/form/samsung`에 접속한다. 이 때 다음과 같은 프로세스가 진행된다\r\n\r\n1. `양식모음.com`에 대응하는 DNS를 룩업한다\r\n1. 룩업한 dns를 기반으로 TCP 3웨이 핸드쉐이킹을 수행한다\r\n1. tcp 커넥션이 완료되면 보안을 위해 TLS 핸드쉐이킹을 수행한다\r\n1. 요청한 url에서 데이터를 다운로드 받는다\r\n\r\n이런 과정으로 진행된다. 즉 마지막에 데이터를 다운로드 받기 전까지 3가지 선행과정을 필요로 한다\r\n그런데 위의 3가지 과정은 단지 서버와 연결하는 과정이다. 즉 구체적인 URL을 몰라도 서버 주소만 안다면 연결할 수 있다. 즉 위의 예에서는 `양식모음.com`에 접속하는 것만으로도 연결을 구축할 수 있다. 자 만일 이러한 요청을 먼저 구축한 상태에서 삼성 지원자가 `양식 다운받기` 버튼을 클릭하면 어떤 프로세스가 진행될까?\r\n\r\n1. 요청한 url에서 데이터를 다운로드 받는다\r\n\r\n이게 전부다. 즉 연결에 필요한 모든 과정이 생략된다. 이것은 빠르며 빠른 반응은 유저에게 만족감을 준다\\\r\n결론을 말하자면 유저가 요청할 엔드포인트가 분명하지는 않지만 서버 주소는 확실한 경우 프리커넥트를 사용하여 속도상의 이득을 볼 수 있다. 이렇게 미리 서버와 `연결`해 놓으면 유저가 필요한 데이터를 요청할 때 즉각적인 응답을 보장할 수 있다. 프리커넥트는 이러한 상황에 쓰인다\r\n\r\n그리고 여담이지만 `web.dev`는 프리커넥트를 이렇게 광고하고 있다\r\n`chrome.com 은 중요한 출처에 사전 연결하여 Time To Interactive 를 거의 1초 개선했습니다`\\\r\n1초라. 웹에서 1초는 큰 시간이다. 위의 말이 맞다면 프리커넥트를 사용할 가치는 충분하다\r\n\r\n#### DNS 프리패치 (dns-prefetch)\r\n\r\nDNS 프리패치는 프리커넥트와 비슷하다. 하지만 프리커넥트의 열화 버전이라고 생각하면 좋다.\r\n프리커넥트가 `dns 룩업 -> TCP 핸드쉐이킹 -> TLS 핸드쉐이킹` 이라는 3단계를 거치는 반면 dns 프리패치는 `dns 룩업` 의 1단계만을 수행한다. 즉 DNS 프리패치를 수행하고 나서 추가로 TCP핸드쉐이킹과 TLS핸드쉐이킹을 별도로 수행해야 하므로 리소스를 받아오는 시간이 프리커넥트 보다는 느리다.\\\r\n\\\r\n그러면 이렇게 느린 dns 프리패치를 왜 쓰는가? 클라이언트 입장에서만 보면 dns-프리패치를 사용할 이유는 없어보인다. 하지만 서버의 관점에서 생각해보라. 프리커넥트는 TCP 핸드쉐이킹과 TLS 핸드쉐이킹을 추가로 수행한다. 이런 핸드쉐이킹을 수행하는 과정에서 서버의 CPU와 램 등의 자원이 소비된다. 이것이 서버의 자원낭비로 이어질 수도 있다. 이해가 어려울 텐데 예를 들어보자.\\\r\n\\\r\n어떤 리소스를 빠르게 다운로드 받으려고 프리커넥트를 걸었다고 가정해 보자. 그런데 이 리소스는 그렇게 빠르게 다운로드 받을 필요는 없는 자원이다. 그런 상황에서 동접자가 10만인 사이트라면 10만개의 커넥션이 생성된다. 이것이 서버에 과부하를 주어서 먼저 급하게 수행되어야 할 프로세스에 악영향을 줄 수도 있다.\\\r\n실제로 아마존닷컴은 프리커넥트 대신 dns 프리패치 전략을 구사한다. 위에서 언급했듯이 서버의 과부하를 막기 위함이다. 아래 코드는 `amazon.com`에 접속하여 개발자 도구로 확인할 수 있다\r\n\r\n```html\r\n<link rel=\"dns-prefetch\" href=\"https://images-na.ssl-images-amazon.com\" />\r\n<link rel=\"dns-prefetch\" href=\"https://m.media-amazon.com\" />\r\n<link rel=\"dns-prefetch\" href=\"https://completion.amazon.com\" />\r\n```\r\n\r\n위의 코드에서 세번째 라인을 주목하자. `completion.amazon.com`은 검색어 자동완성에 쓰이는 URL이다. 아마존 메인페이지에서 검색어를 입력하면 해당 URL에 리퀘스트를 날려서 예상되는 자동완성 문자열을 받아온다.\\\r\n자 그런데 이런 자동완성 기능이 반드시 쓰이는 기능인가? 그렇지 않다. 사람들이 아마존에 검색해서 꼭 상품을 검색하리라는 보장은 없다. 마이 페이지에 들어가서 재구매를 할 수도 있는것이고 오늘의 핫딜 페이지를 서핑할 수도 있는것이고 브라우징 히스토리를 열람해서 내가 이전에 둘러봤던 상품 페이지로 이동할 수도 있다. 즉 아마존에 접속한 모든 사람들이 검색어 입력을 하는 것은 아니다.\\\r\n이런 상황에서 모든 유저들이 `completion.amazon.com`에 프리커넥트를 요청한다면 어떻게 될까? 해당 사이트는 수백만건의 TCP핸드쉐이크와 TLS핸드쉐이크를 하느라 자원을 소비할 것이고 먼저 급하게 처리되어야 할 리퀘스트 요청이 지연될 수 있다. 실제로 상품을 검색하는 유저가 이런 지연을 겪는다면 그것은 불쾌한 경험이다. 이처럼 모든 유저가 URL을 요청할 거라는 보장이 없는 상황에서는 무분별한 프리커넥트의 사용이 서버 퍼포먼스의 저하를 야기할 수 있다.\\\r\n즉 DNS 프리패치는 아래와 같은 상황에서 사용할 수 있다\r\n\r\n1. 과중하게 트래픽이 몰리는 서버\r\n1. 클라이언트가 서버에 요청을 할지 말지가 분명하지 않은 상황\r\n\r\n만일 서버의 CPU나 램 등의 자원이 너무 풍부해서 연결 요청이 얼마가 되든지 퍼포먼스의 하락이 걱정되지 않는 상황이라면 DNS 프리패치를 사용할 이유는 없다. 이런 상황에서는 프리커넥트가 권장된다\r\n\r\n#### 프리패치 (prefetch)\r\n\r\n프리패치는 `미리 다운로드`한다는 뜻이다. html파일, 스크립트 파일, css 등의 파일을 미리 다운로드 해놓는다.\r\n문제는 `미리 다운로드`같은 적당한 용어가 사람들을 헷갈리게 한다. `미리 다운로드`한다는 말이 무슨뜻인가?\\\r\n\\\r\n결론만 말하면 `다음 페이지에서 사용할 리소스`를 미리 다운로드 한다는 뜻이다.\r\n미리 다운로드 받은 자원은 다음 페이지에서 자원을 요청할 때 캐쉬로 사용할 수 있다.\r\n예를 들어 다음 페이지에 `<link rel=\"stylesheet\" >`처럼 css 파일을 요청하는 코드가 있을 때, 지금 페이지에서 미리 css 파일을 다운로드 받아놓는다. 그리고 그 다운받은 파일을 메모리 어딘가에 저장해놓는다. 그러면 다음 페이지로 이동했을 때 굳이 서버에서 css를 가져올 필요 없이 메모리에 저장해놓은 캐쉬를 가져와서 사용하면 된다. 이게 프리패치다\r\n\r\n자 그러면 한번 생각해보자. 다음 페이지에서 사용할 데이터를 가져오는 작업의 우선순위가 높아야하는가?\r\n아니다. 낮아도 된다. 왜냐하면 다음페이지로 넘어가기 전 까지만 다운로드 받으면 되기 때문이다. 당장 급하게 사용할 자원이 아니라는 뜻이다. 더군다나 프리패치의 우선순위가 높아서 더 먼저 처리해야 하는 리소스의 순위가 밀려나면 현재 페이지의 렌더링이 느려진다. 이것은 사용자에게 불쾌한 경험이다. 따라서 프리패치의 우선순위가 `최저(lowest)`인 것은 납득할만한 일이다\\\r\n\\\r\n그런데 몇가지 궁금증이 생길 수 있다.\r\n\r\n> 잠깐만, 유저가 다음 페이지로 넘어갈지 안넘어갈지 어떻게 알지? 그 페이지만 보고 그냥 접속을 꺼버릴 수도 있는 거잖아?\\\r\n> 그리고, 다음 페이지로 연결된 링크가 한개가 아니고 수십개인 상황에서는 어떤 페이지로 넘어갈 지 예측할수도 없는데 이런 상황에서는 프리패치를 어떻게 하지?\r\n\r\n자 결론부터 말하면 이건 `확률게임`이다. 유저가 다음페이지로 넘어갈지 여기서 접속을 종료할지는 알 수 없다. 독심술사도 아니고 그런걸 알 방법은 없다. 그러므로 그저 높은 확률을 찍을 뿐이다. 만일 통계상 유저가 다음 페이지로 넘어갈 확률이 `95%` 정도라면 프리패치를 할 가치는 충분하다. 나머지 5%의 유저가 페이지를 이탈하여 그저 트래픽 낭비로 이어질지라도 `95%` 유저의 쾌적환 UX경험이 이를 상쇄한다.\\\r\n그러면 당신은 반문할 것이다.\r\n\r\n> 유저가 다음 페이지로 넘어갈 확률이 몇퍼센트 이상일 때 프리패치를 하는것이 좋지? 70%이상인가? 60% 이상인가?\r\n\r\n이것은 정답이 없으며 제공하는 서비스의 종류에 따라 달라진다. 만일 다음 페이지의 로딩이 느려도 상관없다면 프리패치를 전혀 하지 않아도 된다. 그런 페이지가 있냐고? 있다. 환불 페이지나 구독 취소 페이지 같은 페이지들은 기업 입장에서 페이지 로딩이 빨라야 할 이유가 없다\\\r\n반면 다음 페이지의 로딩속도가 기업의 이윤과 직결되는 중요한 페이지라서 0.01초라도 빨리 수행되어야 하는 서비스라면? 이런 경우는 유저가 다음 페이지로 넘어갈 확률이 50% 미만인 경우라도 무조건 프리패치를 하는 것이 기업의 이윤에 도움이 될 것이다\r\n\r\n문제는 다음 페이지로 이동하는 링크가 여러개인 경우인데 이것도 `확률게임`이다. 사이트 관리자는 특정 유저가 어느 페이지로 이동할 가능성이 높은지 확률 모델을 구축할 수 있다. 이 확률에 근거하여 가장 방문 가능성이 높은 페이지의 리소스를 미리 프리로딩하는 전략이 가장 보편적이다.\\\r\n물론 이런 방법이 정답은 아니다. 만일 유저가 가장 방문 가능성이 높은 페이지가 아니라 2번째로 방문 가능성이 높은 페이지를 방문한다면 프리패치의 덕을 볼 수 없다. 그러므로 방문 확률이 높은 1, 2, 3번째 페이지의 리소스를 통째로 프리패치하는 전략도 생각해볼만 한것이다.\\\r\n\\\r\n여기서 한가지 의문이 들 것이다. 방문 가능성이 높은 페이지를 구체적으로 어떻게 알아내지. 어떤 알고리즘을 써야하나? 누가 미리 만들어놓은 라이브러리가 있지 않을까?\\\r\n그렇다. `guess.js` 는 확률에 기반하여 방문페이지를 예측하는 라이브러리다. 상세 주소는 `https://github.com/guess-js/guess`이니 관심이 있으면 참조해 보는것이 좋겠다\\\r\n\\\r\n그 외의 대중적인 전략은 호버링 전략이다. 유저가 특정 링크에 마우스를 올려놓는 행위를 호버링이라고 하는데 이렇게 호버링을 하는 상황을 이벤트리스너로 탐지하여 프리패치를 수행하는 전략이다. 이것은 `next.js`에서 수행하는 기법인데 만일 모든 페이지의 링크가 버튼으로만 이루어져 있는 사이트라면 백퍼센트에 육박하는 히트 레이트를 보여준다. 다만 유저가 링크에 마우스를 올려놓고 클릭하는 행위가 매우 찰나에 이루어진다면 그 짦은 시간동안 프리패치가 온전히 수행되지 않을수도 있다. 즉 모든 리소스를 미리 로딩해 놓고 페이지가 이동되자 마자 바로 짠하고 보여주기는 어려울 수도 있다. 이처럼 프리패치 전략에는 모두 장단점이 있어서 어느 하나를 고집하기는 어려운 것이다\r\n\r\n#### 프리랜더 (prerender)\r\n\r\n프리랜더는 말 그대로 미리 랜더링 한다는 뜻이다. 대략적인 문법은 `<link rel=\"prerender\" href=\"/이동할_페이지의_URL\">` 처럼 사용한다.\\\r\n프리랜더는 프리패치와 같은 컨셉이다. 다음 페이지에 사용할 리소스를 미리 다운로드 받아서 캐쉬로 사용하겠다는 전략이다. 하지만 프리패치에서 한단계 진화된 버전인데 받아온 리소스를 먼저 `렌더링`한다\\\r\n이 렌더링이라는 작업을 오해하기 쉬운데 프리랜더 전략으로 리소스를 가져온다고 하더라도 웹브라우저 상에서는 가시적인 아무런 변화가 없다. 그래서 `뭐가 렌더링이 됐다는 건가?`하고 의아해 할 수 있다. 정상적인 반응이다. 이 렌더링 작업은 백그라운드에서 진행되기 때문에 눈에 보이지 않는다. 백그라운드에서 새로운 탭을 생성하여 그 탭에서 html을 파싱하여 돔트리를 만들고 렌더 트리를 만들고 필요하다면 자바스크립트까지 실행한다. 이렇게 미리 다음 페이지를 렌더링 한 상황에서 유저가 다음 페이지로 이동하는 버튼을 클릭하면 어떤 일이 벌어질까? 이미 렌더링 되어있는 렌더 트리를 모니터상에 페인팅하면 될 뿐이다.\\\r\n즉 일반적인 페이지 이동에 비해서 웹브라우저에서 처리해야 하는 프로세스가 줄어든다. 일반적인 페이지 이동시에 웹브라우저는 아래와 같은 프로세스를 거친다\r\n\r\n1. 유저가 다음페이지로 이동 버튼을 클릭한다\r\n1. 다음페이지의 URL에서 html 파일을 다운로드받는다\r\n1. html을 파싱한다\r\n1. 파싱한 html을 해석하여 dom 트리와 cssom 트리를 생성한다\r\n1. dom트리와 cssom 트리를 합병하여 렌더트리를 생성한다\r\n1. 렌더트리와 웹브라우저의 창크기를 기반으로 픽셀을 생성한다\r\n1. 여러 레이어로 분리된 픽셀을 합병하여 화면상에 드러나는 부분만 비트맵을 생성한다\r\n1. 비트맵 정보를 OS 커널을 통하여 GPU 하드웨어에 전송한다\r\n1. GPU에서 모니터로 픽셀 정보를 전송한다\r\n1. 모니터가 픽셀을 뿌린다\r\n\r\n이것이 웹페이지 이동시에 일어나는 일반적인 과정이라면 이미 프리랜더링 되어있는 상태에서는 위의 2-5 스탭이 스킵된다. 즉 아래와 같다\r\n\r\n1. 유저가 다음페이지로 이동 버튼을 클릭한다\r\n1. 이미 생성된 렌더트리와 웹브라우저의 창크기를 기반으로 픽셀을 생성한다\r\n1. 여러 레이어로 분리된 픽셀을 합병하여 화면상에 드러나는 부분만 비트맵을 생성한다\r\n1. 비트맵 정보를 OS 커널을 통하여 GPU 하드웨어에 전송한다\r\n1. GPU에서 모니터로 픽셀 정보를 전송한다\r\n1. 모니터가 픽셀을 뿌린다\r\n\r\n이것이 전부다. 두말할 것 없이 빠르다.\\\r\n즉 프리랜더는 다음과 같은 상황에서 수행할 수 있다\r\n\r\n1. 유저가 다음 페이지로 이동할 가능성이 높은 경우\r\n1. 동시에 다음 페이지의 화면을 빠르게 보여줘야 하는 경우\r\n\r\n이런 프리랜더가 퍼포먼스 면에서는 우수하지만 메모리를 많이 잡아먹는다는 단점이 있다. 크로미움 계열 웹브라우저에서 프리랜더는 약 100~150메가 가량의 메모리를 소비한다. 메모리가 넉넉한 데스크탑 환경이라면 메모리에 의한 디메리트가 크게 신경쓸 수준은 아니다. 하지만 메모리 크기가 적은 모바일 환경에서는 상당히 걸림돌이 될 수 있다.\\\r\n그래서 크롬 웹브라우저는 메모리 크기가 일정수준 이하인 디바이스에서 프리랜더를 수행하지 않는다. `프리랜드(prerender)` 키워드가 있더라도 프리랜더 대신 `프리커넥트(preconnect)`를 수행한다. 이러한 로우엔드 디바이스의 프리랜더링 문제는 아직까지도 해결되지 않고 있다. 이것은 메모리 크기라는 하드웨어적인 한계이므로 앞으로도 극복 방안이 없을 것으로 보인다.\r\n\r\n구글 크롬팀은 이러한 메모리 문제 때문에 곪머리를 앓고 있던 도중 `노 스테이트 프리패치(nostate prefetch)`라는 개념을 고안해 냈다.\r\n\r\n#### Q. 노 스테이트 프리패치(nostate prefetch)가 뭔가?\r\n\r\nA. 노스테이트 프리패치는 프리랜더링과 개념적으로는 거의 유사하지만 메모리를 덜 잡아먹는 것을 목표로 설계되었다. 이는 최대 45메가의 메모리를 소비한다.\\\r\n그렇다면 `노 스테이트 프리패치`가 메모리 사이즈가 적은 로우엔드 디바이스에서도 작동할까? 그렇지는 않다. 노 스테이트 프리패치가 작동하기 위한 두가지 조건이 있다\r\n\r\n1. 유저의 장치가 로우엔드 디바이스가 아닐 것\r\n1. 유저가 LTE나 5G등의 이동통신 네트워크에 접속한 상태가 아닐 것. 이 조건이 붙은 이유는 유저가 원치 않는 데이터 사용을 막기 위함이다. 만일 유저가 원치 않는 상황에서 무분별하게 프리패치를 수행했다가 요금 폭탄이라도 맞으면 누가 책임을 질 것인가. 그러므로 5G등의 환경에서는 노스테이트 프리패치가 작동하지 않는다\r\n\r\n(상세는 [여기](https://developers.google.com/web/updates/2018/07/nostate-prefetch)를 참고할 것)\r\n\r\n#### Q. 노 스테이트 프리패치(nostate prefetch)를 어떻게 사용할 수 있는가?\r\n\r\nA. 아래 스탭을 따라하시오\r\n\r\n1. 크로미움 계열의 웹브라우저에서 URL란에 `chrome://flags/`를 입력한다\r\n2. 검색란에 `nostate`라고 검색한다. 그러면 크롬 버전 95.0.4638.69 기준으로 아래와 같은 항목이 뜬다\r\n\r\n![NOSTATE PREFETCH 스크린샷](/assets/blog/211117_웹최적화_preload/NOSTATE_PREFETCH.png)\r\n\r\n`Enable NoStatePrefetch on Navigation Predictor Isolated Prerenders`라는 항목이 보이는데 아래 설명란에 보면 `고립된 프리랜더에서 Nostate Prefetch를 활성화한다`라고 적혀있다. `고립된 프리랜더`라는건 프리랜더가 외부와 리소스 공유를 하지 않는다는 의미로 보인다.\r\n이 옵션을 활성화하면 `<link rel=\"prerender\">` 라고 적혀있는 리소스 요청문을 실행할 때 노스테이트 프리패치 방식으로 작동한다. 즉 전통적인 프리렌더링 대비 메모리 사이즈를 절감할 수 있다\r\n\r\n-- 끝\r\n",
      "html": "<h2 id=\"html-최적화-preload-prefetch-등에-대하여\">[html 최적화] preload, prefetch 등에 대하여</h2>\n<p>먼저 쉬운 이야기부터 하자</p>\n<h4 id=\"q-html-파일에서-외부-리소스를-불러오는-방법이-있는가\">Q. html 파일에서 외부 리소스를 불러오는 방법이 있는가?</h4>\n<p>A. 방법이 있다. <code>&lt;head></code> 내부에서 <code>링크(link)</code> 엘리먼트를 사용하면 외부 리소스를 불러올 수 있다. 링크는 말그대로 연결해 준다는 뜻이다. html파일과 외부 리소스를 연결해 준다. 연결된 리소스는 연결 즉시 자동으로 반영되기도 하고 내가 리소스를 직접 가져다가 써야 하는 경우도 있다. css의 경우는 링크하는 것 만으로도 자동으로 반영된다</p>\n<h4 id=\"q-link-엘리먼트를-어떻게-기입하면-외부-리소스를-참고할-수-있는가\">Q. <code>link</code> 엘리먼트를 어떻게 기입하면 외부 리소스를 참고할 수 있는가?</h4>\n<p>A. 예를 들어 <code>&lt;link rel=\"stylesheet\" href=\"/style.css\" ></code> 과 같은 포멧으로 사용할 수 있다. rel 어트리뷰트는 관계(relationship)의 약자인데 현재 문서와 연결할 리소스의 관계가 어떠한지를 기입한다. 무슨말이냐면 <code>rel=\"stylesheet\"</code>이라고 기입된 코드는 <code>html에서 해당 리소스를 스타일시트의 형태로 참고한다</code>는 뜻으로 해석할 수 있다\r\n또 다른 예인 <code>&lt;link rel=\"icon\" href=\"favicon.ico\"></code>는 <code>html에서 해당 리소스를 아이콘의 형태로 참고한다</code>는 뜻이다. 이처럼 리소스의 타입을 지정하여 관계를 표기하는 것이 일반적이었다. 과거형을 쓰는 이유는 현재에는 타입에 한정짓지 않고 다른 방식으로도 관계를 표현하기 때문이다. 요즘에는 <code>리소스를 처리하는 전략</code>을 기입하여 관계를 지정하기도 한다.</p>\n<h4 id=\"q-리소스를-처리하는-전략이-무슨뜻인가\">Q. <code>리소스를 처리하는 전략</code>이 무슨뜻인가?</h4>\n<p>A. 말 그대로 리소스를 어떤 방식으로 처리하는지를 나타낸다. 예를 들어 원래 다운받게 되는 타이밍보다 더 앞당겨 다운로드를 받을지, 아니면 리소스를 다운받아 미리 렌더링해놓고 대기하고 있을지 등 다양한 리소스 처리방식 중 하나를 선택할 수 있다.\r\n<code>리소스를 처리하는 전략</code>은 <code>관계</code>라고 볼 수 없지만 표준 스펙이 그러하니 그냥 그려러니 하는것이 좋겠다.</p>\n<h4 id=\"q-말이-너무-추상적인데-리소스를-처리하는-전략에-구체적인-예가-있는가\">Q. 말이 너무 추상적인데 <code>리소스를 처리하는 전략</code>에 구체적인 예가 있는가?</h4>\n<p>A. link의 rel 어트리뷰트에는 <code>프리로드(preload)</code> 라는 옵션을 줄 수 있다. 프리로드는 그 이름이 의미하는 대로 먼저 로드하겠다는 뜻이지만 <code>먼저 로드</code>한다는 말은 너무 추상적이라 크게 와닿지는 않는다<br>\n프리로드는 <code>마치 css처럼 리소스를 빨리 다운로드 받고 사용하지는 않겠다</code>는 뜻으로 이해하면 편하다. 비록 이 정의가 정확하지는 않더라도 감을 익히는데는 도움을 준다. 그리고 preload의 <code>load</code>는 <code>사용하기 위한 모든 조건이 갖추어졌지만 아직 사용하지는 않은 상황</code>을 뜻한다. 이게 내가 아는 가장 쉬운 설명이다.<br>\n<br>\n하지만 위의 설명을 듣고도 의문점이 생길 수 있다</p>\n<ol>\n<li>css처럼 리소스를 빨리 다운로드 받는다는 말이 무슨말인가? 어떻게 다운로드 받는게 css처럼 다운로드 받는다는 건가?</li>\n<li>어떤 자원을 css처럼 빨리 다운로드 받아야 하는가?</li>\n</ol>\n<p>자 하나씩 설명해보자. 먼저 프리로드를 사용하지 않고 css를 다운로드 받는 코드를 준비했다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;html>\r\n  &lt;head>\r\n    &lt;link\r\n      href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\"\r\n      rel=\"stylesheet\"\r\n    />\r\n  &lt;/head>\r\n  &lt;script>\r\n    alert(\"after head\");\r\n  &lt;/script>\r\n  &lt;body>\r\n    1234567890\r\n  &lt;/body>\r\n&lt;/html>\n</code></pre>\n<p>크롬을 켜고 개발자 도구의 Network 탭으로 들어간 뒤에 위의 페이지를 로딩해 보면 아래와 같다</p>\n<p><img src=\"/assets/blog/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload/after_head.png\" alt=\"aaa\"></p>\n<p>위의 사진은 alert창이 뜨는 시점을 캡쳐해두었다. 즉 위의 소스에서 alert은 head 엘리먼트가 끝나고 body 엘리먼트가 시작되기 중간 지점이다. 그런 상황에서 이미지 중간의 네트워크 요청란을 보면 <code>boot...</code>라는 항목이 보일것이다. <code>bootstrap.min.css</code>파일을 요청하는 대목인데 여기서 한가지 힌트를 얻을 수 있다. 즉 html 파싱이 채 끝나기도 전에 <code>head 엘리먼트</code>의 파싱이 종료된 상황에서 <code>&lt;link rel=\"stylesheet\"></code>를 확인하고 css파일의 다운로드 요청을 수행한 것이다. 즉 css의 다운로드 요청은 <code>head</code>부분의 파싱이 종료되자 마자 수행된다.</p>\n<h4 id=\"q-그렇다면-link-relpreload가-붙은-엘리먼트는-모두-css와-같은-방식으로-다운로드가-수행되는가\">Q. 그렇다면 <code>&lt;link rel=\"preload\"></code>가 붙은 엘리먼트는 모두 css와 같은 방식으로 다운로드가 수행되는가?</h4>\n<p>A. 비슷하긴 하지만 조금씩 다르다. 먼저 html의 <code>head</code> 안에 삽입되어서 head 엘리먼트의 파싱이 종료되자 마자 다운로드가 실행되는 점은 같다. 하지만 다운로드의 우선순위가 다를 수 있다. 리소스는 그 리소스의 타입별로 고유의 우선순위가 부여된다. 이 우선순위는 바꿀 수 없으며 반드시 우선순위가 높은 순서대로 리소스 다운로드가 실행된다. css의 우선순위는 가장높음(highest)이라서 대부분의 경우 head의 파싱이 종료되자 마자 다운로드가 수행된다. 반면 이미지 파일은 우선순위가 낮음(low)이라서 우선순위가 높은 파일들이 많을 경우 바로 다운로드를 수행하지 않고 대기한다</p>\n<h4 id=\"q-우선순위가-뭔가-우선순위가-높은-순서대로-다운로드-받는다고-했는데-한개씩-순서대로-다운받는가-\">Q. 우선순위가 뭔가? 우선순위가 높은 순서대로 다운로드 받는다고 했는데 한개씩 순서대로 다운받는가 ?</h4>\n<p>A. 이걸 이해하려면 웹브라우저의 <code>연결수 제한</code>의 개념을 이해해야 한다. 웹브라우저는 같은 도메인에서 동시에 6개의 다운로드가 가능하도록 설계되어 있다. 예를 들어 <code>www.naver.com</code>에서 이미지를 다운로드 받는다고 하면 동시에 6개의 이미지만 다운로드가 가능한 것이다. 만일 8개의 이미지를 다운로드 받는다고 하면 먼저 6개의 다운로드를 동시에 수행하고 그 중 하나가 끝나면 나머지 이미지를 다운로드 받는 방식으로 진행된다. 같은 도메인에서 6개를 초과하는 동시 다운로드는 수행될 수 없다.<br>\n사실 동시 다운로드 제한수는 웹브라우저와 웹브라우저의 버전별로 어느정도 차이가 있다. 본인이 사용하는 크롬 버전 95기준으로는 6개라서 동접제한이 6개라고 설명한 것이다.<br>\n자 방금 설명한 동접 제한을 바탕으로 우선순위를 설명해보자. 아래와 같은 코드가 있다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;\r\n&lt;html>\r\n  &lt;head>\r\n    &lt;!-- css 3개 -->\r\n    &lt;link\r\n      rel=\"stylesheet\"\r\n      href=\"https://ssl.pstatic.net/sstatic/search/pc/css/sp_autocomplete_210318.css\"\r\n    />\r\n    &lt;link\r\n      rel=\"stylesheet\"\r\n      type=\"text/css\"\r\n      href=\"https://ssl.pstatic.net/tveta/libs/assets/css/pc/main/min/main_topic_darkmode.min.css?20200601\"\r\n    />\r\n    &lt;link\r\n      rel=\"stylesheet\"\r\n      type=\"text/css\"\r\n      href=\"https://ssl.pstatic.net/tveta/libs/assets/css/pc/main/min/rollingboard_imagerolling_350.min.css?20180427\"\r\n    />\r\n\r\n    &lt;!-- 스크립트 3개  -->\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/share/js/naver_sharebutton.js\"\r\n    />\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/static.gn/js/clickcrD.js\"\r\n    />\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"script\"\r\n      href=\"https://ssl.pstatic.net/sstatic/au/s/pc/_common/ime/nhn.ime_search_140825.js\"\r\n    />\r\n\r\n    &lt;!--  이미지 4개  -->\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/pwe/nm/bn/bn_login_02_150128.png\"\r\n    />\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/blank.gif\"\r\n    />\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/static/common/gnb/one/sp_gnb_v14.png\"\r\n    />\r\n    &lt;link\r\n      rel=\"preload\"\r\n      as=\"image\"\r\n      href=\"https://ssl.pstatic.net/mimgnews/image/420/2018/07/17/093447877_09.TY-01.jpg\"\r\n    />\r\n  &lt;/head>\r\n  &lt;body>\r\n    1234567890\r\n  &lt;/body>\r\n&lt;/html>\n</code></pre>\n<p>head부분에 link가 총 10개 있다. css 링크가 3개이고 스크립트 링크가 3개, 이미지 링크가 4개 있다. 그리고 이 링크의 서버는 모두 <code>ssl.pstatic.net</code>로 동일하다. 앞서 말한대로 크롬 95 기준으로 같은 서버에 가능한 동접수는 6개이다. 따라서 10개를 동시에 다운로드 받을 수 없으며 먼저 6개를 선택해야 한다. 자 6개를 선택해 보자<br>\n위에서 말한 대로 css파일은 우선순위가 가장높음(highest)이고 스크립트 파일은 높음(high)이며 이미지 파일은 우선순위가 낮음(low)이다. 따라서 우선순위는 아래와 같다</p>\n<ol>\n<li>처음 선언한 css 파일</li>\n<li>두번째 선언한 css파일</li>\n<li>세번째 선언한 css파일</li>\n<li>처음 선언한 스크립트 파일</li>\n<li>두번째 선언한 스크립트 파일</li>\n<li>세번째 선언한 스크립트 파일</li>\n<li>처음 선언한 이미지 파일</li>\n<li>두번째 선언한 이미지 파일</li>\n<li>세번째 선언한 이미지 파일</li>\n<li>네번째 선언한 이미지 파일</li>\n</ol>\n<p>위에서 1부터 6번까지가 동시에 다운로드 될 것으로 예상된다. 정말 그럴까 ? 아래는 크롬 개발자 도구의 네트워크 탭에서 워터폴을 표시한 내용이다</p>\n<p><img src=\"/assets/blog/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload/download_waterfall2.png\" alt=\"download_waterfall\"></p>\n<p>예상대로 우선순위 상위 6개 파일인 css와 스크립트 파일들이 동시에 다운로드 되는것이 보인다. 우선순위가 낮은 이미지 파일의 다운로드는 6개 중 하나의 다운로드가 종료된 2.4초 이후에 수행되었다</p>\n<h4 id=\"q-그런데-왜-동접을-6개-파일로-제한하는가--요즘같은-초고속-인터넷-환경에-그런-제약이-굳이-필요한가-\">Q. 그런데 왜 동접을 6개 파일로 제한하는가 ? 요즘같은 초고속 인터넷 환경에 그런 제약이 굳이 필요한가 ?</h4>\n<p>A. 사실 동접 제한은 클라이언트 입장에서 생각하면 이해하기 어렵다. 요즘 인터넷은 충분히 빨라서 6개가 아닌 60개 동시요청도 무리없이 수행할 수 있는 수준이다. 하지만 서버에 입장에서 생각해보라. 만일 다운로드 받을 이미지가 60개가 있어서 60개를 동시에 요청한다고 가정하자. 60은 6의 10배이고 이론상으로는 10배 많은 동시 요청이 발생할 수 있는 것이다. 이런 많은수의 요청이 서버에 과부하를 주어서 퍼포먼스 저하를 야기할 수 있기 때문에 동접을 제한한 것으로 추정된다</p>\n<h4 id=\"q-프리로드가-적용된-link가-css-요청하고-비슷하게-작동하는건-알겠다-이런-프리로드를-구체적으로-어떤-상황에-적용할-수-있는가\">Q. 프리로드가 적용된 link가 css 요청하고 비슷하게 작동하는건 알겠다. 이런 프리로드를 구체적으로 어떤 상황에 적용할 수 있는가?</h4>\n<p>A. 프리로드가 흔하게 쓰이는 상황은 웹폰트를 다운로드하는 상황이다. 이 웹폰트를 적용하는 가장 흔한 방법은 css파일 내부의 폰트페이스(font-face)에서 외부 리소스로 읽어들이는 방식이다.\r\n구체적인 코드의 예시를 들어보자</p>\n<pre class=\"language-css\" lang=\"css\"><code class=\"language-css\" lang=\"css\">@font-face ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  font-family: \"Bitstream Vera Serif Bold\";\r\n  src: url(\"https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\r\n}\n</code></pre>\n<p>위의 코드는 베라 세리프(<code>Vera Serif</code>)라는 폰트를 불러온다. 이 코드가 실행되려면 아래와 같은 과정을 거친다.</p>\n<ol>\n<li>먼저 css를 다운로드 받는다</li>\n<li>css를 파싱한다</li>\n<li>font-face에서 src를 발견하면 해당 url에서 리소스를 다운로드 받는다</li>\n</ol>\n<p>위와 같은 과정은 크게 <code>css다운로드 이후 -> 폰트 다운로드</code>라는 두 단계로 나뉜다. 하지만 웹폰트를 적용할 때 얼마나 빨리 웹폰트가 웹페이지에 적용되는지는 중요한 문제다. 그러므로 이러한 과정을 더 빠르게 단축시키고 싶다. 가령 css와 폰트파일을 동시에 다운로드 받은 뒤에 css파일에서 다운로드 받은 폰트파일을 바로 적용시키면 <code>css다운로드 이후 -> 폰트 다운로드</code> 라는 2개의 스탭을 거치지 않아도 되지 않은가. 그렇다. 이게 프리로드의 존재목적이다. 프리로드를 사용하면 css와 폰트파일을 동시에 다운로드 받을 수 있다. 가령 아래와 같다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;!-- high 우선순위로 지정됨 -->\r\n&lt;link\r\n  rel=\"preload\"\r\n  href=\"https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\"\r\n  as=\"font\"\r\n  type=\"font/woff2\"\r\n  crossorigin=\"anonymous\"\r\n/>\r\n\r\n&lt;!-- highest 우선순위로 지정됨 -->\r\n&lt;link rel=\"stylesheet\" href=\"/style.css\" />\n</code></pre>\n<p>위의 코드는 다운받을 파일이 2개 뿐이므로 이들 두개는 동시에 다운로드가 진행된다. 그 결과 웹사이트 상에 폰트의 적용이 더욱 빨라질 수 있다.\r\n이와 같은 웹 폰트는 하나의 예시일 뿐이며 css내에서 이미지를 다운받거나 비디오를 다운로드 받는 상황에도 똑같이 적용할 수 있다</p>\n<p>그리고 <code>프리로드</code> 사용시에 주의할 점은 <code>프리로드로 다운받는 것 만으로는 해당 리소스를 직접적으로 사용하지 않는다</code>는 점이다. 이 프리로드된 파일은 css등의 다른 리소스에서 추가적으로 호출되어야 한다. 만일 해당 자원을 호출하지 않으면 웹브라우저에서 경고 메시지를 보낸다. 크롬의 개발자 도구를 열면 이렇게 프리로드로 호출하고 나서 사용되지 않는 리소스에 대한 경고창을 확인할 수 있다</p>\n<p><img src=\"/assets/blog/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload/preload_error.png\" alt=\"NOSTATE PREFETCH 스크린샷\"></p>\n<p>위의 내용을 해석하면 <code>리소스가 프리로드 되었지만 몇초이내에 windows의 로드 이벤트에서 사용되지 않았다. 아마도 as값을 잘못 기입한거 같으니까 as 값이 적절한지 확인해. 그게 아니라면 이게 당신이 의도해서 프리로드한 리소스가 맞는가? 한번 확인해봐라</code><br>\n이런 경고창은 두가지 의미에서 이롭다. 첫째로 내가 작성한 코드가 의도한대로 동작하지 않았다는 것을 알려준다. 즉 웹브라우저가 디버거 역할을 한 것이다.<br>\n둘째로는 리소스가 프리로드 되고 사용되지 않음으로서 다른 리소스의 다운로드 우선순위가 밀려날 수 있으므로 퍼포먼스 최적화에 악영향을 주니 만일 당신이 사용하지 않는 파일은 프리로드를 걷어내라는 최적화 지침을 내려준다. 이런 지침을 참고하여 개발하면 크롬의 개발자 도구를 훌륭한 디버깅 툴로 이용할 수 있다</p>\n<h4 id=\"또-다른-전략--프리커넥트-preconnect\">또 다른 전략 : 프리커넥트 (preconnect)</h4>\n<p>프리커넥트를 직역하면 서버와 <code>미리 연결</code>해 놓는다는 뜻이다. 서버와 연결이라는 과정이 생소할 수 있는데 간단히 말하면 필요한 데이터를 받기 위한 선행과정이다. 자원을 서버에 요청할 때 요청한다고 바로 받아지는건 아니고 <code>연결</code>이라는 과정이 필요하다</p>\n<p>이건 미리 서버와 <code>미리 연결을 완료해 놓고</code> 필요하면 TCP 핸드쉐이킹 같은 연결과정을 생략한 채 바로 다운받을 수 있도록 준비해 놓겠다는 뜻이다</p>\n<p>프리커넥트는 프리로드와는 다르다. 프리로드는 특정한 자원을 다운로드 한다. 그러나 프리로드는 특정한 자원을 다운로드 하지 않는다. 그저 서버와 미리 연결을 해놓을 뿐이다.</p>\n<p>의아하지 않은가. 왜 바로 다운로드를 받지 않고 <code>연결만</code> 해 놓을까? 그건 어떤 데이터를 받아올지 아직 결정되지 않은 상황이기 때문이다. 유저가 요청할 리소스의 URL이 상황에 따라서 변경되는 상황이 있다. 프리커넥트는 그런 상황에 쓴다</p>\n<p>예를 들어보자. 구직자인 당신은 원서지원 사이트인 <code>원서지원.com</code>에 접속했다. 어떤 기업에 원서를 지원하려 하는데 삼성에 지원할 수도 있고 엘지에 지원할 수도 있다. 만일 삼성에 지원한다면 <code>양식모음.com/form/samsung</code>에서 제공하는 지원양식을 다운받아야 한다. 그리고 엘지에 지원한다면 <code>양식모음.com/form/lg</code> 라는 URL에서 지원양식을 다운받아야 한다. 자 이런 상황은 지원자가 구체적으로 어떤 회사에 지원할지 예측할 수 없다. 이 때 프리커넥트를 사용하지 않았다고 가정해 보자. 만일 삼성 지원자가 <code>양식 다운받기</code> 버튼을 클릭해서 <code>양식모음.com/form/samsung</code>에 접속한다. 이 때 다음과 같은 프로세스가 진행된다</p>\n<ol>\n<li><code>양식모음.com</code>에 대응하는 DNS를 룩업한다</li>\n<li>룩업한 dns를 기반으로 TCP 3웨이 핸드쉐이킹을 수행한다</li>\n<li>tcp 커넥션이 완료되면 보안을 위해 TLS 핸드쉐이킹을 수행한다</li>\n<li>요청한 url에서 데이터를 다운로드 받는다</li>\n</ol>\n<p>이런 과정으로 진행된다. 즉 마지막에 데이터를 다운로드 받기 전까지 3가지 선행과정을 필요로 한다\r\n그런데 위의 3가지 과정은 단지 서버와 연결하는 과정이다. 즉 구체적인 URL을 몰라도 서버 주소만 안다면 연결할 수 있다. 즉 위의 예에서는 <code>양식모음.com</code>에 접속하는 것만으로도 연결을 구축할 수 있다. 자 만일 이러한 요청을 먼저 구축한 상태에서 삼성 지원자가 <code>양식 다운받기</code> 버튼을 클릭하면 어떤 프로세스가 진행될까?</p>\n<ol>\n<li>요청한 url에서 데이터를 다운로드 받는다</li>\n</ol>\n<p>이게 전부다. 즉 연결에 필요한 모든 과정이 생략된다. 이것은 빠르며 빠른 반응은 유저에게 만족감을 준다<br>\n결론을 말하자면 유저가 요청할 엔드포인트가 분명하지는 않지만 서버 주소는 확실한 경우 프리커넥트를 사용하여 속도상의 이득을 볼 수 있다. 이렇게 미리 서버와 <code>연결</code>해 놓으면 유저가 필요한 데이터를 요청할 때 즉각적인 응답을 보장할 수 있다. 프리커넥트는 이러한 상황에 쓰인다</p>\n<p>그리고 여담이지만 <code>web.dev</code>는 프리커넥트를 이렇게 광고하고 있다\r\n<code>chrome.com 은 중요한 출처에 사전 연결하여 Time To Interactive 를 거의 1초 개선했습니다</code><br>\n1초라. 웹에서 1초는 큰 시간이다. 위의 말이 맞다면 프리커넥트를 사용할 가치는 충분하다</p>\n<h4 id=\"dns-프리패치-dns-prefetch\">DNS 프리패치 (dns-prefetch)</h4>\n<p>DNS 프리패치는 프리커넥트와 비슷하다. 하지만 프리커넥트의 열화 버전이라고 생각하면 좋다.\r\n프리커넥트가 <code>dns 룩업 -> TCP 핸드쉐이킹 -> TLS 핸드쉐이킹</code> 이라는 3단계를 거치는 반면 dns 프리패치는 <code>dns 룩업</code> 의 1단계만을 수행한다. 즉 DNS 프리패치를 수행하고 나서 추가로 TCP핸드쉐이킹과 TLS핸드쉐이킹을 별도로 수행해야 하므로 리소스를 받아오는 시간이 프리커넥트 보다는 느리다.<br>\n<br>\n그러면 이렇게 느린 dns 프리패치를 왜 쓰는가? 클라이언트 입장에서만 보면 dns-프리패치를 사용할 이유는 없어보인다. 하지만 서버의 관점에서 생각해보라. 프리커넥트는 TCP 핸드쉐이킹과 TLS 핸드쉐이킹을 추가로 수행한다. 이런 핸드쉐이킹을 수행하는 과정에서 서버의 CPU와 램 등의 자원이 소비된다. 이것이 서버의 자원낭비로 이어질 수도 있다. 이해가 어려울 텐데 예를 들어보자.<br>\n<br>\n어떤 리소스를 빠르게 다운로드 받으려고 프리커넥트를 걸었다고 가정해 보자. 그런데 이 리소스는 그렇게 빠르게 다운로드 받을 필요는 없는 자원이다. 그런 상황에서 동접자가 10만인 사이트라면 10만개의 커넥션이 생성된다. 이것이 서버에 과부하를 주어서 먼저 급하게 수행되어야 할 프로세스에 악영향을 줄 수도 있다.<br>\n실제로 아마존닷컴은 프리커넥트 대신 dns 프리패치 전략을 구사한다. 위에서 언급했듯이 서버의 과부하를 막기 위함이다. 아래 코드는 <code>amazon.com</code>에 접속하여 개발자 도구로 확인할 수 있다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;link rel=\"dns-prefetch\" href=\"https://images-na.ssl-images-amazon.com\" />\r\n&lt;link rel=\"dns-prefetch\" href=\"https://m.media-amazon.com\" />\r\n&lt;link rel=\"dns-prefetch\" href=\"https://completion.amazon.com\" />\n</code></pre>\n<p>위의 코드에서 세번째 라인을 주목하자. <code>completion.amazon.com</code>은 검색어 자동완성에 쓰이는 URL이다. 아마존 메인페이지에서 검색어를 입력하면 해당 URL에 리퀘스트를 날려서 예상되는 자동완성 문자열을 받아온다.<br>\n자 그런데 이런 자동완성 기능이 반드시 쓰이는 기능인가? 그렇지 않다. 사람들이 아마존에 검색해서 꼭 상품을 검색하리라는 보장은 없다. 마이 페이지에 들어가서 재구매를 할 수도 있는것이고 오늘의 핫딜 페이지를 서핑할 수도 있는것이고 브라우징 히스토리를 열람해서 내가 이전에 둘러봤던 상품 페이지로 이동할 수도 있다. 즉 아마존에 접속한 모든 사람들이 검색어 입력을 하는 것은 아니다.<br>\n이런 상황에서 모든 유저들이 <code>completion.amazon.com</code>에 프리커넥트를 요청한다면 어떻게 될까? 해당 사이트는 수백만건의 TCP핸드쉐이크와 TLS핸드쉐이크를 하느라 자원을 소비할 것이고 먼저 급하게 처리되어야 할 리퀘스트 요청이 지연될 수 있다. 실제로 상품을 검색하는 유저가 이런 지연을 겪는다면 그것은 불쾌한 경험이다. 이처럼 모든 유저가 URL을 요청할 거라는 보장이 없는 상황에서는 무분별한 프리커넥트의 사용이 서버 퍼포먼스의 저하를 야기할 수 있다.<br>\n즉 DNS 프리패치는 아래와 같은 상황에서 사용할 수 있다</p>\n<ol>\n<li>과중하게 트래픽이 몰리는 서버</li>\n<li>클라이언트가 서버에 요청을 할지 말지가 분명하지 않은 상황</li>\n</ol>\n<p>만일 서버의 CPU나 램 등의 자원이 너무 풍부해서 연결 요청이 얼마가 되든지 퍼포먼스의 하락이 걱정되지 않는 상황이라면 DNS 프리패치를 사용할 이유는 없다. 이런 상황에서는 프리커넥트가 권장된다</p>\n<h4 id=\"프리패치-prefetch\">프리패치 (prefetch)</h4>\n<p>프리패치는 <code>미리 다운로드</code>한다는 뜻이다. html파일, 스크립트 파일, css 등의 파일을 미리 다운로드 해놓는다.\r\n문제는 <code>미리 다운로드</code>같은 적당한 용어가 사람들을 헷갈리게 한다. <code>미리 다운로드</code>한다는 말이 무슨뜻인가?<br>\n<br>\n결론만 말하면 <code>다음 페이지에서 사용할 리소스</code>를 미리 다운로드 한다는 뜻이다.\r\n미리 다운로드 받은 자원은 다음 페이지에서 자원을 요청할 때 캐쉬로 사용할 수 있다.\r\n예를 들어 다음 페이지에 <code>&lt;link rel=\"stylesheet\" ></code>처럼 css 파일을 요청하는 코드가 있을 때, 지금 페이지에서 미리 css 파일을 다운로드 받아놓는다. 그리고 그 다운받은 파일을 메모리 어딘가에 저장해놓는다. 그러면 다음 페이지로 이동했을 때 굳이 서버에서 css를 가져올 필요 없이 메모리에 저장해놓은 캐쉬를 가져와서 사용하면 된다. 이게 프리패치다</p>\n<p>자 그러면 한번 생각해보자. 다음 페이지에서 사용할 데이터를 가져오는 작업의 우선순위가 높아야하는가?\r\n아니다. 낮아도 된다. 왜냐하면 다음페이지로 넘어가기 전 까지만 다운로드 받으면 되기 때문이다. 당장 급하게 사용할 자원이 아니라는 뜻이다. 더군다나 프리패치의 우선순위가 높아서 더 먼저 처리해야 하는 리소스의 순위가 밀려나면 현재 페이지의 렌더링이 느려진다. 이것은 사용자에게 불쾌한 경험이다. 따라서 프리패치의 우선순위가 <code>최저(lowest)</code>인 것은 납득할만한 일이다<br>\n<br>\n그런데 몇가지 궁금증이 생길 수 있다.</p>\n<blockquote>\n<p>잠깐만, 유저가 다음 페이지로 넘어갈지 안넘어갈지 어떻게 알지? 그 페이지만 보고 그냥 접속을 꺼버릴 수도 있는 거잖아?<br>\n그리고, 다음 페이지로 연결된 링크가 한개가 아니고 수십개인 상황에서는 어떤 페이지로 넘어갈 지 예측할수도 없는데 이런 상황에서는 프리패치를 어떻게 하지?</p>\n</blockquote>\n<p>자 결론부터 말하면 이건 <code>확률게임</code>이다. 유저가 다음페이지로 넘어갈지 여기서 접속을 종료할지는 알 수 없다. 독심술사도 아니고 그런걸 알 방법은 없다. 그러므로 그저 높은 확률을 찍을 뿐이다. 만일 통계상 유저가 다음 페이지로 넘어갈 확률이 <code>95%</code> 정도라면 프리패치를 할 가치는 충분하다. 나머지 5%의 유저가 페이지를 이탈하여 그저 트래픽 낭비로 이어질지라도 <code>95%</code> 유저의 쾌적환 UX경험이 이를 상쇄한다.<br>\n그러면 당신은 반문할 것이다.</p>\n<blockquote>\n<p>유저가 다음 페이지로 넘어갈 확률이 몇퍼센트 이상일 때 프리패치를 하는것이 좋지? 70%이상인가? 60% 이상인가?</p>\n</blockquote>\n<p>이것은 정답이 없으며 제공하는 서비스의 종류에 따라 달라진다. 만일 다음 페이지의 로딩이 느려도 상관없다면 프리패치를 전혀 하지 않아도 된다. 그런 페이지가 있냐고? 있다. 환불 페이지나 구독 취소 페이지 같은 페이지들은 기업 입장에서 페이지 로딩이 빨라야 할 이유가 없다<br>\n반면 다음 페이지의 로딩속도가 기업의 이윤과 직결되는 중요한 페이지라서 0.01초라도 빨리 수행되어야 하는 서비스라면? 이런 경우는 유저가 다음 페이지로 넘어갈 확률이 50% 미만인 경우라도 무조건 프리패치를 하는 것이 기업의 이윤에 도움이 될 것이다</p>\n<p>문제는 다음 페이지로 이동하는 링크가 여러개인 경우인데 이것도 <code>확률게임</code>이다. 사이트 관리자는 특정 유저가 어느 페이지로 이동할 가능성이 높은지 확률 모델을 구축할 수 있다. 이 확률에 근거하여 가장 방문 가능성이 높은 페이지의 리소스를 미리 프리로딩하는 전략이 가장 보편적이다.<br>\n물론 이런 방법이 정답은 아니다. 만일 유저가 가장 방문 가능성이 높은 페이지가 아니라 2번째로 방문 가능성이 높은 페이지를 방문한다면 프리패치의 덕을 볼 수 없다. 그러므로 방문 확률이 높은 1, 2, 3번째 페이지의 리소스를 통째로 프리패치하는 전략도 생각해볼만 한것이다.<br>\n<br>\n여기서 한가지 의문이 들 것이다. 방문 가능성이 높은 페이지를 구체적으로 어떻게 알아내지. 어떤 알고리즘을 써야하나? 누가 미리 만들어놓은 라이브러리가 있지 않을까?<br>\n그렇다. <code>guess.js</code> 는 확률에 기반하여 방문페이지를 예측하는 라이브러리다. 상세 주소는 <code>https://github.com/guess-js/guess</code>이니 관심이 있으면 참조해 보는것이 좋겠다<br>\n<br>\n그 외의 대중적인 전략은 호버링 전략이다. 유저가 특정 링크에 마우스를 올려놓는 행위를 호버링이라고 하는데 이렇게 호버링을 하는 상황을 이벤트리스너로 탐지하여 프리패치를 수행하는 전략이다. 이것은 <code>next.js</code>에서 수행하는 기법인데 만일 모든 페이지의 링크가 버튼으로만 이루어져 있는 사이트라면 백퍼센트에 육박하는 히트 레이트를 보여준다. 다만 유저가 링크에 마우스를 올려놓고 클릭하는 행위가 매우 찰나에 이루어진다면 그 짦은 시간동안 프리패치가 온전히 수행되지 않을수도 있다. 즉 모든 리소스를 미리 로딩해 놓고 페이지가 이동되자 마자 바로 짠하고 보여주기는 어려울 수도 있다. 이처럼 프리패치 전략에는 모두 장단점이 있어서 어느 하나를 고집하기는 어려운 것이다</p>\n<h4 id=\"프리랜더-prerender\">프리랜더 (prerender)</h4>\n<p>프리랜더는 말 그대로 미리 랜더링 한다는 뜻이다. 대략적인 문법은 <code>&lt;link rel=\"prerender\" href=\"/이동할_페이지의_URL\"></code> 처럼 사용한다.<br>\n프리랜더는 프리패치와 같은 컨셉이다. 다음 페이지에 사용할 리소스를 미리 다운로드 받아서 캐쉬로 사용하겠다는 전략이다. 하지만 프리패치에서 한단계 진화된 버전인데 받아온 리소스를 먼저 <code>렌더링</code>한다<br>\n이 렌더링이라는 작업을 오해하기 쉬운데 프리랜더 전략으로 리소스를 가져온다고 하더라도 웹브라우저 상에서는 가시적인 아무런 변화가 없다. 그래서 <code>뭐가 렌더링이 됐다는 건가?</code>하고 의아해 할 수 있다. 정상적인 반응이다. 이 렌더링 작업은 백그라운드에서 진행되기 때문에 눈에 보이지 않는다. 백그라운드에서 새로운 탭을 생성하여 그 탭에서 html을 파싱하여 돔트리를 만들고 렌더 트리를 만들고 필요하다면 자바스크립트까지 실행한다. 이렇게 미리 다음 페이지를 렌더링 한 상황에서 유저가 다음 페이지로 이동하는 버튼을 클릭하면 어떤 일이 벌어질까? 이미 렌더링 되어있는 렌더 트리를 모니터상에 페인팅하면 될 뿐이다.<br>\n즉 일반적인 페이지 이동에 비해서 웹브라우저에서 처리해야 하는 프로세스가 줄어든다. 일반적인 페이지 이동시에 웹브라우저는 아래와 같은 프로세스를 거친다</p>\n<ol>\n<li>유저가 다음페이지로 이동 버튼을 클릭한다</li>\n<li>다음페이지의 URL에서 html 파일을 다운로드받는다</li>\n<li>html을 파싱한다</li>\n<li>파싱한 html을 해석하여 dom 트리와 cssom 트리를 생성한다</li>\n<li>dom트리와 cssom 트리를 합병하여 렌더트리를 생성한다</li>\n<li>렌더트리와 웹브라우저의 창크기를 기반으로 픽셀을 생성한다</li>\n<li>여러 레이어로 분리된 픽셀을 합병하여 화면상에 드러나는 부분만 비트맵을 생성한다</li>\n<li>비트맵 정보를 OS 커널을 통하여 GPU 하드웨어에 전송한다</li>\n<li>GPU에서 모니터로 픽셀 정보를 전송한다</li>\n<li>모니터가 픽셀을 뿌린다</li>\n</ol>\n<p>이것이 웹페이지 이동시에 일어나는 일반적인 과정이라면 이미 프리랜더링 되어있는 상태에서는 위의 2-5 스탭이 스킵된다. 즉 아래와 같다</p>\n<ol>\n<li>유저가 다음페이지로 이동 버튼을 클릭한다</li>\n<li>이미 생성된 렌더트리와 웹브라우저의 창크기를 기반으로 픽셀을 생성한다</li>\n<li>여러 레이어로 분리된 픽셀을 합병하여 화면상에 드러나는 부분만 비트맵을 생성한다</li>\n<li>비트맵 정보를 OS 커널을 통하여 GPU 하드웨어에 전송한다</li>\n<li>GPU에서 모니터로 픽셀 정보를 전송한다</li>\n<li>모니터가 픽셀을 뿌린다</li>\n</ol>\n<p>이것이 전부다. 두말할 것 없이 빠르다.<br>\n즉 프리랜더는 다음과 같은 상황에서 수행할 수 있다</p>\n<ol>\n<li>유저가 다음 페이지로 이동할 가능성이 높은 경우</li>\n<li>동시에 다음 페이지의 화면을 빠르게 보여줘야 하는 경우</li>\n</ol>\n<p>이런 프리랜더가 퍼포먼스 면에서는 우수하지만 메모리를 많이 잡아먹는다는 단점이 있다. 크로미움 계열 웹브라우저에서 프리랜더는 약 100~150메가 가량의 메모리를 소비한다. 메모리가 넉넉한 데스크탑 환경이라면 메모리에 의한 디메리트가 크게 신경쓸 수준은 아니다. 하지만 메모리 크기가 적은 모바일 환경에서는 상당히 걸림돌이 될 수 있다.<br>\n그래서 크롬 웹브라우저는 메모리 크기가 일정수준 이하인 디바이스에서 프리랜더를 수행하지 않는다. <code>프리랜드(prerender)</code> 키워드가 있더라도 프리랜더 대신 <code>프리커넥트(preconnect)</code>를 수행한다. 이러한 로우엔드 디바이스의 프리랜더링 문제는 아직까지도 해결되지 않고 있다. 이것은 메모리 크기라는 하드웨어적인 한계이므로 앞으로도 극복 방안이 없을 것으로 보인다.</p>\n<p>구글 크롬팀은 이러한 메모리 문제 때문에 곪머리를 앓고 있던 도중 <code>노 스테이트 프리패치(nostate prefetch)</code>라는 개념을 고안해 냈다.</p>\n<h4 id=\"q-노-스테이트-프리패치nostate-prefetch가-뭔가\">Q. 노 스테이트 프리패치(nostate prefetch)가 뭔가?</h4>\n<p>A. 노스테이트 프리패치는 프리랜더링과 개념적으로는 거의 유사하지만 메모리를 덜 잡아먹는 것을 목표로 설계되었다. 이는 최대 45메가의 메모리를 소비한다.<br>\n그렇다면 <code>노 스테이트 프리패치</code>가 메모리 사이즈가 적은 로우엔드 디바이스에서도 작동할까? 그렇지는 않다. 노 스테이트 프리패치가 작동하기 위한 두가지 조건이 있다</p>\n<ol>\n<li>유저의 장치가 로우엔드 디바이스가 아닐 것</li>\n<li>유저가 LTE나 5G등의 이동통신 네트워크에 접속한 상태가 아닐 것. 이 조건이 붙은 이유는 유저가 원치 않는 데이터 사용을 막기 위함이다. 만일 유저가 원치 않는 상황에서 무분별하게 프리패치를 수행했다가 요금 폭탄이라도 맞으면 누가 책임을 질 것인가. 그러므로 5G등의 환경에서는 노스테이트 프리패치가 작동하지 않는다</li>\n</ol>\n<p>(상세는 <a href=\"https://developers.google.com/web/updates/2018/07/nostate-prefetch\">여기</a>를 참고할 것)</p>\n<h4 id=\"q-노-스테이트-프리패치nostate-prefetch를-어떻게-사용할-수-있는가\">Q. 노 스테이트 프리패치(nostate prefetch)를 어떻게 사용할 수 있는가?</h4>\n<p>A. 아래 스탭을 따라하시오</p>\n<ol>\n<li>크로미움 계열의 웹브라우저에서 URL란에 <code>chrome://flags/</code>를 입력한다</li>\n<li>검색란에 <code>nostate</code>라고 검색한다. 그러면 크롬 버전 95.0.4638.69 기준으로 아래와 같은 항목이 뜬다</li>\n</ol>\n<p><img src=\"/assets/blog/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload/NOSTATE_PREFETCH.png\" alt=\"NOSTATE PREFETCH 스크린샷\"></p>\n<p><code>Enable NoStatePrefetch on Navigation Predictor Isolated Prerenders</code>라는 항목이 보이는데 아래 설명란에 보면 <code>고립된 프리랜더에서 Nostate Prefetch를 활성화한다</code>라고 적혀있다. <code>고립된 프리랜더</code>라는건 프리랜더가 외부와 리소스 공유를 하지 않는다는 의미로 보인다.\r\n이 옵션을 활성화하면 <code>&lt;link rel=\"prerender\"></code> 라고 적혀있는 리소스 요청문을 실행할 때 노스테이트 프리패치 방식으로 작동한다. 즉 전통적인 프리렌더링 대비 메모리 사이즈를 절감할 수 있다</p>\n<p>— 끝</p>"
    },
    "url": "/posts/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/211117_%EC%9B%B9%EC%B5%9C%EC%A0%81%ED%99%94_preload.md")
  }
}, children);

});
</script><astro-root uid="2nKi88"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211112_project_loom"><p class="title">자바진영의 프로젝트 룸(Project Loom)이란 무엇인가?</p></a></header><time>2021.11.12</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2nKi88", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "자바진영의 프로젝트 룸(Project Loom)이란 무엇인가?",
    "description": "JVM기반의 스케줄링 모델",
    "publishDate": "2021.11.12",
    "astro": {
      "headers": [{
        "depth": 2,
        "slug": "프로젝트-룸project-loom이란-무엇인가",
        "text": "프로젝트 룸(Project Loom)이란 무엇인가?"
      }],
      "source": "\r\n## 프로젝트 룸(Project Loom)이란 무엇인가?\r\n\r\n프로젝트 룸 (project loom)은 JVM 가상머신 기반의 스케줄링 메커니즘을 새로 구현하는 프로젝트이다. 얼랭(erlang)과 마찬가지로 동시성 패턴의 최적화를 목표로 한다\\\r\n\\\r\n이는 os의 관리하에 있었던 커널스레드 모델에서 가상머신이 관리하는 경량스레드 모델로의 전환으로 이루어진다.\\\r\n\\\r\n경량스레드라는 용어는 혼란을 줄 수 있는 용어인데 엄밀히 말하면 스레드가 아니기 때문이다. 스레드는 그저 OS가 관리하는 실행 흐름의 단위를 뜻한다. 하나의 어플리케이션에서 여러개의 실행흐름이 동시에 관리되어야 하는 상황이 있다. 네트워크와 통신하거나 유저의 입력을 기다리거나 UI를 새로 렌더링 하는 등 이런 여러개의 실행흐름을 동시에 관리하려는 목적으로 OS레벨에서 관리하는 실행흐름을 스레드 또는 커널스레드라고 한다\\\r\n\\\r\n그러면 경량스레드는 무엇인가 ? 이 또한 실행흐름의 단위이다. 스레드와 개념적으로는 거의 같다. 즉 여러개의 실행흐름이 동시에 관리되어야 하는 상황에서 사용한다. 다만 이러한 실행흐름이 OS단위에서 관리되지 않고 어플리케이션 레벨에서 관리된다. 자바의 예를 들면 JVM이라는 가상머신이 이러한 실행흐름의 관리자가 된다. 이 가상머신은 OS와 비슷한 개념으로 작동하는데 즉 자체 스케줄러를 별도로 가지게 되며 이 스케줄러에서 관리하는 자체의 실행흐름을 생성 및 관리한다.\\\r\n\\\r\n이것은 제네레이터라는 개념을 알고 있다면 이해가 쉽다. 가상머신 내부의 스케줄러가 제네레이터를 하나의 실행흐름 단위로 생성하여 생성, 호출, 중지, 재개하기 등의 작업을 종합적으로 컨트롤한다. 이렇게 하면 마치 OS에서 스레드를 사용하여 동시성을 관리하는 것과 거의 유사한 효과를 준다\\\r\n\\\r\n이러한 경량스레드라는 용어가 OS 스레드와 혼선을 줄 수 있음에도 경량스레드로 불리는 이유는 스레드와 기능적으로 거의 유사하기 때문이다. 이러한 혼선을 피하기 위한 목적으로 화이버(fiber)라는 용어가 고안되었다. 화이버는 경량스레드의 또다른 이름이다. 프로젝트 룸에서 화이버 모델은 컨티뉴에이션이라는 형태로 구현된다.\\\r\n\\\r\n사실 이전에도 자바 진영에서 화이버 모델을 구현하려는 시도는 있었다. 그린 스레드라는 이름으로도 유명한데 이 모델은 커널 스레드와 경량 스레드를 1:N 관계로 맵핑하여 경량 스레드를 스케줄링한다. 대략 아래와 같다\r\n\r\n<!-- ![img](../assets/blog/211112_project_loom/project_loom_1.png) -->\r\n![img](/assets/blog/211112_project_loom/project_loom_1.png)\r\n\r\n이 모델은 각 커널 스레드별로 별도의 스케줄러를 생성하여 경량스레드를 작업단위로 관리한다\\\r\n\\\r\n이 모델은 훌륭하지만 한계가 있다. 커널 스레드 단위로만 스케줄링이 가능하다는 점이다. 전체 가상머신 단위의 잡 스케줄링이 불가능하다. 프로젝트 룸은 이것을 실현하기 위한 프로젝트이다.\\\r\n\\\r\n즉 프로젝트 룸 기반의 경량스레드 모델은 커널 스레드와 경량 스레드를 N:N 관계로 스케줄링한다. 이 스케줄링의 주체는 가상머신이다. 그림으로 표현하면 아래와 같다\r\n\r\n![project_loom_2](/assets/blog/211112_project_loom/project_loom_2.jpg)\r\n\r\n이 모델은 특정한 경량스레드가 실행되어야 할 때 가장 최소의 컨텍스트 스위칭 비용이 발생하는 커널 스레드에게 작업을 위임할 수 있다. 이러한 스레드간의 N:N 모델은 그린스레드의 1:N 모델에 비하여 커널 스레드라는 자원을 훨씬 효율적으로 사용할 수 있다\\\r\n\\\r\n그리고 이 모델은 기존의 그린스레드가 가졌던 메모리 절감 효과도 그대로 가져온다. 하나의 루틴을 새로 생성한다고 가정해 보자. 이 때 고전적인 스레드 기반의 루틴을 새로 생성한다면 이들 스레드는 OS가 제공하는 커널 스레드이고 이 커널 스레드는 상당한 메모리 공간을 차지한다. 일단 이것은 메모리 효율성 측면에서 좋지않다.\\\r\n\\\r\n반면 화이버 기반에서는 OS가 아닌 가상머신이 경량스레드를 생성하는데 이 경량스레드는 커널스레드 대비 메타데이터 크기가 약 1/7에서 1/10 수준에 그친다. 아래는 프로젝트 룸의 테크니컬 리드가 말하는 커널스레드와 가상 스레드의 비교 데이터이다.\r\n\r\n<!-- assets\\blog\\211112_project_loom -->\r\n![img](/assets/blog/211112_project_loom/project_loom_3_mod.jpg)\r\n\r\n\r\n그림의 상단은 스레드가 차지하는 메타데이터 크기를 비교해놓았다. 이와는 별개로 그림 하단에는 컨텍스트 스위칭 시간을 비교해놓았다.\\\r\n\\\r\n컨텍스트 스위칭이란 활성 스레드가 기존의 작업을 중단하고 유휴 스레드에게 자원을 할당하여 새로운 작업을 시작하는 프로세스를 일컫는데 고전적인 모델에서는 이 컨텍스트 스위칭이 OS레벨에서 발생했다. 즉 컨텍스트 스위칭이 커널스레드 간에 스위칭하는 방식으로 구현되어 있다. 그런데 앞서 살펴봤듯이 커널스레드는 약 200kb 가량의 메타데이터를 가지며 추가로 1메가 가량의 스택 크기도 할당받는다. 이 메타데이터를 스위칭하고 새로운 작업을 준비하는 과정에서 약 1-10마이크로세컨드가 소모된다.\\\r\n\\\r\n이 시간이 사소해 보일지 모르겠지만 작업이 빈번하게 여러번 전환되는 상황에서는 어느정도 처리속도의 지연이 있다.\r\n반면 가상머신 기반의 컨텍스트 스위칭은 커널스레드에 기반하지 않는다. 이는 가상머신의 경량스레드에 기반하며 따라서 스케줄링되는 작업의 단위는 경량스레드, 즉 화이버이다. 화이버 단위의 컨텍스트 스위칭이 가능한 이유는 OS가 수행했던 스케줄링 작업을 가상머신이 대신 수행하기 때문이다\\\r\n\\\r\n당연하지만 컨텍스트 스위칭에 소모되는 시간은 스레드가 가진 메타데이터의 크기에 비례한다. 그런 관계로 훨씬 적은 메타데이터를 가진 경량스레드는 기존 컨텍스트 스위칭 대비 약 5~50배 빠른 전환 속도를 보여준다. 기존의 동시성 패턴대비 더나은 퍼포먼스와 더 적은 메모리 소모를 경험할 수 있다\\\r\n\\\r\n스케줄링의 권한이 OS가 아닌 응용프로그램에 위임될 때는 또다른 장점이 있다. 이것을 코틀린과 비교하여 설명해 보자. 코틀린의 컨티뉴에이션 루틴은 작업이 오래 지속될 시에 개발자가 원하는 타이밍에 작업을 취소되거나 작업순위을 뒤로 미룰 수 없다. 만일 특정한 작업이 자원을 선점하고 있어서 다른 화이버가 자원을 사용할 수 없는 기아상태가 지속된다면 그것이 OS 스케줄러 수준에서 관리된다.\\\r\n\\\r\n즉 OS스케줄러가 작업을 중단시키거나 작업순위를 뒤로 미루게 된다. 이것은 두가지 문제가 있다. 첫째로 얼마나 시간이 흐른 뒤에 작업을 중단시킬지 응용프로그램 수준에서 관리할 수 없다. 즉 스케줄링이 실행중인 OS에 전적으로 의존해야 하므로 당신이 OS커널 내부의 스케줄러를 수정하지 않는 이상은 실행흐름 관련 커스터마이징이 불가능하다. 리눅스 커널의 스케줄러를 개조하여 사용하는 경우가 있기는 하지만 이것은 상당한 전문지식과 수고로움을 필요로 한다. 두번째 문제는 내가 작업을 도중에 중단하고 싶지 않은 경우에도 OS스케줄러에 의해 강제적으로 재스케줄링이 될 수도 있다는 점이다. 종합하면 내가 원하는 스케줄링 정책을 적용할 수가 없다.\\\r\n\\\r\n그러나 가상머신 기반의 컨티뉴에이션 루틴은 스케줄링 정책을 개발자가 직접 설정할 수 있다. 만일 더 지연된 시간에 작업을 리스케줄링 하고 싶다면 그렇게 할 수 있고 중도에 리스케줄링을 원하지 않는다면 그렇게 할 수도 있다. 이것은 실행흐름을 실행할 때 `데드라인`을 설정하여 가능해진다. 가령 `withDeadline(30초)`라고 설정하여 실행흐름을 시작한다면 이 실행흐름의 최대 실행시간은 30초로 제한된다. 즉 응용프로그램 레벨에서 미세한 스케줄링 정책을 컨트롤할 수 있게 되었다\\\r\n\\\r\n그 외에 롬은 기존의 비동기함수 처리방식을 훨씬 간단하게 만든다. 이것을 설명하기 앞서 전염성이라는 개념을 이해할 필요가 있다.\\\r\n\\\r\n예를들어 어떤 메소드가 퓨처(Future)를 반환하면 이를 호출한 다른 메소드도 퓨처를 반환해야 하는데 이러한 방식은 퓨처가 포함된 콜스택을 통틀어 비동기 패러다임을 강제하는 문제를 야기한다.\r\n이것을 `함수의 색 문제`라고 하는데 동기 함수와 비동기 함수 사이에 거대한 벽이 있어 상호 연동이 쉽지 않은 문제를 말한다. 실제로 개발 시 동기 함수를 작성하고 있는 건지 비동기 함수를 작성하고 있는 건지 계속해서 의식하게 해야 하는 불편함이 발생한다.\\\r\n\\\r\n함수의 색 문제를 자세히 알고 싶다면 밥 니스트롬(Bob Nystrom)의 [당신 함수의 색은 무엇입니까?](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)(What Color is Your Function?) 문서를 참고해 보자.\\\r\n\\\r\n프로젝트 룸의 테크니컬 리드인 론 프레슬러는 이런 전염성이 기존 스레드 모델의 가장 큰 문제라고 말한다.\r\n만일 가상머신 기반의 경량스레드 모델을 사용한다면 이런 함수의 색 문제로부터 자유롭다. 즉 함수를 작성할 때 이전에 호출했던 함수가 동기인지 비동기인지를 체크할 필요가 없어진다. 그저 비동기 처리용 컨티뉴에이션을 생성하고 그즉시 yield를 수행하여 작업을 잠정 중단한 뒤에 비동기 처리용 컨티뉴에이션에서 비동기 작업이 종료되면 이전에 작업하던 컨티뉴에이션을 다시 호출하여 작업을 재개하면 되기 떄문이다. 따라서 프로젝트 룸이 프로덕션 레벨에 적용된다면 비동기 처리관련 코딩 스타일이 급변하게 되는것은 필연이다. 그리고 이것은 개발자를 더욱 편하게 만들어줄 것이다\\\r\n\\\r\n그 외에 프로젝트 룸은 꼬리재귀 최적화를 지원한다. 따라서 재귀함수가 꼬리재귀 기반으로 구현되었다면 더 빠른 처리 속도와 적은 메모리 사용이라는 이익을 볼 수 있다. 이로서 퍼포먼스의 눈치를 보지 않고도 꼬리재귀를 구현할 수 있는 환경이 마련되었다\r\n\r\n---\r\n\r\n참고자료\r\n\r\n론 프레슬러의 프로젝트 룸 소개 동영상 (론 프레슬러는 프로젝트 룸의 테크니컬 리드이다)\\\r\nhttps://www.youtube.com/watch?v=fOEPEXTpbJA\r\n\r\n자바 공식 문서 (Project Loom: JVM을 위한 화이버와 컨티뉴에이션)\\\r\nhttps://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html\r\n",
      "html": "<h2 id=\"프로젝트-룸project-loom이란-무엇인가\">프로젝트 룸(Project Loom)이란 무엇인가?</h2>\n<p>프로젝트 룸 (project loom)은 JVM 가상머신 기반의 스케줄링 메커니즘을 새로 구현하는 프로젝트이다. 얼랭(erlang)과 마찬가지로 동시성 패턴의 최적화를 목표로 한다<br>\n<br>\n이는 os의 관리하에 있었던 커널스레드 모델에서 가상머신이 관리하는 경량스레드 모델로의 전환으로 이루어진다.<br>\n<br>\n경량스레드라는 용어는 혼란을 줄 수 있는 용어인데 엄밀히 말하면 스레드가 아니기 때문이다. 스레드는 그저 OS가 관리하는 실행 흐름의 단위를 뜻한다. 하나의 어플리케이션에서 여러개의 실행흐름이 동시에 관리되어야 하는 상황이 있다. 네트워크와 통신하거나 유저의 입력을 기다리거나 UI를 새로 렌더링 하는 등 이런 여러개의 실행흐름을 동시에 관리하려는 목적으로 OS레벨에서 관리하는 실행흐름을 스레드 또는 커널스레드라고 한다<br>\n<br>\n그러면 경량스레드는 무엇인가 ? 이 또한 실행흐름의 단위이다. 스레드와 개념적으로는 거의 같다. 즉 여러개의 실행흐름이 동시에 관리되어야 하는 상황에서 사용한다. 다만 이러한 실행흐름이 OS단위에서 관리되지 않고 어플리케이션 레벨에서 관리된다. 자바의 예를 들면 JVM이라는 가상머신이 이러한 실행흐름의 관리자가 된다. 이 가상머신은 OS와 비슷한 개념으로 작동하는데 즉 자체 스케줄러를 별도로 가지게 되며 이 스케줄러에서 관리하는 자체의 실행흐름을 생성 및 관리한다.<br>\n<br>\n이것은 제네레이터라는 개념을 알고 있다면 이해가 쉽다. 가상머신 내부의 스케줄러가 제네레이터를 하나의 실행흐름 단위로 생성하여 생성, 호출, 중지, 재개하기 등의 작업을 종합적으로 컨트롤한다. 이렇게 하면 마치 OS에서 스레드를 사용하여 동시성을 관리하는 것과 거의 유사한 효과를 준다<br>\n<br>\n이러한 경량스레드라는 용어가 OS 스레드와 혼선을 줄 수 있음에도 경량스레드로 불리는 이유는 스레드와 기능적으로 거의 유사하기 때문이다. 이러한 혼선을 피하기 위한 목적으로 화이버(fiber)라는 용어가 고안되었다. 화이버는 경량스레드의 또다른 이름이다. 프로젝트 룸에서 화이버 모델은 컨티뉴에이션이라는 형태로 구현된다.<br>\n<br>\n사실 이전에도 자바 진영에서 화이버 모델을 구현하려는 시도는 있었다. 그린 스레드라는 이름으로도 유명한데 이 모델은 커널 스레드와 경량 스레드를 1:N 관계로 맵핑하여 경량 스레드를 스케줄링한다. 대략 아래와 같다</p>\n<!-- ![img](../assets/blog/211112_project_loom/project_loom_1.png) -->\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_1.png\" alt=\"img\"></p>\n<p>이 모델은 각 커널 스레드별로 별도의 스케줄러를 생성하여 경량스레드를 작업단위로 관리한다<br>\n<br>\n이 모델은 훌륭하지만 한계가 있다. 커널 스레드 단위로만 스케줄링이 가능하다는 점이다. 전체 가상머신 단위의 잡 스케줄링이 불가능하다. 프로젝트 룸은 이것을 실현하기 위한 프로젝트이다.<br>\n<br>\n즉 프로젝트 룸 기반의 경량스레드 모델은 커널 스레드와 경량 스레드를 N:N 관계로 스케줄링한다. 이 스케줄링의 주체는 가상머신이다. 그림으로 표현하면 아래와 같다</p>\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_2.jpg\" alt=\"project_loom_2\"></p>\n<p>이 모델은 특정한 경량스레드가 실행되어야 할 때 가장 최소의 컨텍스트 스위칭 비용이 발생하는 커널 스레드에게 작업을 위임할 수 있다. 이러한 스레드간의 N:N 모델은 그린스레드의 1:N 모델에 비하여 커널 스레드라는 자원을 훨씬 효율적으로 사용할 수 있다<br>\n<br>\n그리고 이 모델은 기존의 그린스레드가 가졌던 메모리 절감 효과도 그대로 가져온다. 하나의 루틴을 새로 생성한다고 가정해 보자. 이 때 고전적인 스레드 기반의 루틴을 새로 생성한다면 이들 스레드는 OS가 제공하는 커널 스레드이고 이 커널 스레드는 상당한 메모리 공간을 차지한다. 일단 이것은 메모리 효율성 측면에서 좋지않다.<br>\n<br>\n반면 화이버 기반에서는 OS가 아닌 가상머신이 경량스레드를 생성하는데 이 경량스레드는 커널스레드 대비 메타데이터 크기가 약 1/7에서 1/10 수준에 그친다. 아래는 프로젝트 룸의 테크니컬 리드가 말하는 커널스레드와 가상 스레드의 비교 데이터이다.</p>\n<!-- assets\\blog\\211112_project_loom -->\n<p><img src=\"/assets/blog/211112_project_loom/project_loom_3_mod.jpg\" alt=\"img\"></p>\n<p>그림의 상단은 스레드가 차지하는 메타데이터 크기를 비교해놓았다. 이와는 별개로 그림 하단에는 컨텍스트 스위칭 시간을 비교해놓았다.<br>\n<br>\n컨텍스트 스위칭이란 활성 스레드가 기존의 작업을 중단하고 유휴 스레드에게 자원을 할당하여 새로운 작업을 시작하는 프로세스를 일컫는데 고전적인 모델에서는 이 컨텍스트 스위칭이 OS레벨에서 발생했다. 즉 컨텍스트 스위칭이 커널스레드 간에 스위칭하는 방식으로 구현되어 있다. 그런데 앞서 살펴봤듯이 커널스레드는 약 200kb 가량의 메타데이터를 가지며 추가로 1메가 가량의 스택 크기도 할당받는다. 이 메타데이터를 스위칭하고 새로운 작업을 준비하는 과정에서 약 1-10마이크로세컨드가 소모된다.<br>\n<br>\n이 시간이 사소해 보일지 모르겠지만 작업이 빈번하게 여러번 전환되는 상황에서는 어느정도 처리속도의 지연이 있다.\r\n반면 가상머신 기반의 컨텍스트 스위칭은 커널스레드에 기반하지 않는다. 이는 가상머신의 경량스레드에 기반하며 따라서 스케줄링되는 작업의 단위는 경량스레드, 즉 화이버이다. 화이버 단위의 컨텍스트 스위칭이 가능한 이유는 OS가 수행했던 스케줄링 작업을 가상머신이 대신 수행하기 때문이다<br>\n<br>\n당연하지만 컨텍스트 스위칭에 소모되는 시간은 스레드가 가진 메타데이터의 크기에 비례한다. 그런 관계로 훨씬 적은 메타데이터를 가진 경량스레드는 기존 컨텍스트 스위칭 대비 약 5~50배 빠른 전환 속도를 보여준다. 기존의 동시성 패턴대비 더나은 퍼포먼스와 더 적은 메모리 소모를 경험할 수 있다<br>\n<br>\n스케줄링의 권한이 OS가 아닌 응용프로그램에 위임될 때는 또다른 장점이 있다. 이것을 코틀린과 비교하여 설명해 보자. 코틀린의 컨티뉴에이션 루틴은 작업이 오래 지속될 시에 개발자가 원하는 타이밍에 작업을 취소되거나 작업순위을 뒤로 미룰 수 없다. 만일 특정한 작업이 자원을 선점하고 있어서 다른 화이버가 자원을 사용할 수 없는 기아상태가 지속된다면 그것이 OS 스케줄러 수준에서 관리된다.<br>\n<br>\n즉 OS스케줄러가 작업을 중단시키거나 작업순위를 뒤로 미루게 된다. 이것은 두가지 문제가 있다. 첫째로 얼마나 시간이 흐른 뒤에 작업을 중단시킬지 응용프로그램 수준에서 관리할 수 없다. 즉 스케줄링이 실행중인 OS에 전적으로 의존해야 하므로 당신이 OS커널 내부의 스케줄러를 수정하지 않는 이상은 실행흐름 관련 커스터마이징이 불가능하다. 리눅스 커널의 스케줄러를 개조하여 사용하는 경우가 있기는 하지만 이것은 상당한 전문지식과 수고로움을 필요로 한다. 두번째 문제는 내가 작업을 도중에 중단하고 싶지 않은 경우에도 OS스케줄러에 의해 강제적으로 재스케줄링이 될 수도 있다는 점이다. 종합하면 내가 원하는 스케줄링 정책을 적용할 수가 없다.<br>\n<br>\n그러나 가상머신 기반의 컨티뉴에이션 루틴은 스케줄링 정책을 개발자가 직접 설정할 수 있다. 만일 더 지연된 시간에 작업을 리스케줄링 하고 싶다면 그렇게 할 수 있고 중도에 리스케줄링을 원하지 않는다면 그렇게 할 수도 있다. 이것은 실행흐름을 실행할 때 <code>데드라인</code>을 설정하여 가능해진다. 가령 <code>withDeadline(30초)</code>라고 설정하여 실행흐름을 시작한다면 이 실행흐름의 최대 실행시간은 30초로 제한된다. 즉 응용프로그램 레벨에서 미세한 스케줄링 정책을 컨트롤할 수 있게 되었다<br>\n<br>\n그 외에 롬은 기존의 비동기함수 처리방식을 훨씬 간단하게 만든다. 이것을 설명하기 앞서 전염성이라는 개념을 이해할 필요가 있다.<br>\n<br>\n예를들어 어떤 메소드가 퓨처(Future)를 반환하면 이를 호출한 다른 메소드도 퓨처를 반환해야 하는데 이러한 방식은 퓨처가 포함된 콜스택을 통틀어 비동기 패러다임을 강제하는 문제를 야기한다.\r\n이것을 <code>함수의 색 문제</code>라고 하는데 동기 함수와 비동기 함수 사이에 거대한 벽이 있어 상호 연동이 쉽지 않은 문제를 말한다. 실제로 개발 시 동기 함수를 작성하고 있는 건지 비동기 함수를 작성하고 있는 건지 계속해서 의식하게 해야 하는 불편함이 발생한다.<br>\n<br>\n함수의 색 문제를 자세히 알고 싶다면 밥 니스트롬(Bob Nystrom)의 <a href=\"http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">당신 함수의 색은 무엇입니까?</a>(What Color is Your Function?) 문서를 참고해 보자.<br>\n<br>\n프로젝트 룸의 테크니컬 리드인 론 프레슬러는 이런 전염성이 기존 스레드 모델의 가장 큰 문제라고 말한다.\r\n만일 가상머신 기반의 경량스레드 모델을 사용한다면 이런 함수의 색 문제로부터 자유롭다. 즉 함수를 작성할 때 이전에 호출했던 함수가 동기인지 비동기인지를 체크할 필요가 없어진다. 그저 비동기 처리용 컨티뉴에이션을 생성하고 그즉시 yield를 수행하여 작업을 잠정 중단한 뒤에 비동기 처리용 컨티뉴에이션에서 비동기 작업이 종료되면 이전에 작업하던 컨티뉴에이션을 다시 호출하여 작업을 재개하면 되기 떄문이다. 따라서 프로젝트 룸이 프로덕션 레벨에 적용된다면 비동기 처리관련 코딩 스타일이 급변하게 되는것은 필연이다. 그리고 이것은 개발자를 더욱 편하게 만들어줄 것이다<br>\n<br>\n그 외에 프로젝트 룸은 꼬리재귀 최적화를 지원한다. 따라서 재귀함수가 꼬리재귀 기반으로 구현되었다면 더 빠른 처리 속도와 적은 메모리 사용이라는 이익을 볼 수 있다. 이로서 퍼포먼스의 눈치를 보지 않고도 꼬리재귀를 구현할 수 있는 환경이 마련되었다</p>\n<hr>\n<p>참고자료</p>\n<p>론 프레슬러의 프로젝트 룸 소개 동영상 (론 프레슬러는 프로젝트 룸의 테크니컬 리드이다)<br>\n<a href=\"https://www.youtube.com/watch?v=fOEPEXTpbJA\">https://www.youtube.com/watch?v=fOEPEXTpbJA</a></p>\n<p>자바 공식 문서 (Project Loom: JVM을 위한 화이버와 컨티뉴에이션)<br>\n<a href=\"https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html\">https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html</a></p>"
    },
    "url": "/posts/211112_project_loom",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/211112_project_loom.md")
  }
}, children);

});
</script><astro-root uid="ZfaLWj"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/%EB%AF%B8%EC%99%84%EC%84%B1_css%EA%B4%80%EB%A0%A8"><p class="title">리액트의 css패턴 Q&amp;A 모음</p></a></header><time>2021.11.10</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("ZfaLWj", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "리액트의 css패턴 Q&A 모음",
    "description": "",
    "publishDate": "2021.11.10",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "리액트의-css패턴-qa-모음",
        "text": "리액트의 css패턴 Q&A 모음"
      }, {
        "depth": 4,
        "slug": "q-css-in-js가-무엇인가",
        "text": "Q. css-in-js가 무엇인가?"
      }, {
        "depth": 4,
        "slug": "q-테일윈드-css-tailwind-css란-무엇인가",
        "text": "Q. 테일윈드 css (tailwind css)란 무엇인가?"
      }, {
        "depth": 4,
        "slug": "q-스타일드-컴포넌트styled-components란-무엇인가",
        "text": "Q. 스타일드 컴포넌트(styled-components)란 무엇인가?"
      }, {
        "depth": 4,
        "slug": "q-함수-컴포넌트-내부에서-사용하는-style-jsx--같은-패턴을-뭐라고-부르는가-",
        "text": "Q. 함수 컴포넌트 내부에서 사용하는 <style jsx>{\" \"} 같은 패턴을 뭐라고 부르는가 ?"
      }, {
        "depth": 4,
        "slug": "q-css-module이란-무엇인가-",
        "text": "Q. CSS Module이란 무엇인가 ?"
      }, {
        "depth": 4,
        "slug": "q-css-모듈에-안티-패턴이-있는가",
        "text": "Q. CSS 모듈에 안티 패턴이 있는가?"
      }, {
        "depth": 4,
        "slug": "q-sasssyntactically-awesome-stylesheets-란-무엇인가-",
        "text": "Q. SASS(Syntactically Awesome Stylesheets) 란 무엇인가 ?"
      }, {
        "depth": 1,
        "slug": "sass부분은-작성중입니다",
        "text": "SASS부분은 작성중입니다"
      }, {
        "depth": 1,
        "slug": "sass부분은-작성중입니다",
        "text": "SASS부분은 작성중입니다"
      }],
      "source": "\r\n### 리액트의 css패턴 Q&A 모음\r\n\r\n#### Q. css-in-js가 무엇인가?\r\n\r\ncss파일이 아닌 자바스크립트 파일 내부에서 css 규칙을 정의하는 코딩 스타일을 `css-in-js`라고 부른다.\\\r\n\\\r\n스타일드 컴포넌트같은 라이브러리가 대표적인 css-in-js의 예이다\r\n\r\n#### Q. 테일윈드 css (tailwind css)란 무엇인가?\r\n\r\n테일윈드를 이야기하기 앞서 부트스트랩 라이브러리를 이야기 해보자\\\r\n\\\r\n부트스트랩은 일일이 css 규칙을 정의하지 않아도 html 엘리먼트에 클래스 이름을 기입하는 것만으로 간편하게 사용할 수 있는 라이브러리이다. 이것이 가능한 이유는 부트스트랩 팀에서 미리 css 코드와 클래스 이름을 정의해놓았기 때문이다\\\r\n\\\r\n즉 부트스트랩을 사용하면 남이 만들어놓은 css를 그저 가져다 쓰면 될 뿐이므로 내가 css 규칙을 작성할 일이 거의 없다. 부트스트랩에서 제공하는 클래스 이름만 암기하고 그 암기한 클래스 이름을 원하는 엘리먼트에 붙여넣으면 될 뿐이다\\\r\n\\\r\n그리고 이 부트스트랩의 후계자 정도 되는 라이브러리가 테일윈드 css인데 테일윈드 css도 부트스트랩과 마찬가지로 이미 정의되어 있는 css규칙을 사용한다. 유저는 그저 테일윈드에 정의되어 있는 클래스 이름을 암기하고 그 이름을 가져다가 특정 html 엘리먼트에 적용하기만 하면 된다. 예를 들어 아래와 같다\r\n\r\n```javascript\r\nfunction 컴포넌트(){\r\n    return(\r\n        <div className=\"w-64 h-3 bg-gradient-to-br from-fuchsia-500 to-purple-600\">\r\n            테일윈드를 적용한 div\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n위의 코드는 css 정의부가 없으며 그저 정의된 css를 적용했다. 즉 내가 별도로 css를 작성하는데 소비되는 시간이 줄어든다. 극단적으로 말하면 프로젝트의 모든 스타일링을 테일윈드 만으로도 구현할 수 있다. 그렇게 된다면 내가 별도로 작성해야 하는 css코드의 양을 제로로 줄이는것도 가능하다\\\r\n\\\r\n그리고 이미 정의되어 있는 css를 가져다가 쓰기 때문에 마크업 부분과 css정의부를 이리저리 왔다갔다 할 필요가 없다. 테일윈드를 쓰는 사람들은 `개발 시간이 줄어들었다`는 이야기를 공통적으로 하는데 이처럼 코드를 이리저리 옮겨다닐 필요가 없는 것도 개발시간 단축에 한 몫 한다\\\r\n\\\r\n이렇게만 적어놓으면 테일윈드를 사용하지 않는 것이 바보처럼 느껴지겠지만 꼭 그렇지만도 않다. 테일윈드의 시장점유율이 압도적인 것도 아니다. 왜 그럴까?  일단 암기해야 하는 클래스 이름이 많아 어느정도의 러닝커브가 있다. 테일윈드에 익숙해지기 전까지는 모니터 한켠에 테일윈드의 공식 docs 페이지를 띄어놓고 검색하는 일이 잦다\\\r\n\\\r\n이것보다 더 큰 문제는 코드가 지저분해지는 단점이다. 위의 코드만 보면 별 느낌이 없을 수도 있겠지만 아래의 코드를 보자\r\n\r\n```javascript\r\nfunction 컴포넌트(){\r\n    return (\r\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\">\r\n            <div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\r\n                <p className=\"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\">Entire house</p>\r\n                <h2 className=\"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\">Beach House in Collingwood</h2>\r\n            </div>\r\n            <div className=\"col-start-1 row-start-2 px-4 sm:pb-16\">\r\n                <div className=\"flex items-center text-sm font-medium my-5 sm:mt-2 sm:mb-4\">\r\n                    <svg width=\"20\" height=\"20\" fill=\"currentColor\" className=\"text-violet-600\">\r\n                        <path d=\"M9.05 3.691c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.372 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.539 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.363-1.118l-2.8-2.034c-.784-.57-.381-1.81.587-1.81H7.03a1 1 0 00.95-.69L9.05 3.69z\" />\r\n                    </svg>\r\n                    <div className=\"ml-1\">\r\n                        <span className=\"text-black\">4.94</span>\r\n                        <span className=\"sm:hidden md:inline\">(128)</span>\r\n                    </div>\r\n                    <div className=\"text-base font-normal mx-2\">·</div>\r\n                    <div>Collingwood, Ontario</div>\r\n                </div>\r\n                <hr className=\"w-16 border-gray-300 hidden sm:block\">\r\n            </div>\r\n            <div className=\"col-start-1 row-start-3 space-y-3 px-4\">\r\n                <p className=\"flex items-center text-black text-sm font-medium\">\r\n                    <img src=\"/kevin-francis.jpg\" alt=\"\" className=\"w-6 h-6 rounded-full mr-2 bg-gray-100\">\r\n                    Hosted by Kevin Francis\r\n                </p>\r\n                <button type=\"button\" className=\"bg-violet-100 text-violet-700 text-base font-semibold px-6 py-2 rounded-lg\">Check availability</button>\r\n            </div>\r\n            <div className=\"col-start-1 row-start-1 flex sm:col-start-2 sm:row-span-3\">\r\n                <div className=\"w-full grid grid-cols-3 grid-rows-2 gap-2\">\r\n                    <div className=\"relative col-span-3 row-span-2 md:col-span-2\">\r\n                        <img src=\"/beach-house.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover bg-gray-100 sm:rounded-lg\" />\r\n                    </div>\r\n                    <div className=\"relative hidden md:block\">\r\n                        <img src=\"/beach-house-interior.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover rounded-lg bg-gray-100\" />\r\n                    </div>\r\n                    <div className=\"relative hidden md:block\">\r\n                        <img src=\"/beach-house-view.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover rounded-lg bg-gray-100\" />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n위의 코드는 본인이 만든 코드가 아니다. 테일윈드 공식 사이트에 있는 코드를 가져와서 함수 컴포넌트로 바꾸었을 뿐이다.\\\r\n자 위의 코드는 일단 만들 때는 편하다. 위에서 언급한 대로 마크업과 css부분을 옮겨다닐 필요가 없고 남이 정의해 놓은 규칙을 가져다가 쓰기만 하면 되기 때문이다. 하지만 유지보수 상황을 고려해 보자.\\\r\n\\\r\n먼저 마크업의 구조를 변경하고 싶을 때 전체적인 구조가 한눈에 들어오지 않는다. 이것은 마크업 레이어와 css레이어가 섞여있기 때문이다.\\\r\n애써 클래스네임 부분을 무시하고 구조만 보려고 해도 잘 되지 않는다. 이는 인간의 눈이 무언가를 인지할 때 내가 보고싶은 정보만 취사선택 하기가 어렵기 때문이다. 이처럼 마크업 구조를 이해할 때 인지적인 과부하 문제가 있다\\\r\n\\\r\n두번째로 css를 수정해야 하는 상황을 보자. 이런경우 내가 수정할 엘리먼트의 css가 어디에 정의되어 있는지를 별도로 찾을 필요는 없다. 여기까지는 좋다. 그러나 아래의 코드를 보자\r\n\r\n```html\r\n<div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\r\n```\r\n\r\n위의 코드에서 패딩을 수정하고 싶다. 무엇을 수정해야 하는지 한눈에 들어오는가? 아마 쉽지 않을것이다. 일단 클래스이름이 가로로 적혀있는 관계로 가독성이 떨어진다. 만일 위의 코드를 세로로 바꾸면 아래와 같이 된다\r\n\r\n```html\r\n  <div className=\"\r\n    relative \r\n    z-10 \r\n    col-start-1 \r\n    row-start-1 \r\n    px-4 \r\n    pt-40 \r\n    pb-3 \r\n    bg-gradient-to-t \r\n    from-black \r\n    sm:bg-none\">\r\n```\r\n\r\n이건 좀 낫다. 하지만 실제로는 이런 식으로 코딩할 수 없다. 클래스이름을 세로로 작성하면 너무 길어지고 그렇게되면 마크업 구조를 파악하는 게 거의 불가능에 가까워진다. 따라서 가로로 정의할 수 밖에 없는데 이 때문에 클래스이름이 한눈에 들어오지 않는다.\\\r\n\\\r\nctrl-f로 검색을 해서 원하는 클래스를 찾은다음 수정하는 방법도 있다. 그런데 패딩에 대한 클래스이름이 한두개가 아니라 그것도 어렵다. p-도 패딩이고 px도 패딩, pt, pb, pr등이 모두 패딩이다. 위의 예에서는 `px-4`, `pt-40`, `pb-3`가 모두 패딩이다. 즉 내가 수정하고 싶은 디자인의 클래스이름을 찾는것도 쉽지않다.\\\r\n\\\r\n이전에 특정한 스타일을 지정했는지 지정하지 않았는지 확인하는 것도 쉽지 않다. 예를 들어 내가 폰트사이즈를 바꾸고 싶어서 `text-7xl` 이라는 클래스이름을 추가했다. 그런데 이미 앞에서 `text-2xl`가 선언되어 있었다. 다만 클래스 문자열이 너무 길어서 미처 확인하지 못한것이다. 이렇게 되면 중복으로 같은 속성을 지정하는 문제가 생길수도 있다.\\\r\n따라서 초기 개발은 빠를 수 있지만 유지보수의 속도는 그렇지 않을 수 있다는 결론도 무리는 아닌것으로 보인다\\\r\n\\\r\n이런 문제를 조금이라도 극복할 수 있을까? 먼저 클래스이름을 별도의 문자열로 떼어놓는 방법이 있다. 가령 아래와 같은 코드가 있다고 가정하자\r\n\r\n```javascript\r\nfunction House(){\r\n    return (\r\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\">\r\n            <div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\r\n                <p className=\"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\">Entire house</p>\r\n                <h2 className=\"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\">Beach House in Collingwood</h2>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n위의 코드에서 인라인 문자열을 별도의 변수로 분리하면 아래와 같이 변경된다\r\n\r\n```javascript\r\nfunction House(){\r\n\r\n    const HouseCss = {\r\n        wrapper : \"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\",\r\n        description : \"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\",\r\n        p : \"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\",\r\n        h2 : \"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\",\r\n    }\r\n\r\n    return (\r\n        <div className={HouseCss.wrapper}>\r\n            <div className={HouseCss.description}>\r\n                <p className={HouseCss.p}>Entire house</p>\r\n                <h2 className={HouseCss.h2}>Beach House in Collingwood</h2>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n이렇게 되니 마크업 구조의 이해가 더 수월해졌다. 이것은 공식 사이트에서 제안하는 베스트 프랙티스는 아닌 본인의 생각이니 오해없기 바란다. 왜 이것이 베스트 프랙티스가 아닌지는 모르겠으나 개인적으로는 이게 더 낫다\\\r\n\\\r\n하지만 위의 방법론도 어떤 클래스이름을 지정했는지 한눈에 들어오지 않는 단점이 있다. 이것은 문자열을 합병하는 식으로 코드를 표현하면 조금 나아진다. 가령 아래와 같다\r\n\r\n```javascript\r\nfunction House(){\r\n\r\n    const HouseCss = {\r\n        wrapper : `grid` + ` grid-cols-1` + ` sm:grid-cols-2` + ` sm:px-8` + ` sm:py-12` + ` sm:gap-x-8` + ` md:py-16`,\r\n        description : `relative` + ` z-10` + ` col-start-1` + ` row-start-1` + ` px-4` + ` pt-40` + ` pb-3` + ` bg-gradient-to-t` + ` from-black sm:bg-none`,\r\n        p : `text-sm` + `font-medium` + `text-white` + `sm:mb-1` + `sm:text-gray-500`,\r\n        h2 : `text-xl` +  ` font-semibold`  + ` text-white sm:text-2xl` + ` sm:leading-7` +  ` sm:text-black` +  ` md:text-3xl`,\r\n    }\r\n\r\n    return (\r\n        <div className={HouseCss.wrapper}>\r\n            <div className={HouseCss.description}>\r\n                <p className={HouseCss.p}>Entire house</p>\r\n                <h2 className={HouseCss.h2}>Beach House in Collingwood</h2>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n이렇게 해놓으니 클래스이름이 더 잘 구분된다. 이런 프랙티스는 마크업 레이어와 css레이어가 합쳐짐으로서 얻는 장점을 거의 그대로 가져온다. 즉 마크업 선언부와 css 정의부를 옮겨다닐 일이 거의 없다. 클래스를 인라인에 직접 기입하지 않으므로 옮겨다닐 일이 아주 없는건 아니다. 하지만 리턴문 바로 앞에 클래스이름을 정의하면 코드를 이동할 때 소모되는 인지적 과부하가 상당부분 줄어든다\\\r\n\\\r\n또한 마크업 부분을 그대로 복붙해서 다른 컴포넌트에 가져다가 집어넣어도 그 자체로 완결성을 가진 컴포넌트로 작동할 수 있다. 즉 외부에서 css모듈까지 추가로 복붙해야 하는 번거로움이 없다. 그저 함수 컴포넌트의 리턴문 바로 앞에 클래스이름이 정의된 `HouseCss`같은 객체를 선언하면 리턴문과 `HouseCss`객체만 복붙하는 것으로 상태가 없는 하나의 독립된 컴포넌트를 다른 컴포넌트에 이식할 수 있다. 객체이름을 `HouseCss`와 같이 컴포넌트 이름으로 작성하면 다른 컴포넌트에서 변수명이 충돌할 일도 없다\\\r\n\\\r\n만일 css 가독성을 극대화하고 싶다면 위의 코드를 아래와 같이 변경할 수도 있다\r\n\r\n```javascript\r\nconst HouseCss = {\r\n\r\n    wrapper : `grid` + \r\n    ` grid-cols-1` + \r\n    ` sm:grid-cols-2` + \r\n    ` sm:px-8` + \r\n    ` sm:py-12` + \r\n    ` sm:gap-x-8` + \r\n    ` md:py-16`,\r\n    \r\n    description : \r\n    `relative` + \r\n    ` z-10` + \r\n    ` col-start-1` + \r\n    ` row-start-1` + \r\n    ` px-4` + \r\n    ` pt-40` + \r\n    ` pb-3` + \r\n    ` bg-gradient-to-t` + \r\n    ` from-black sm:bg-none`,\r\n\r\n    p : `text-sm` + \r\n    `font-medium` + \r\n    `text-white` + \r\n    `sm:mb-1` + \r\n    `sm:text-gray-500`,\r\n\r\n    h2 : `text-xl` +  \r\n    ` font-semibold`  + \r\n    ` text-white sm:text-2xl` + \r\n    ` sm:leading-7` +  \r\n    ` sm:text-black` +  \r\n    ` md:text-3xl`,\r\n}\r\n\r\nfunction House(){\r\n\r\n    return (\r\n        <div className={HouseCss.wrapper}>\r\n            <div className={HouseCss.description}>\r\n                <p className={HouseCss.p}>Entire house</p>\r\n                <h2 className={HouseCss.h2}>Beach House in Collingwood</h2>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n```\r\n\r\n클래스 정의부를 함수 밖으로 꺼내었다. 이렇게 하면 js 레이어,  마크업 레이어, css 레이어가 구분되므로 클래스 이름을 세로로 기입해도 큰 부담이 없다. 아무리 클래스 이름이 길더라도 css정의에 국한되어 있어서 다른 레이어에 영향을 주지 않기 때문이다\\\r\n\\\r\n이렇게 하면 세로축으로 코드가 읽히므로 정의된 스타일이 한눈에 들어온다. 따라서 이러한 프랙티스는 css 유지보수에 최적이다. 이 같은 상황에서 css를 수정하는 시나리오를 가정해 보자. h2의 텍스트 크기를 변경하고 싶을 때 아래와 같은 절차를 거친다\r\n\r\n1. 먼저 h2 엘리먼트가 정의된 코드로 이동한다\r\n2. h2 엘리먼트에서 `className={HouseCss.h2}` 부분에 마우스 커서를 올려놓고 f12를 누른다 (vs code 기준). 그러면 HouseCss.h2의 정의부로 이동한다. 즉 아래와 같은 코드로 이동한다\r\n\r\n```javascript\r\n    // ...\r\n    h2 : `text-xl` +  \r\n    ` font-semibold`  + \r\n    ` text-white sm:text-2xl` + \r\n    ` sm:leading-7` +  \r\n    ` sm:text-black` +  \r\n    ` md:text-3xl`,\r\n    // ...\r\n```\r\n3. 수정할 클래스이름을 찾는다. 이 예제에서는 텍스트 크기를 수정할 것이므로 텍스트 크기가 정의된 부분을 찾는다. 위의 코드에서는  `text-xl`과  ` text-white sm:text-2xl`,  그리고 ` md:text-3xl`가 해당된다. 여기서 원하는 부분을 수정한다\r\n4. 끝\r\n\r\n\r\n만일 이러한 프랙티스가 아닌 공홈에서 제공하는 베스트 프랙티스만을 적용하고 싶다면 아래와 같은 상황에 적합한 것으로 보인다\r\n\r\n1. 개발을 빠르게 하고 싶을때\r\n2. 한번 개발해놓고 나면 마크업 구조나 디자인을 수정할 일이 거의 없을때\r\n\r\n#### Q. 스타일드 컴포넌트(styled-components)란 무엇인가?\r\n\r\n스타일드 컴포넌트는 css-in-js 패턴의 일종이다. 말 그대로 스타일이 적용된 컴포넌트를 생성한다\\\r\n\\\r\n함수 컴포넌트 내부에서 스타일 객체의 메소드를 호출하여 새로운 스타일이 적용된 컴포넌트를 반환한다\\\r\n아래 예는 스타일 객체에서 a메소드를 호출하여 새로운 스타일이 적용된 앵커 태그를 생성한다\r\n\r\n```javascript\r\nconst AnchorTag = styled.a`\r\n    color : red\r\n` ;\r\n```\r\n\r\n이렇게 리턴된 컴포넌트는 일반적인 리액트 컴포넌트처럼 사용할 수 있다\\\r\n스타일드 컴포넌트가 주목받는 이유는 두가지 정도가 있다\\\r\n\\\r\n첫째로 함수 컴포넌트의 리턴부분이 깔끔해진다. html엘리먼트에 어떠한 클래스네임도 기입할 필요가 없기 때문이다\\\r\n\\\r\n두번째로 함수 컴포넌트의 완전한 고립화가 가능해진다. 외부의 css파일에서 css속성을 임포트하지 않아도 되므로 단일 파일 형태로 관리하기 쉽다. 이에 따라 자연스럽게 재사용성도 높아진다\\\r\n\\\r\n세번째로 레가시 코드를 새로운 css 프레임워크로 대체할 때 코드를 리팩토링할 필요가 없다. 앞서 말했듯 스타일드 컴포넌트가 적용된 리액트 컴포넌트는 완전한 고립화가 가능하므로 다른 컴포넌트에서 테일윈드 css등의 별개의 프레임워크를 사용한다 하더라도 충돌을 일으키지 않은 채 정상적으로 작동한다\\\r\n\\\r\n하지만 스타일드 컴포넌트는 css 정의와 리액트 컴포넌트 정의부분이 분리되지 않으므로 다른 컴포넌트에서 css 정의를 재사용하기 어렵다는 단점이 있다\r\n\r\n#### Q. 함수 컴포넌트 내부에서 사용하는 `<style jsx>{\" \"}` 같은 패턴을 뭐라고 부르는가 ?\r\n\r\n이것은 `스타일드 jsx(styled-jsx)` 라고 부른다. 버셀(vercel)에서 개발한 스타일드 jsx 라이브러리는 함수 컴포넌트 내부에서 사용하는 `css-in-js` 패턴의 일종이다.\\\r\n\\\r\n스타일드 jsx에서 선언된 css 규칙은 해당 컴포넌트에만 국소적으로 적용된다.\\\r\n\\\r\n이는 스타일드 컴포넌트 라이브러와 유사하지만 둘 사이의 차이점이 있다.\\\r\n\\\r\n스타일드 jsx는 css규칙을 선언한 후에 html엘리먼트에도 클래스이름을 기입해야 하는 번거로움이 있다.\\\r\n\\\r\n하지만 스타일드 컴포넌트로 정의된 리액트 컴포넌트에는 별도의 클래스네임을 기입할 필요가 없다는 편의성이 있다.\\\r\n\\\r\n이런 면에서 보면 스타일드 jsx의 진화된 버전이 스타일드 컴포넌트라고 해석할 수도 있지만 꼭 스타일드 컴포넌트가 더 좋다고 볼 수는 없다\\\r\n\\\r\n왜냐하면 스타일드 컴포넌트는 코드부와 css정의부가 독립되기 않기 때문이다.\\\r\n\\\r\n코드부와 css정의부가 독립되는게 왜 중요한가?\\\r\n\\\r\n이들 둘이 분리되어 있는 경우에는 관심사의 분리가 이루어진 것이며 관심사가 분리된 경우에는 코드의 유지보수가 더 수월해진다\\\r\n\\\r\ncss 디피니티브 가이드(css definitive guide)의 공저자인 에스텔 웨일(Estelle Weyl)은 css와 js코드가 분리되어야 한다고 주장했는데 그렇게 해야하는 이유는 레이어를 분리하기 위함이다.\\\r\n\\\r\n애초에 웹을 구성하는 도구가 html, css, javascript의 3가지로 나뉜것도 레이어를 분리해서 유지보수를 수월하게 하기 위함이었다고 그녀는 말한다.\\\r\n\\\r\n구체적으로 이야기하면 css는 표현 계층(presentational layer)의 구현체이며 자바스크립트는 행동 계층(Behavioral layer)의 구현체이다.\\\r\n\\\r\n이들 둘이 분리된건 우연이 아니며 의도적인 것이었다.\\\r\n\\\r\n그런데 오늘날 `css-in-js`를 통하여 표현 계층과 행동 계층을 합병하려 하고 있으니 이것은 썩 바라짐하지 못하다고 그녀는 이야기하고 있는 것이었다.\\\r\n\\\r\n그러므로 우리는 외부에서 css를 항상 임포트해서 써야 하는가? 리액트의 관점에서 보면 그것도 썩 바람직하다고는 볼 수 없는 것이다.\\\r\n\\\r\n왜냐하면 그것은 단일 파일이 하나의 컴포넌트로 완결성을 지니는 고립성(isolation)을 해치기 때문이다.\\\r\n\\\r\n그런 관점에서 볼 때 스타일드 jsx는 레이어의 분리와 컴포넌트의 고립성을 보장하면서 어느정도는 레이어를 분리시키는 이 두가지 원칙의 절충점이라고 볼 수 있다\\\r\n\\\r\n비록 스타일드 jsx가 js파일 내부에서 사용된다고는 할지라도 단일 jsx구문은 코드에 산발적으로 흩어져있지 않으며 한곳에 응집되어 있다\\\r\n\\\r\n따라서 이리저리 css코드를 찾으러 헤메일 필요가 없는 것이다.\\\r\n\\\r\n이런면에서 볼 때 어느정도는 레이어의 분리가 성립되었다고도 평가할 수 있는 것이다\\\r\n\\\r\n결론을 말하면 완전한 레이어의 분리를 유지하여 개발하고 싶다면 css 모듈이 적합하고 리액트 컴포넌트를 단일 파일로 고립시킨 상태에서 어느정도의 레이어의 분리를 원한다면 스타일드 jsx가 적합하다\r\n\r\n\r\n#### Q. CSS Module이란 무엇인가 ?\r\n\r\ncss 모듈은 특정 컴포넌트에만 국소적으로 스타일을 적용하는 css 테크닉이다\\\r\n\\\r\ncss 모듈은 일반적인 css 임포트 (import) 패턴과 거의 같은 패턴이므로 새롭게 배울 내용은 거의 없다\\\r\n\\\r\n다만 css 파일명은 `컴포넌트명.module.css`과 같은 포멧으로 작성한다\\\r\n\\\r\n그리고 css를 적용할 때는 임포트된 css 모듈에 프로퍼티로 정의된 클래스 이름을 사용한다\\\r\n\\\r\n클래스명이나 아이디 어트리뷰트를 css 식별자로 사용할 수 있지만 아이디 사용은 권장하지 않는다. 아이디는 유니크한 값이므로 적용할 수 있는 엘리먼트가 매우 제한적이기 때문이다\\\r\n\\\r\n같은 css모듈을 사용하더라도 임포트 할 때마다 고유한 클래스 이름이 생성되어 다른 컴포넌트에서 같은 css 모듈을 사용한다고 해도 클래스명이 겹칠 일은 없다\\\r\n\\\r\n이것이 특정 컴포넌트에만 국소적으로 스타일을 적용하게 해주는 핵심 원리다\\\r\n\r\n#### Q. `CSS 모듈`에 안티 패턴이 있는가?\r\n\r\nA. 부모 컴포넌트에서 생성된 클래스네임을 자식 컴포넌트로 상속하지 않는 편이 좋다.\\\r\n\\\r\nCSS 모듈을 임포트하고 나서 해당 모듈에서 제공하는 클래스네임을 자식 컴포넌트에 프롭스로  전달하지 않는 편이 좋다.\\\r\n\\\r\n만일 css 모듈 파일에서 클래스 이름을 변경했을 때 단일 컴포넌트에서만 사용하는 경우 클래스 네임의 변경은 쉽다. 그저 IDE를 켜고 일괄적으로 이름바꾸기 기능을 사용하면 10초 내외로 끝나는 작업이다.\\\r\n\\\r\n하지만 불특정 다수의 자식 컴포넌트에서 해당 클래스 이름을 가져다가 사용하는 경우는 자식 컴포넌트가 정의된 모든 파일을 순회하며 클래스 이름을 변경해줘야 하는 번거로움이 발생한다\r\n\r\n#### Q. SASS(Syntactically Awesome Stylesheets) 란 무엇인가 ?\r\n\r\n# SASS부분은 작성중입니다\r\n\r\n사스는 css의 변종 언어이며 이 언어는 빌드 과정에서 css로 트랜스파일 된다\\\r\n\\\r\n사스는 css 표준 문법보다 더욱 프로그래밍 언어스럽게 개발할 수 있다는 장점이 있다. 즉 사스는 변수, 믹스인, 중첩과 같은 기능을 제공한다. 이러한 기능들은 개발의 편의성을 제공한다\\\r\n\\\r\n요즘은 css 표준에도 변수같은 기능이 추가되어 사스를 사용할 이유가 점차 줄어들고 있기는 하다\r\n\r\n# SASS부분은 작성중입니다\r\n",
      "html": "<h3 id=\"리액트의-css패턴-qa-모음\">리액트의 css패턴 Q&amp;A 모음</h3>\n<h4 id=\"q-css-in-js가-무엇인가\">Q. css-in-js가 무엇인가?</h4>\n<p>css파일이 아닌 자바스크립트 파일 내부에서 css 규칙을 정의하는 코딩 스타일을 <code>css-in-js</code>라고 부른다.<br>\n<br>\n스타일드 컴포넌트같은 라이브러리가 대표적인 css-in-js의 예이다</p>\n<h4 id=\"q-테일윈드-css-tailwind-css란-무엇인가\">Q. 테일윈드 css (tailwind css)란 무엇인가?</h4>\n<p>테일윈드를 이야기하기 앞서 부트스트랩 라이브러리를 이야기 해보자<br>\n<br>\n부트스트랩은 일일이 css 규칙을 정의하지 않아도 html 엘리먼트에 클래스 이름을 기입하는 것만으로 간편하게 사용할 수 있는 라이브러리이다. 이것이 가능한 이유는 부트스트랩 팀에서 미리 css 코드와 클래스 이름을 정의해놓았기 때문이다<br>\n<br>\n즉 부트스트랩을 사용하면 남이 만들어놓은 css를 그저 가져다 쓰면 될 뿐이므로 내가 css 규칙을 작성할 일이 거의 없다. 부트스트랩에서 제공하는 클래스 이름만 암기하고 그 암기한 클래스 이름을 원하는 엘리먼트에 붙여넣으면 될 뿐이다<br>\n<br>\n그리고 이 부트스트랩의 후계자 정도 되는 라이브러리가 테일윈드 css인데 테일윈드 css도 부트스트랩과 마찬가지로 이미 정의되어 있는 css규칙을 사용한다. 유저는 그저 테일윈드에 정의되어 있는 클래스 이름을 암기하고 그 이름을 가져다가 특정 html 엘리먼트에 적용하기만 하면 된다. 예를 들어 아래와 같다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function 컴포넌트()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    return(\r\n        &lt;div className=\"w-64 h-3 bg-gradient-to-br from-fuchsia-500 to-purple-600\">\r\n            테일윈드를 적용한 div\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>위의 코드는 css 정의부가 없으며 그저 정의된 css를 적용했다. 즉 내가 별도로 css를 작성하는데 소비되는 시간이 줄어든다. 극단적으로 말하면 프로젝트의 모든 스타일링을 테일윈드 만으로도 구현할 수 있다. 그렇게 된다면 내가 별도로 작성해야 하는 css코드의 양을 제로로 줄이는것도 가능하다<br>\n<br>\n그리고 이미 정의되어 있는 css를 가져다가 쓰기 때문에 마크업 부분과 css정의부를 이리저리 왔다갔다 할 필요가 없다. 테일윈드를 쓰는 사람들은 <code>개발 시간이 줄어들었다</code>는 이야기를 공통적으로 하는데 이처럼 코드를 이리저리 옮겨다닐 필요가 없는 것도 개발시간 단축에 한 몫 한다<br>\n<br>\n이렇게만 적어놓으면 테일윈드를 사용하지 않는 것이 바보처럼 느껴지겠지만 꼭 그렇지만도 않다. 테일윈드의 시장점유율이 압도적인 것도 아니다. 왜 그럴까?  일단 암기해야 하는 클래스 이름이 많아 어느정도의 러닝커브가 있다. 테일윈드에 익숙해지기 전까지는 모니터 한켠에 테일윈드의 공식 docs 페이지를 띄어놓고 검색하는 일이 잦다<br>\n<br>\n이것보다 더 큰 문제는 코드가 지저분해지는 단점이다. 위의 코드만 보면 별 느낌이 없을 수도 있겠지만 아래의 코드를 보자</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function 컴포넌트()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    return (\r\n        &lt;div className=\"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\">\r\n            &lt;div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\r\n                &lt;p className=\"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\">Entire house&lt;/p>\r\n                &lt;h2 className=\"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\">Beach House in Collingwood&lt;/h2>\r\n            &lt;/div>\r\n            &lt;div className=\"col-start-1 row-start-2 px-4 sm:pb-16\">\r\n                &lt;div className=\"flex items-center text-sm font-medium my-5 sm:mt-2 sm:mb-4\">\r\n                    &lt;svg width=\"20\" height=\"20\" fill=\"currentColor\" className=\"text-violet-600\">\r\n                        &lt;path d=\"M9.05 3.691c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.372 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.539 1.118l-2.8-2.034a1 1 0 00-1.176 0l-2.8 2.034c-.783.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.363-1.118l-2.8-2.034c-.784-.57-.381-1.81.587-1.81H7.03a1 1 0 00.95-.69L9.05 3.69z\" />\r\n                    &lt;/svg>\r\n                    &lt;div className=\"ml-1\">\r\n                        &lt;span className=\"text-black\">4.94&lt;/span>\r\n                        &lt;span className=\"sm:hidden md:inline\">(128)&lt;/span>\r\n                    &lt;/div>\r\n                    &lt;div className=\"text-base font-normal mx-2\">·&lt;/div>\r\n                    &lt;div>Collingwood, Ontario&lt;/div>\r\n                &lt;/div>\r\n                &lt;hr className=\"w-16 border-gray-300 hidden sm:block\">\r\n            &lt;/div>\r\n            &lt;div className=\"col-start-1 row-start-3 space-y-3 px-4\">\r\n                &lt;p className=\"flex items-center text-black text-sm font-medium\">\r\n                    &lt;img src=\"/kevin-francis.jpg\" alt=\"\" className=\"w-6 h-6 rounded-full mr-2 bg-gray-100\">\r\n                    Hosted by Kevin Francis\r\n                &lt;/p>\r\n                &lt;button type=\"button\" className=\"bg-violet-100 text-violet-700 text-base font-semibold px-6 py-2 rounded-lg\">Check availability&lt;/button>\r\n            &lt;/div>\r\n            &lt;div className=\"col-start-1 row-start-1 flex sm:col-start-2 sm:row-span-3\">\r\n                &lt;div className=\"w-full grid grid-cols-3 grid-rows-2 gap-2\">\r\n                    &lt;div className=\"relative col-span-3 row-span-2 md:col-span-2\">\r\n                        &lt;img src=\"/beach-house.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover bg-gray-100 sm:rounded-lg\" />\r\n                    &lt;/div>\r\n                    &lt;div className=\"relative hidden md:block\">\r\n                        &lt;img src=\"/beach-house-interior.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover rounded-lg bg-gray-100\" />\r\n                    &lt;/div>\r\n                    &lt;div className=\"relative hidden md:block\">\r\n                        &lt;img src=\"/beach-house-view.jpg\" alt=\"\" className=\"absolute inset-0 w-full h-full object-cover rounded-lg bg-gray-100\" />\r\n                    &lt;/div>\r\n                &lt;/div>\r\n            &lt;/div>\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>위의 코드는 본인이 만든 코드가 아니다. 테일윈드 공식 사이트에 있는 코드를 가져와서 함수 컴포넌트로 바꾸었을 뿐이다.<br>\n자 위의 코드는 일단 만들 때는 편하다. 위에서 언급한 대로 마크업과 css부분을 옮겨다닐 필요가 없고 남이 정의해 놓은 규칙을 가져다가 쓰기만 하면 되기 때문이다. 하지만 유지보수 상황을 고려해 보자.<br>\n<br>\n먼저 마크업의 구조를 변경하고 싶을 때 전체적인 구조가 한눈에 들어오지 않는다. 이것은 마크업 레이어와 css레이어가 섞여있기 때문이다.<br>\n애써 클래스네임 부분을 무시하고 구조만 보려고 해도 잘 되지 않는다. 이는 인간의 눈이 무언가를 인지할 때 내가 보고싶은 정보만 취사선택 하기가 어렵기 때문이다. 이처럼 마크업 구조를 이해할 때 인지적인 과부하 문제가 있다<br>\n<br>\n두번째로 css를 수정해야 하는 상황을 보자. 이런경우 내가 수정할 엘리먼트의 css가 어디에 정의되어 있는지를 별도로 찾을 필요는 없다. 여기까지는 좋다. 그러나 아래의 코드를 보자</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\n</code></pre>\n<p>위의 코드에서 패딩을 수정하고 싶다. 무엇을 수정해야 하는지 한눈에 들어오는가? 아마 쉽지 않을것이다. 일단 클래스이름이 가로로 적혀있는 관계로 가독성이 떨어진다. 만일 위의 코드를 세로로 바꾸면 아래와 같이 된다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">  &lt;div className=\"\r\n    relative \r\n    z-10 \r\n    col-start-1 \r\n    row-start-1 \r\n    px-4 \r\n    pt-40 \r\n    pb-3 \r\n    bg-gradient-to-t \r\n    from-black \r\n    sm:bg-none\">\n</code></pre>\n<p>이건 좀 낫다. 하지만 실제로는 이런 식으로 코딩할 수 없다. 클래스이름을 세로로 작성하면 너무 길어지고 그렇게되면 마크업 구조를 파악하는 게 거의 불가능에 가까워진다. 따라서 가로로 정의할 수 밖에 없는데 이 때문에 클래스이름이 한눈에 들어오지 않는다.<br>\n<br>\nctrl-f로 검색을 해서 원하는 클래스를 찾은다음 수정하는 방법도 있다. 그런데 패딩에 대한 클래스이름이 한두개가 아니라 그것도 어렵다. p-도 패딩이고 px도 패딩, pt, pb, pr등이 모두 패딩이다. 위의 예에서는 <code>px-4</code>, <code>pt-40</code>, <code>pb-3</code>가 모두 패딩이다. 즉 내가 수정하고 싶은 디자인의 클래스이름을 찾는것도 쉽지않다.<br>\n<br>\n이전에 특정한 스타일을 지정했는지 지정하지 않았는지 확인하는 것도 쉽지 않다. 예를 들어 내가 폰트사이즈를 바꾸고 싶어서 <code>text-7xl</code> 이라는 클래스이름을 추가했다. 그런데 이미 앞에서 <code>text-2xl</code>가 선언되어 있었다. 다만 클래스 문자열이 너무 길어서 미처 확인하지 못한것이다. 이렇게 되면 중복으로 같은 속성을 지정하는 문제가 생길수도 있다.<br>\n따라서 초기 개발은 빠를 수 있지만 유지보수의 속도는 그렇지 않을 수 있다는 결론도 무리는 아닌것으로 보인다<br>\n<br>\n이런 문제를 조금이라도 극복할 수 있을까? 먼저 클래스이름을 별도의 문자열로 떼어놓는 방법이 있다. 가령 아래와 같은 코드가 있다고 가정하자</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function House()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    return (\r\n        &lt;div className=\"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\">\r\n            &lt;div className=\"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\">\r\n                &lt;p className=\"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\">Entire house&lt;/p>\r\n                &lt;h2 className=\"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\">Beach House in Collingwood&lt;/h2>\r\n            &lt;/div>\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>위의 코드에서 인라인 문자열을 별도의 변수로 분리하면 아래와 같이 변경된다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function House()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    const HouseCss = ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        wrapper : \"grid grid-cols-1 sm:grid-cols-2 sm:px-8 sm:py-12 sm:gap-x-8 md:py-16\",\r\n        description : \"relative z-10 col-start-1 row-start-1 px-4 pt-40 pb-3 bg-gradient-to-t from-black sm:bg-none\",\r\n        p : \"text-sm font-medium text-white sm:mb-1 sm:text-gray-500\",\r\n        h2 : \"text-xl font-semibold text-white sm:text-2xl sm:leading-7 sm:text-black md:text-3xl\",\r\n    }\r\n\r\n    return (\r\n        &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.wrapper}>\r\n            &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.description}>\r\n                &lt;p className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.p}>Entire house&lt;/p>\r\n                &lt;h2 className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.h2}>Beach House in Collingwood&lt;/h2>\r\n            &lt;/div>\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>이렇게 되니 마크업 구조의 이해가 더 수월해졌다. 이것은 공식 사이트에서 제안하는 베스트 프랙티스는 아닌 본인의 생각이니 오해없기 바란다. 왜 이것이 베스트 프랙티스가 아닌지는 모르겠으나 개인적으로는 이게 더 낫다<br>\n<br>\n하지만 위의 방법론도 어떤 클래스이름을 지정했는지 한눈에 들어오지 않는 단점이 있다. 이것은 문자열을 합병하는 식으로 코드를 표현하면 조금 나아진다. 가령 아래와 같다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function House()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    const HouseCss = ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        wrapper : `grid` + ` grid-cols-1` + ` sm:grid-cols-2` + ` sm:px-8` + ` sm:py-12` + ` sm:gap-x-8` + ` md:py-16`,\r\n        description : `relative` + ` z-10` + ` col-start-1` + ` row-start-1` + ` px-4` + ` pt-40` + ` pb-3` + ` bg-gradient-to-t` + ` from-black sm:bg-none`,\r\n        p : `text-sm` + `font-medium` + `text-white` + `sm:mb-1` + `sm:text-gray-500`,\r\n        h2 : `text-xl` +  ` font-semibold`  + ` text-white sm:text-2xl` + ` sm:leading-7` +  ` sm:text-black` +  ` md:text-3xl`,\r\n    }\r\n\r\n    return (\r\n        &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.wrapper}>\r\n            &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.description}>\r\n                &lt;p className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.p}>Entire house&lt;/p>\r\n                &lt;h2 className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.h2}>Beach House in Collingwood&lt;/h2>\r\n            &lt;/div>\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>이렇게 해놓으니 클래스이름이 더 잘 구분된다. 이런 프랙티스는 마크업 레이어와 css레이어가 합쳐짐으로서 얻는 장점을 거의 그대로 가져온다. 즉 마크업 선언부와 css 정의부를 옮겨다닐 일이 거의 없다. 클래스를 인라인에 직접 기입하지 않으므로 옮겨다닐 일이 아주 없는건 아니다. 하지만 리턴문 바로 앞에 클래스이름을 정의하면 코드를 이동할 때 소모되는 인지적 과부하가 상당부분 줄어든다<br>\n<br>\n또한 마크업 부분을 그대로 복붙해서 다른 컴포넌트에 가져다가 집어넣어도 그 자체로 완결성을 가진 컴포넌트로 작동할 수 있다. 즉 외부에서 css모듈까지 추가로 복붙해야 하는 번거로움이 없다. 그저 함수 컴포넌트의 리턴문 바로 앞에 클래스이름이 정의된 <code>HouseCss</code>같은 객체를 선언하면 리턴문과 <code>HouseCss</code>객체만 복붙하는 것으로 상태가 없는 하나의 독립된 컴포넌트를 다른 컴포넌트에 이식할 수 있다. 객체이름을 <code>HouseCss</code>와 같이 컴포넌트 이름으로 작성하면 다른 컴포넌트에서 변수명이 충돌할 일도 없다<br>\n<br>\n만일 css 가독성을 극대화하고 싶다면 위의 코드를 아래와 같이 변경할 수도 있다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const HouseCss = ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    wrapper : `grid` + \r\n    ` grid-cols-1` + \r\n    ` sm:grid-cols-2` + \r\n    ` sm:px-8` + \r\n    ` sm:py-12` + \r\n    ` sm:gap-x-8` + \r\n    ` md:py-16`,\r\n    \r\n    description : \r\n    `relative` + \r\n    ` z-10` + \r\n    ` col-start-1` + \r\n    ` row-start-1` + \r\n    ` px-4` + \r\n    ` pt-40` + \r\n    ` pb-3` + \r\n    ` bg-gradient-to-t` + \r\n    ` from-black sm:bg-none`,\r\n\r\n    p : `text-sm` + \r\n    `font-medium` + \r\n    `text-white` + \r\n    `sm:mb-1` + \r\n    `sm:text-gray-500`,\r\n\r\n    h2 : `text-xl` +  \r\n    ` font-semibold`  + \r\n    ` text-white sm:text-2xl` + \r\n    ` sm:leading-7` +  \r\n    ` sm:text-black` +  \r\n    ` md:text-3xl`,\r\n}\r\n\r\nfunction House()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    return (\r\n        &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.wrapper}>\r\n            &lt;div className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.description}>\r\n                &lt;p className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.p}>Entire house&lt;/p>\r\n                &lt;h2 className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.h2}>Beach House in Collingwood&lt;/h2>\r\n            &lt;/div>\r\n        &lt;/div>\r\n    )\r\n}\n</code></pre>\n<p>클래스 정의부를 함수 밖으로 꺼내었다. 이렇게 하면 js 레이어,  마크업 레이어, css 레이어가 구분되므로 클래스 이름을 세로로 기입해도 큰 부담이 없다. 아무리 클래스 이름이 길더라도 css정의에 국한되어 있어서 다른 레이어에 영향을 주지 않기 때문이다<br>\n<br>\n이렇게 하면 세로축으로 코드가 읽히므로 정의된 스타일이 한눈에 들어온다. 따라서 이러한 프랙티스는 css 유지보수에 최적이다. 이 같은 상황에서 css를 수정하는 시나리오를 가정해 보자. h2의 텍스트 크기를 변경하고 싶을 때 아래와 같은 절차를 거친다</p>\n<ol>\n<li>먼저 h2 엘리먼트가 정의된 코드로 이동한다</li>\n<li>h2 엘리먼트에서 <code>className=ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000HouseCss.h2}</code> 부분에 마우스 커서를 올려놓고 f12를 누른다 (vs code 기준). 그러면 HouseCss.h2의 정의부로 이동한다. 즉 아래와 같은 코드로 이동한다</li>\n</ol>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">    // ...\r\n    h2 : `text-xl` +  \r\n    ` font-semibold`  + \r\n    ` text-white sm:text-2xl` + \r\n    ` sm:leading-7` +  \r\n    ` sm:text-black` +  \r\n    ` md:text-3xl`,\r\n    // ...\n</code></pre>\n<ol start=\"3\">\n<li>수정할 클래스이름을 찾는다. 이 예제에서는 텍스트 크기를 수정할 것이므로 텍스트 크기가 정의된 부분을 찾는다. 위의 코드에서는  <code>text-xl</code>과  <code> text-white sm:text-2xl</code>,  그리고 <code> md:text-3xl</code>가 해당된다. 여기서 원하는 부분을 수정한다</li>\n<li>끝</li>\n</ol>\n<p>만일 이러한 프랙티스가 아닌 공홈에서 제공하는 베스트 프랙티스만을 적용하고 싶다면 아래와 같은 상황에 적합한 것으로 보인다</p>\n<ol>\n<li>개발을 빠르게 하고 싶을때</li>\n<li>한번 개발해놓고 나면 마크업 구조나 디자인을 수정할 일이 거의 없을때</li>\n</ol>\n<h4 id=\"q-스타일드-컴포넌트styled-components란-무엇인가\">Q. 스타일드 컴포넌트(styled-components)란 무엇인가?</h4>\n<p>스타일드 컴포넌트는 css-in-js 패턴의 일종이다. 말 그대로 스타일이 적용된 컴포넌트를 생성한다<br>\n<br>\n함수 컴포넌트 내부에서 스타일 객체의 메소드를 호출하여 새로운 스타일이 적용된 컴포넌트를 반환한다<br>\n아래 예는 스타일 객체에서 a메소드를 호출하여 새로운 스타일이 적용된 앵커 태그를 생성한다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const AnchorTag = styled.a`\r\n    color : red\r\n` ;\n</code></pre>\n<p>이렇게 리턴된 컴포넌트는 일반적인 리액트 컴포넌트처럼 사용할 수 있다<br>\n스타일드 컴포넌트가 주목받는 이유는 두가지 정도가 있다<br>\n<br>\n첫째로 함수 컴포넌트의 리턴부분이 깔끔해진다. html엘리먼트에 어떠한 클래스네임도 기입할 필요가 없기 때문이다<br>\n<br>\n두번째로 함수 컴포넌트의 완전한 고립화가 가능해진다. 외부의 css파일에서 css속성을 임포트하지 않아도 되므로 단일 파일 형태로 관리하기 쉽다. 이에 따라 자연스럽게 재사용성도 높아진다<br>\n<br>\n세번째로 레가시 코드를 새로운 css 프레임워크로 대체할 때 코드를 리팩토링할 필요가 없다. 앞서 말했듯 스타일드 컴포넌트가 적용된 리액트 컴포넌트는 완전한 고립화가 가능하므로 다른 컴포넌트에서 테일윈드 css등의 별개의 프레임워크를 사용한다 하더라도 충돌을 일으키지 않은 채 정상적으로 작동한다<br>\n<br>\n하지만 스타일드 컴포넌트는 css 정의와 리액트 컴포넌트 정의부분이 분리되지 않으므로 다른 컴포넌트에서 css 정의를 재사용하기 어렵다는 단점이 있다</p>\n<h4 id=\"q-함수-컴포넌트-내부에서-사용하는-style-jsx--같은-패턴을-뭐라고-부르는가-\">Q. 함수 컴포넌트 내부에서 사용하는 <code>&lt;style jsx>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\" \"}</code> 같은 패턴을 뭐라고 부르는가 ?</h4>\n<p>이것은 <code>스타일드 jsx(styled-jsx)</code> 라고 부른다. 버셀(vercel)에서 개발한 스타일드 jsx 라이브러리는 함수 컴포넌트 내부에서 사용하는 <code>css-in-js</code> 패턴의 일종이다.<br>\n<br>\n스타일드 jsx에서 선언된 css 규칙은 해당 컴포넌트에만 국소적으로 적용된다.<br>\n<br>\n이는 스타일드 컴포넌트 라이브러와 유사하지만 둘 사이의 차이점이 있다.<br>\n<br>\n스타일드 jsx는 css규칙을 선언한 후에 html엘리먼트에도 클래스이름을 기입해야 하는 번거로움이 있다.<br>\n<br>\n하지만 스타일드 컴포넌트로 정의된 리액트 컴포넌트에는 별도의 클래스네임을 기입할 필요가 없다는 편의성이 있다.<br>\n<br>\n이런 면에서 보면 스타일드 jsx의 진화된 버전이 스타일드 컴포넌트라고 해석할 수도 있지만 꼭 스타일드 컴포넌트가 더 좋다고 볼 수는 없다<br>\n<br>\n왜냐하면 스타일드 컴포넌트는 코드부와 css정의부가 독립되기 않기 때문이다.<br>\n<br>\n코드부와 css정의부가 독립되는게 왜 중요한가?<br>\n<br>\n이들 둘이 분리되어 있는 경우에는 관심사의 분리가 이루어진 것이며 관심사가 분리된 경우에는 코드의 유지보수가 더 수월해진다<br>\n<br>\ncss 디피니티브 가이드(css definitive guide)의 공저자인 에스텔 웨일(Estelle Weyl)은 css와 js코드가 분리되어야 한다고 주장했는데 그렇게 해야하는 이유는 레이어를 분리하기 위함이다.<br>\n<br>\n애초에 웹을 구성하는 도구가 html, css, javascript의 3가지로 나뉜것도 레이어를 분리해서 유지보수를 수월하게 하기 위함이었다고 그녀는 말한다.<br>\n<br>\n구체적으로 이야기하면 css는 표현 계층(presentational layer)의 구현체이며 자바스크립트는 행동 계층(Behavioral layer)의 구현체이다.<br>\n<br>\n이들 둘이 분리된건 우연이 아니며 의도적인 것이었다.<br>\n<br>\n그런데 오늘날 <code>css-in-js</code>를 통하여 표현 계층과 행동 계층을 합병하려 하고 있으니 이것은 썩 바라짐하지 못하다고 그녀는 이야기하고 있는 것이었다.<br>\n<br>\n그러므로 우리는 외부에서 css를 항상 임포트해서 써야 하는가? 리액트의 관점에서 보면 그것도 썩 바람직하다고는 볼 수 없는 것이다.<br>\n<br>\n왜냐하면 그것은 단일 파일이 하나의 컴포넌트로 완결성을 지니는 고립성(isolation)을 해치기 때문이다.<br>\n<br>\n그런 관점에서 볼 때 스타일드 jsx는 레이어의 분리와 컴포넌트의 고립성을 보장하면서 어느정도는 레이어를 분리시키는 이 두가지 원칙의 절충점이라고 볼 수 있다<br>\n<br>\n비록 스타일드 jsx가 js파일 내부에서 사용된다고는 할지라도 단일 jsx구문은 코드에 산발적으로 흩어져있지 않으며 한곳에 응집되어 있다<br>\n<br>\n따라서 이리저리 css코드를 찾으러 헤메일 필요가 없는 것이다.<br>\n<br>\n이런면에서 볼 때 어느정도는 레이어의 분리가 성립되었다고도 평가할 수 있는 것이다<br>\n<br>\n결론을 말하면 완전한 레이어의 분리를 유지하여 개발하고 싶다면 css 모듈이 적합하고 리액트 컴포넌트를 단일 파일로 고립시킨 상태에서 어느정도의 레이어의 분리를 원한다면 스타일드 jsx가 적합하다</p>\n<h4 id=\"q-css-module이란-무엇인가-\">Q. CSS Module이란 무엇인가 ?</h4>\n<p>css 모듈은 특정 컴포넌트에만 국소적으로 스타일을 적용하는 css 테크닉이다<br>\n<br>\ncss 모듈은 일반적인 css 임포트 (import) 패턴과 거의 같은 패턴이므로 새롭게 배울 내용은 거의 없다<br>\n<br>\n다만 css 파일명은 <code>컴포넌트명.module.css</code>과 같은 포멧으로 작성한다<br>\n<br>\n그리고 css를 적용할 때는 임포트된 css 모듈에 프로퍼티로 정의된 클래스 이름을 사용한다<br>\n<br>\n클래스명이나 아이디 어트리뷰트를 css 식별자로 사용할 수 있지만 아이디 사용은 권장하지 않는다. 아이디는 유니크한 값이므로 적용할 수 있는 엘리먼트가 매우 제한적이기 때문이다<br>\n<br>\n같은 css모듈을 사용하더라도 임포트 할 때마다 고유한 클래스 이름이 생성되어 다른 컴포넌트에서 같은 css 모듈을 사용한다고 해도 클래스명이 겹칠 일은 없다<br>\n<br>\n이것이 특정 컴포넌트에만 국소적으로 스타일을 적용하게 해주는 핵심 원리다\\</p>\n<h4 id=\"q-css-모듈에-안티-패턴이-있는가\">Q. <code>CSS 모듈</code>에 안티 패턴이 있는가?</h4>\n<p>A. 부모 컴포넌트에서 생성된 클래스네임을 자식 컴포넌트로 상속하지 않는 편이 좋다.<br>\n<br>\nCSS 모듈을 임포트하고 나서 해당 모듈에서 제공하는 클래스네임을 자식 컴포넌트에 프롭스로  전달하지 않는 편이 좋다.<br>\n<br>\n만일 css 모듈 파일에서 클래스 이름을 변경했을 때 단일 컴포넌트에서만 사용하는 경우 클래스 네임의 변경은 쉽다. 그저 IDE를 켜고 일괄적으로 이름바꾸기 기능을 사용하면 10초 내외로 끝나는 작업이다.<br>\n<br>\n하지만 불특정 다수의 자식 컴포넌트에서 해당 클래스 이름을 가져다가 사용하는 경우는 자식 컴포넌트가 정의된 모든 파일을 순회하며 클래스 이름을 변경해줘야 하는 번거로움이 발생한다</p>\n<h4 id=\"q-sasssyntactically-awesome-stylesheets-란-무엇인가-\">Q. SASS(Syntactically Awesome Stylesheets) 란 무엇인가 ?</h4>\n<h1 id=\"sass부분은-작성중입니다\">SASS부분은 작성중입니다</h1>\n<p>사스는 css의 변종 언어이며 이 언어는 빌드 과정에서 css로 트랜스파일 된다<br>\n<br>\n사스는 css 표준 문법보다 더욱 프로그래밍 언어스럽게 개발할 수 있다는 장점이 있다. 즉 사스는 변수, 믹스인, 중첩과 같은 기능을 제공한다. 이러한 기능들은 개발의 편의성을 제공한다<br>\n<br>\n요즘은 css 표준에도 변수같은 기능이 추가되어 사스를 사용할 이유가 점차 줄어들고 있기는 하다</p>\n<h1 id=\"sass부분은-작성중입니다-1\">SASS부분은 작성중입니다</h1>"
    },
    "url": "/posts/%EB%AF%B8%EC%99%84%EC%84%B1_css%EA%B4%80%EB%A0%A8",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/%EB%AF%B8%EC%99%84%EC%84%B1_css%EA%B4%80%EB%A0%A8.md")
  }
}, children);

});
</script><astro-root uid="1IoJj4"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211028_phoenix_qna"><p class="title">엘릭서의 피닉스 프레임워크 FAQ</p></a></header><time>2021.11.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("1IoJj4", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "엘릭서의 피닉스 프레임워크 FAQ",
    "description": "피닉스 프레임워크에 대해 흔하게 물어보는 질문들과 그 답변들",
    "publishDate": "2021.11.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "엘릭서의-피닉스-프레임워크-faq",
        "text": "엘릭서의 피닉스 프레임워크 FAQ"
      }, {
        "depth": 4,
        "slug": "약간-심화내용",
        "text": "약간 심화내용"
      }],
      "source": "\n### 엘릭서의 피닉스 프레임워크 FAQ\n\nQ. 피닉스란 무엇인가?\\\nA. 피닉스는 엘릭서의 웹서버 프레임워크 이다\\\n\\\nQ. 피닉스는 누가 만들었나?\\\nA. 피닉스는 크리스 맥코드가 만들었다. 그는 원래 루비온레일즈로 개발하던 서버 개발자였다. 그는 레일즈에서 `서버기반 상태관리`를 하고 싶었고 실제로 라이브러리까지 만들어가면서 방법을 연구했다. 하지만 루비라는 언어 및 레일즈라는 프레임워크가 제공하는 동시성 수준으로는 한계가 있었고 여러 상황에서 제대로 작동하지 않았던 것이다. 그는 결국 루비온레일즈를 떠났고 높은 수준의 동시성을 제공해주는 환경을 찾다가 결국 엘릭서 생태계로 이전한다. 그리고 나서 결국 웹서버 프레임워크인 피닉스를 만들게 된 것이다.\\\n[출처 : 해커뉴스 rkangel](https://news.ycombinator.com/item?id=25105581)\\\n\\\nQ. 피닉스는 어떤 특징이 있는가?\\\nA. 위에서 언급했던 대로 피닉스는 `서버기반 상태관리`를 하려다가 좌절한 개발자가 만든 웹 프레임워크다. 따라서 `서버기반 상태관리` 기능을 제공한다. 이를 피닉스 라이브뷰라고 한다\\\n\\\nQ. 웹페이지에서 페이지의 상태를 관리하는 기능은 리액트나 뷰 등의 UI 프레임워크가 제공하던 기능이 아닌가 ?\\\nA. 그렇다. 하지만 리액트나 뷰 등을 사용하는 것은 너무 많은 지식을 필요로 한다. 기술이 빠르게 바뀌고 새로운 라이브러리가 계속 등장하고 새로운 프레임워크도 계속 등장한다. 이것을 계속 따라가는 것은 피곤한 일이다. 하지만 `서버기반 상태관리`에 의존하면 이런 기술들을 계속 쫒아갈 필요가 없다. 그저 엘릭서와 피닉스에 대한 지식만으로도 SPA 웹사이트를 만들 수 있는 것이다. 자바스크립트를 단 한줄도 작성할 필요가 없다\\\n\\\nQ. 라이브뷰가 어떤 방식으로 `서버기반 상태관리 기능`을 제공하길래 자바스크립트를 한 줄도 작성할 필요가 없는가?\\\nA. 라이브뷰는 두가지로 이루어진다. 먼저 `템플릿 기반의 html 코드`이다. 이것은 다른 프레임워크도 흔하게 제공하는 기능이다. 두번째로 `이벤트 처리기`이다. 이벤트 처리기란 웹소켓을 통하여 클라이언트와 서버가 교신하는 모델이다. 클라이언트에게 이벤트가 발생하면 그 이벤트는 서버로 전송된다. 서버는 그 이벤트를 받아서 현재 `서버에 저장된 상태를 기준으로` 재랜더링(re-render)을 수행한다. 재랜더링을 수행하는 과정에서 diff알고리즘으로 이전 랜더링과의 차이점을 분석하고 변경된 사항만을 클라이언트에게 전송한다. 이것이 라이브뷰의 핵심이다\\\n\\\nQ. 서버가 상태를 가지고 있고 렌더링도 수행한다면 이건 `서버에서 작동하는 리액트`가 아닌가?\\\nA. 그렇게 볼 수도 있다. 다만 소위 말하는 `서버에서 작동하는 리액트`를 구현하기 위해 당신은 자바스크립트를 사용할 필요가 없다. 당연하게도 피닉스 프레임워크는 자바스크립트 기반으로 작동하는 서버가 아닌 엘릭서 기반의 서버이기 때문이다. 따라서 당신은 엘릭서와 자바스크립트 두가지 언어를 모두 알 필요가 없으며 엘릭서만 알아도 클라와 서버를 모두 만들 수 있다.\\\n\\\nQ. 클라이언트에서 이벤트가 발생할 때마다 서버에게 메시지를 보낸다면 서버에 너무 과부하가 몰리는 건 아닌가 ?\\\nA. 맞는 말이다. 수십만 수백만 클라이언트와 웹소켓으로 연결되어 실시간으로 메시지가 오간다면 이는 필연적으로 과부하를 야기한다. 하지만 피닉스는 엘릭서 기반이고 엘릭서는 높은 수준의 병렬성을 제공한다. 엘릭서의 창시자 호세 발림에 의하면 그는 루비온레일즈로 100개의 서버가 필요했던 환경에서 엘릭서로 이전하고 난 뒤에는 2개의 서버 만으로 감당할 수 있었다고 한다. 이렇게 극적으로 서버 갯수를 줄일 수 있었던 배경에는 엘릭서가 제공하는 높은 수준의 동시성이 있었기 때문이다.\\\n\\\nQ. `서버기반 상태관리`를 제공하는 프레임워크가 피닉스 뿐인가?\\\nA. 아니다. 웬만한 언어별로 `서버기반 상태관리` 라이브러리가 있다. 자세한 내용은 [여기](https://github.com/dbohdan/liveviews)에서 참조할 수 있다\\\n\\\nQ. 그렇다면 굳이 피닉스 프레임워크를 고집할 이유가 없는 것인가?\\\nA. 엄밀히 말하면 `서버기반 상태관리`는 엘릭서만의 전유물은 아니다. 하지만 위에서 말했듯이 엘릭서의 엑터 모델은 모든 언어를 통틀어 최고수준의 동시성을 보장한다. 따라서 서버기반 상태관리에 최적화 되어있는 언어라고 볼 수 있을것이다.\\\n\\\nQ. `서버기반 상태관리`외에 피닉스의 장점이 있는가?\\\nA. 그렇다. 피닉스는 PubSub모델을 제공한다\\\n\\\nQ. PubSub 모델이 뭔가?\\\nA. 어떤 클러스터 내에 누가 접속했고 누가 연결을 끊었는지 알수있는 매커니즘이라고 한다\\\n\\\nQ. 그게 왜 좋은가?\\\nA. 분산 컴퓨팅을 할 수 있기 때문이다. 어떤 서버에서 hello_world라는 함수를 실행하도록 요청받았는데 그런 함수가 구현되어 있지 않다면? 클러스터 내에 연결되어 있는 다른 노드에 대신 수행해 달라고 요청하면 된다. 다시말해 피닉스는 분산 컴퓨팅에 특화되어 있다\n\n---\n\n#### 약간 심화내용\n\nQ. 라이브뷰는 구체적으로 어떻게 구현되었는가 ?\\\nA. 먼저 라이브뷰가 비헤이비어 라는것을 이해해야 한다. 비헤이비어가 낮설다면 일종의 추상 클래스라고 이해해도 좋다. 비헤이비어는 특정한 함수들을 구현할 것을 강제하는데 이런 함수들을 함수 시그니처에 맞추어 구현하는 것이 비헤이비어의 존재 의의이다. 따라서 비헤이비어를 일종의 인터페이스라고 이해해도 좋다. 이렇게 구현된 함수들은 하나의 웹페이지에서 페이지의 상태를 관리하고 렌더링을 수행한다\\\n\\\nQ. 라이브뷰가 비헤이비어이고 비헤이비어가 특정 함수의 구현을 강제하는 것은 알겠다. 그러면 라이브뷰는 어떤 함수의 구현을 강제하는가?\\\nA. 라이브뷰는 웹소켓 기반의 메시지 통신을 구현할 것을 강제한다. 왜냐하면 클라이언트가 서버에게 이벤트의 발생을 알릴 때 웹소켓을 사용하기 때문이다\n",
      "html": "<h3 id=\"엘릭서의-피닉스-프레임워크-faq\">엘릭서의 피닉스 프레임워크 FAQ</h3>\n<p>Q. 피닉스란 무엇인가?<br>\nA. 피닉스는 엘릭서의 웹서버 프레임워크 이다<br>\n<br>\nQ. 피닉스는 누가 만들었나?<br>\nA. 피닉스는 크리스 맥코드가 만들었다. 그는 원래 루비온레일즈로 개발하던 서버 개발자였다. 그는 레일즈에서 <code>서버기반 상태관리</code>를 하고 싶었고 실제로 라이브러리까지 만들어가면서 방법을 연구했다. 하지만 루비라는 언어 및 레일즈라는 프레임워크가 제공하는 동시성 수준으로는 한계가 있었고 여러 상황에서 제대로 작동하지 않았던 것이다. 그는 결국 루비온레일즈를 떠났고 높은 수준의 동시성을 제공해주는 환경을 찾다가 결국 엘릭서 생태계로 이전한다. 그리고 나서 결국 웹서버 프레임워크인 피닉스를 만들게 된 것이다.<br>\n<a href=\"https://news.ycombinator.com/item?id=25105581\">출처 : 해커뉴스 rkangel</a><br>\n<br>\nQ. 피닉스는 어떤 특징이 있는가?<br>\nA. 위에서 언급했던 대로 피닉스는 <code>서버기반 상태관리</code>를 하려다가 좌절한 개발자가 만든 웹 프레임워크다. 따라서 <code>서버기반 상태관리</code> 기능을 제공한다. 이를 피닉스 라이브뷰라고 한다<br>\n<br>\nQ. 웹페이지에서 페이지의 상태를 관리하는 기능은 리액트나 뷰 등의 UI 프레임워크가 제공하던 기능이 아닌가 ?<br>\nA. 그렇다. 하지만 리액트나 뷰 등을 사용하는 것은 너무 많은 지식을 필요로 한다. 기술이 빠르게 바뀌고 새로운 라이브러리가 계속 등장하고 새로운 프레임워크도 계속 등장한다. 이것을 계속 따라가는 것은 피곤한 일이다. 하지만 <code>서버기반 상태관리</code>에 의존하면 이런 기술들을 계속 쫒아갈 필요가 없다. 그저 엘릭서와 피닉스에 대한 지식만으로도 SPA 웹사이트를 만들 수 있는 것이다. 자바스크립트를 단 한줄도 작성할 필요가 없다<br>\n<br>\nQ. 라이브뷰가 어떤 방식으로 <code>서버기반 상태관리 기능</code>을 제공하길래 자바스크립트를 한 줄도 작성할 필요가 없는가?<br>\nA. 라이브뷰는 두가지로 이루어진다. 먼저 <code>템플릿 기반의 html 코드</code>이다. 이것은 다른 프레임워크도 흔하게 제공하는 기능이다. 두번째로 <code>이벤트 처리기</code>이다. 이벤트 처리기란 웹소켓을 통하여 클라이언트와 서버가 교신하는 모델이다. 클라이언트에게 이벤트가 발생하면 그 이벤트는 서버로 전송된다. 서버는 그 이벤트를 받아서 현재 <code>서버에 저장된 상태를 기준으로</code> 재랜더링(re-render)을 수행한다. 재랜더링을 수행하는 과정에서 diff알고리즘으로 이전 랜더링과의 차이점을 분석하고 변경된 사항만을 클라이언트에게 전송한다. 이것이 라이브뷰의 핵심이다<br>\n<br>\nQ. 서버가 상태를 가지고 있고 렌더링도 수행한다면 이건 <code>서버에서 작동하는 리액트</code>가 아닌가?<br>\nA. 그렇게 볼 수도 있다. 다만 소위 말하는 <code>서버에서 작동하는 리액트</code>를 구현하기 위해 당신은 자바스크립트를 사용할 필요가 없다. 당연하게도 피닉스 프레임워크는 자바스크립트 기반으로 작동하는 서버가 아닌 엘릭서 기반의 서버이기 때문이다. 따라서 당신은 엘릭서와 자바스크립트 두가지 언어를 모두 알 필요가 없으며 엘릭서만 알아도 클라와 서버를 모두 만들 수 있다.<br>\n<br>\nQ. 클라이언트에서 이벤트가 발생할 때마다 서버에게 메시지를 보낸다면 서버에 너무 과부하가 몰리는 건 아닌가 ?<br>\nA. 맞는 말이다. 수십만 수백만 클라이언트와 웹소켓으로 연결되어 실시간으로 메시지가 오간다면 이는 필연적으로 과부하를 야기한다. 하지만 피닉스는 엘릭서 기반이고 엘릭서는 높은 수준의 병렬성을 제공한다. 엘릭서의 창시자 호세 발림에 의하면 그는 루비온레일즈로 100개의 서버가 필요했던 환경에서 엘릭서로 이전하고 난 뒤에는 2개의 서버 만으로 감당할 수 있었다고 한다. 이렇게 극적으로 서버 갯수를 줄일 수 있었던 배경에는 엘릭서가 제공하는 높은 수준의 동시성이 있었기 때문이다.<br>\n<br>\nQ. <code>서버기반 상태관리</code>를 제공하는 프레임워크가 피닉스 뿐인가?<br>\nA. 아니다. 웬만한 언어별로 <code>서버기반 상태관리</code> 라이브러리가 있다. 자세한 내용은 <a href=\"https://github.com/dbohdan/liveviews\">여기</a>에서 참조할 수 있다<br>\n<br>\nQ. 그렇다면 굳이 피닉스 프레임워크를 고집할 이유가 없는 것인가?<br>\nA. 엄밀히 말하면 <code>서버기반 상태관리</code>는 엘릭서만의 전유물은 아니다. 하지만 위에서 말했듯이 엘릭서의 엑터 모델은 모든 언어를 통틀어 최고수준의 동시성을 보장한다. 따라서 서버기반 상태관리에 최적화 되어있는 언어라고 볼 수 있을것이다.<br>\n<br>\nQ. <code>서버기반 상태관리</code>외에 피닉스의 장점이 있는가?<br>\nA. 그렇다. 피닉스는 PubSub모델을 제공한다<br>\n<br>\nQ. PubSub 모델이 뭔가?<br>\nA. 어떤 클러스터 내에 누가 접속했고 누가 연결을 끊었는지 알수있는 매커니즘이라고 한다<br>\n<br>\nQ. 그게 왜 좋은가?<br>\nA. 분산 컴퓨팅을 할 수 있기 때문이다. 어떤 서버에서 hello_world라는 함수를 실행하도록 요청받았는데 그런 함수가 구현되어 있지 않다면? 클러스터 내에 연결되어 있는 다른 노드에 대신 수행해 달라고 요청하면 된다. 다시말해 피닉스는 분산 컴퓨팅에 특화되어 있다</p>\n<hr>\n<h4 id=\"약간-심화내용\">약간 심화내용</h4>\n<p>Q. 라이브뷰는 구체적으로 어떻게 구현되었는가 ?<br>\nA. 먼저 라이브뷰가 비헤이비어 라는것을 이해해야 한다. 비헤이비어가 낮설다면 일종의 추상 클래스라고 이해해도 좋다. 비헤이비어는 특정한 함수들을 구현할 것을 강제하는데 이런 함수들을 함수 시그니처에 맞추어 구현하는 것이 비헤이비어의 존재 의의이다. 따라서 비헤이비어를 일종의 인터페이스라고 이해해도 좋다. 이렇게 구현된 함수들은 하나의 웹페이지에서 페이지의 상태를 관리하고 렌더링을 수행한다<br>\n<br>\nQ. 라이브뷰가 비헤이비어이고 비헤이비어가 특정 함수의 구현을 강제하는 것은 알겠다. 그러면 라이브뷰는 어떤 함수의 구현을 강제하는가?<br>\nA. 라이브뷰는 웹소켓 기반의 메시지 통신을 구현할 것을 강제한다. 왜냐하면 클라이언트가 서버에게 이벤트의 발생을 알릴 때 웹소켓을 사용하기 때문이다</p>"
    },
    "url": "/posts/211028_phoenix_qna",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/211028_phoenix_qna.md")
  }
}, children);

});
</script><astro-root uid="2b1HdW"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0"><p class="title">ec2에서 서버리스로의 교체기</p></a></header><time>2021.11.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2b1HdW", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "ec2에서 서버리스로의 교체기",
    "description": "요금과 콜드스타트의 관점에서",
    "publishDate": "2021.11.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "ec2에서-서버리스로의-교체기",
        "text": "ec2에서 서버리스로의 교체기"
      }, {
        "depth": 3,
        "slug": "요약",
        "text": "요약"
      }, {
        "depth": 3,
        "slug": "계기",
        "text": "계기"
      }, {
        "depth": 3,
        "slug": "aws-lambda",
        "text": "aws lambda"
      }, {
        "depth": 2,
        "slug": "서버리스--느린-db요청",
        "text": "서버리스 === 느린 db요청?"
      }, {
        "depth": 3,
        "slug": "콜드스타트-제거가-가능한가",
        "text": "콜드스타트 제거가 가능한가?"
      }, {
        "depth": 3,
        "slug": "서버리스의-또다른문제-db커넥션-제한",
        "text": "서버리스의 또다른문제, db커넥션 제한"
      }, {
        "depth": 3,
        "slug": "결론",
        "text": "결론"
      }],
      "source": "\r\n### ec2에서 서버리스로의 교체기\r\n\r\n### 요약\r\n1. (많은 경우) 람다는 ec2보다 싸다\r\n1. 람다는 한동안 접속하지 않을 시 콜드스타트가 적용된다. 따라서 느릴 수도 있다\r\n\r\n\r\n### 계기\r\n개인 웹서비스를 ec2에서 제공하고 있었다. 월 29,000원 정도 요금이 나오고 있었는데  비용을 더 줄이고 싶었다. 다른 대안을 알아보다가 서버리스의 존재를 알게된다. 솔깃했다. 어떤 개발자가 ec2에서 서버리스로 전환후 비용을 절약할 수 있었다는 말을 듣고 갈아탈 작정을 한다\r\n\r\n### aws lambda\r\naws도 `람다(lambda)`라는 이름으로 서버리스 서비스를 제공하고 있었다. 같은 aws인지 거부감도 없었고 바로 람다로 갈아타려고 했는데 몇가지 걸림돌이 있었다. 중앙 서버가 없으므로 정적파일을 cdn으로 제공하거나 api를 모듈 함수화 해야했는데 대단히 손이 많이가는 작업이었다. 당시 내 서비스는 next.js 기반이었는데 매번 디플로이를 할때마다 수동으로 이런 작업들을 한다는게 엄두가 나지 않았다. 다행이 `서버리스(serverless)`라는 프레임웍이 있었고 정적파일화 && 단일함수화 작업은 자동으로 수행되었다.\\\r\n그렇게 써보니 작동은 잘 되었고 요금은 월 2,500원 가량으로 약 2만원 이상 줄어들었다. 이정도면 요금의 관점에서는 바꾼 보람이 있었다. 그런데 없던 문제가 생겼다. db에서 데이터를 가져오는 시간이 너무 길었다\r\n\r\n## 서버리스 === 느린 db요청?\r\n그 서버리스 함수는 DBaaS의 일종인 [MongoDB Atlas(이하 아틀라스)](https://www.mongodb.com/)에서 데이터를 가져오고 있었다. 그래서 처음에는 이 아틀라스를 의심했지만 문제는 서버리스 함수의 `콜드스타트`였다. 이용자가 거의 없는 내 서비스는 람다의 입장에서 메모리에 함수를 계속 상주시킬 이유가 없었다. 요청이 뜸한 함수는 메모리에서 해제되는데 이 상황을 `게으른 상태(idle state)`라고 하는 모양이다. 게으른 상태에서 누군가 함수를 요청하면 해야할 일이 참 많다. 먼저 함수를 메모리에 적재한다. 이후 함수가 실행될 워커 스레드를 생성한다. 생성된 워커 스레드는 db 서버와 연결이 안되어있는 상태이므로 재연결을 요청한다. 재연결이 허가되면 그제서야 데이터를 요청한다. `여기까지 걸리는 시간은 약 4초였다`. 1초도 느리다고 취급받는 세상에서 4초는 넌센스였다. 역시 싼건 이유가 있었다.\r\n\r\n### 콜드스타트 제거가 가능한가?\r\n`콜드스타트에 한번 걸리면 느려진다`는 불만이 나한테만 있었을까. 당연히 aws측도 인지하고 있었던 문제였다. 그래서 그들은 2019년 12월, 함수가 `게으른 상태(idle state)`로 진입하지 않도록 하는 서비스인 `프로비전드 컨커런시(provisioned concurrency)`를 공개한다. 결론부터 말하면 본인은 이걸 사용하지 않았다. 프로비전드 컨커런시를 알아보던 도중 렘(realm)이라는 더 좋은 솔루션을 발견했다. 나는 이것에 미혹되었고 결국 서버리스 기반의 db통신은 버렸다. 따라서 내가 써보지 않은 프로비전드 컨커런시에 대한 이야기는 어렵다. 다만 납득할 수 있는 가격대였고 괜찮은 해결책으로 보였다. 만일 내가 렘을 몰랐다면 이것을 사용했을지는 분명하다\r\n\r\n### 서버리스의 또다른문제, db커넥션 제한\r\n여기서부터는 소규모 프로젝트에 대한 이야기는 아니다. 그래도 중요한 토픽이다.\\\r\n많은 db가 최대연결 설정을 제한한다. 그런 환경에서 서버리스를 사용할 때 기존에 없던 문제가 생긴다. 서버리스 환경의 각 함수는 각각의 db 세션을 가진다. 고전적인 서버 모델과 다른 이러한 특성은 많은 수의 동시 커넥션을 생성한다. 특히 서버리스 함수가 몇분간 호출되지 않아 `게으른 상태(idle state)`로 진입할 때 db와 커넥션을 종료하지 않는다. 이런 `좀비 커넥션`은 가용 커넥션의 수를 크게 제한한다. 이런 db커넥션 제한 문제도 콜드스타트 못지않은 서버리스의 문제점이었다. 과거형을 쓰는 이유는 해결책이 나왔기 때문이다. AWS의 RDS Proxy는 db연결 전용 프록시 함수를 생성하여 이 함수를 경유하도록 문제를 해결했다. 이렇게 되면 각각의 함수가 db커넥션 상태일 필요가 없어 총 db커넥션 수가 크게 줄어든다.\\\r\ndb프록시의 장점은 이것만이 아니다. 이미 연결되어 있는 db세션을 재활용하는 것이므로 함수가 콜드스타트 되었을 때 서버에 재연결을 시도하는 시간을 없앨 수 있다. 따라서 서버리스의 약점인 느린 레이턴시를 극복할 수 있다\r\n\r\n### 결론\r\n콜드스타트와 db커넥션 제한은 서버리스의 고질적인 문제였다. 하지만 aws는 이에대한 해결책을 제공했다. 이로서 서버리스를 경유한 db참조 문제는 대부분 해결된 셈이므로 서버리스 이용에 큰 부담을 덜 수 있게 되었다.",
      "html": "<h3 id=\"ec2에서-서버리스로의-교체기\">ec2에서 서버리스로의 교체기</h3>\n<h3 id=\"요약\">요약</h3>\n<ol>\n<li>(많은 경우) 람다는 ec2보다 싸다</li>\n<li>람다는 한동안 접속하지 않을 시 콜드스타트가 적용된다. 따라서 느릴 수도 있다</li>\n</ol>\n<h3 id=\"계기\">계기</h3>\n<p>개인 웹서비스를 ec2에서 제공하고 있었다. 월 29,000원 정도 요금이 나오고 있었는데  비용을 더 줄이고 싶었다. 다른 대안을 알아보다가 서버리스의 존재를 알게된다. 솔깃했다. 어떤 개발자가 ec2에서 서버리스로 전환후 비용을 절약할 수 있었다는 말을 듣고 갈아탈 작정을 한다</p>\n<h3 id=\"aws-lambda\">aws lambda</h3>\n<p>aws도 <code>람다(lambda)</code>라는 이름으로 서버리스 서비스를 제공하고 있었다. 같은 aws인지 거부감도 없었고 바로 람다로 갈아타려고 했는데 몇가지 걸림돌이 있었다. 중앙 서버가 없으므로 정적파일을 cdn으로 제공하거나 api를 모듈 함수화 해야했는데 대단히 손이 많이가는 작업이었다. 당시 내 서비스는 next.js 기반이었는데 매번 디플로이를 할때마다 수동으로 이런 작업들을 한다는게 엄두가 나지 않았다. 다행이 <code>서버리스(serverless)</code>라는 프레임웍이 있었고 정적파일화 &amp;&amp; 단일함수화 작업은 자동으로 수행되었다.<br>\n그렇게 써보니 작동은 잘 되었고 요금은 월 2,500원 가량으로 약 2만원 이상 줄어들었다. 이정도면 요금의 관점에서는 바꾼 보람이 있었다. 그런데 없던 문제가 생겼다. db에서 데이터를 가져오는 시간이 너무 길었다</p>\n<h2 id=\"서버리스--느린-db요청\">서버리스 === 느린 db요청?</h2>\n<p>그 서버리스 함수는 DBaaS의 일종인 <a href=\"https://www.mongodb.com/\">MongoDB Atlas(이하 아틀라스)</a>에서 데이터를 가져오고 있었다. 그래서 처음에는 이 아틀라스를 의심했지만 문제는 서버리스 함수의 <code>콜드스타트</code>였다. 이용자가 거의 없는 내 서비스는 람다의 입장에서 메모리에 함수를 계속 상주시킬 이유가 없었다. 요청이 뜸한 함수는 메모리에서 해제되는데 이 상황을 <code>게으른 상태(idle state)</code>라고 하는 모양이다. 게으른 상태에서 누군가 함수를 요청하면 해야할 일이 참 많다. 먼저 함수를 메모리에 적재한다. 이후 함수가 실행될 워커 스레드를 생성한다. 생성된 워커 스레드는 db 서버와 연결이 안되어있는 상태이므로 재연결을 요청한다. 재연결이 허가되면 그제서야 데이터를 요청한다. <code>여기까지 걸리는 시간은 약 4초였다</code>. 1초도 느리다고 취급받는 세상에서 4초는 넌센스였다. 역시 싼건 이유가 있었다.</p>\n<h3 id=\"콜드스타트-제거가-가능한가\">콜드스타트 제거가 가능한가?</h3>\n<p><code>콜드스타트에 한번 걸리면 느려진다</code>는 불만이 나한테만 있었을까. 당연히 aws측도 인지하고 있었던 문제였다. 그래서 그들은 2019년 12월, 함수가 <code>게으른 상태(idle state)</code>로 진입하지 않도록 하는 서비스인 <code>프로비전드 컨커런시(provisioned concurrency)</code>를 공개한다. 결론부터 말하면 본인은 이걸 사용하지 않았다. 프로비전드 컨커런시를 알아보던 도중 렘(realm)이라는 더 좋은 솔루션을 발견했다. 나는 이것에 미혹되었고 결국 서버리스 기반의 db통신은 버렸다. 따라서 내가 써보지 않은 프로비전드 컨커런시에 대한 이야기는 어렵다. 다만 납득할 수 있는 가격대였고 괜찮은 해결책으로 보였다. 만일 내가 렘을 몰랐다면 이것을 사용했을지는 분명하다</p>\n<h3 id=\"서버리스의-또다른문제-db커넥션-제한\">서버리스의 또다른문제, db커넥션 제한</h3>\n<p>여기서부터는 소규모 프로젝트에 대한 이야기는 아니다. 그래도 중요한 토픽이다.<br>\n많은 db가 최대연결 설정을 제한한다. 그런 환경에서 서버리스를 사용할 때 기존에 없던 문제가 생긴다. 서버리스 환경의 각 함수는 각각의 db 세션을 가진다. 고전적인 서버 모델과 다른 이러한 특성은 많은 수의 동시 커넥션을 생성한다. 특히 서버리스 함수가 몇분간 호출되지 않아 <code>게으른 상태(idle state)</code>로 진입할 때 db와 커넥션을 종료하지 않는다. 이런 <code>좀비 커넥션</code>은 가용 커넥션의 수를 크게 제한한다. 이런 db커넥션 제한 문제도 콜드스타트 못지않은 서버리스의 문제점이었다. 과거형을 쓰는 이유는 해결책이 나왔기 때문이다. AWS의 RDS Proxy는 db연결 전용 프록시 함수를 생성하여 이 함수를 경유하도록 문제를 해결했다. 이렇게 되면 각각의 함수가 db커넥션 상태일 필요가 없어 총 db커넥션 수가 크게 줄어든다.<br>\ndb프록시의 장점은 이것만이 아니다. 이미 연결되어 있는 db세션을 재활용하는 것이므로 함수가 콜드스타트 되었을 때 서버에 재연결을 시도하는 시간을 없앨 수 있다. 따라서 서버리스의 약점인 느린 레이턴시를 극복할 수 있다</p>\n<h3 id=\"결론\">결론</h3>\n<p>콜드스타트와 db커넥션 제한은 서버리스의 고질적인 문제였다. 하지만 aws는 이에대한 해결책을 제공했다. 이로서 서버리스를 경유한 db참조 문제는 대부분 해결된 셈이므로 서버리스 이용에 큰 부담을 덜 수 있게 되었다.</p>"
    },
    "url": "/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/211103_ec2%EC%97%90%EC%84%9C_%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4%EB%A1%9C%EC%9D%98_%EA%B5%90%EC%B2%B4%EA%B8%B0.md")
  }
}, children);

});
</script><astro-root uid="Z28szC4"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210505_closure"><p class="title">클로저 (closure)에 대해 정리한 글</p></a></header><time>2021.05.05</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("Z28szC4", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "클로저 (closure)에 대해 정리한 글",
    "description": "상태를 저장하는 함수",
    "publishDate": "2021.05.05",
    "astro": {
      "headers": [{
        "depth": 1,
        "slug": "클로저-closure",
        "text": "클로저 (closure)"
      }],
      "source": "\r\n# 클로저 (closure)\r\n\r\n컴퓨터 과학 분야에서 클로저라는 개념은 란딘이 발표한 논문 `The mechanical evaluation of expressions`에서 처음 등장하지만 자바스크립트를 사용하는데 있어 이 정의는 크게 도움이 되지 않는다.\\\r\n\\\r\n그는 클로저를 다음과 같이 정의하였다\r\n\r\n> 클로저는 환경 파트와 컨트롤 파트로 나뉘어진 람다 표현식이고 이는 표현식을 평가하는데 쓰인다.\\\r\n> (a closure has an environment part and a control part which consists of a list whose sole item is an AE.)\r\n\r\n`(www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Landin64.pdf)`\r\n\\\r\n자바스크립트의 명세인 ECMAScript 스펙에도 클로저는 정의되어 있지 않다. 따라서 자바스크립트 내부에서 정확히 클로저가 무엇을 의미하는지는 알 수 없다.\\\r\n\\\r\n다만 자바스크립트의 가상 머신인 v8에 정의된 클로저 스코프라는 용어를 근거로 정의할 수 있다\r\n\r\n`자바스크립트에서 클로저란 클로저 스코프를 포함한 함수를 뜻한다`\r\n\r\n만일 함수가 클로저 스코프를 포함하지 않아도 클로저가 될 수 있다면 클로저 스코프의 존재 의의가 없어진다.\\\r\n\\\r\n그런 의미에서 이러한 정의는 어느정도의 설득력을 가질 수 있다.\\\r\n\\\r\n위의 정의에 의하면 함수가 가지고 있는 스코프 체인 내부에 클로저 스코프라는 유형의 스코프가 존재할 때 해당 함수는 클로저이다.\\\r\n\\\r\n클로저 스코프란 스코프의 일종인데 V8 엔진 내부에는 총 9종류의 스코프가 존재한다\r\n\r\n```cpp\r\nenum ScopeType {\r\n\r\n    ScopeTypeGlobal = 0,\r\n    ScopeTypeLocal,\r\n    ScopeTypeWith,\r\n    ScopeTypeClosure,\r\n    ScopeTypeCatch,\r\n    ScopeTypeBlock,\r\n    ScopeTypeScript,\r\n    ScopeTypeEval,\r\n    ScopeTypeModule\r\n};\r\n```\r\n\r\n< 참고 : v8/src/debug/debug-scopes.h >\\\r\n\\\r\n이 정보는 enum 형식으로 ScopeIterator 클래스에 정의되어 있다.\\\r\n\\\r\n클로저 스코프는 아래와 같은 상황에서 생성된다.\r\n\r\n```javascript\r\nfunction outer() {\r\n\r\n    var free = 1;\r\n\r\n    function inner() {\r\n        free++;\r\n    };\r\n\r\n    inner();\r\n};\r\n```\r\n\r\n위의 코드는 함수가 중첩되어 있는 상황에서 안쪽에 정의된 함수가 바깥쪽에 정의된 변수를 참조하는 상황이다.\\\r\n\\\r\ninner 함수가 호출될 때 생성되는 스코프 체인은 아래와 같다\r\n\r\n<!-- D:\\project\\리눅스폴더\\myblog_astro\\public\\assets\\blog\\closure -->\r\n![aaa](/assets/blog/closure/1.png)\r\n\r\n위의 스코프에서 Closure (outer) 라고 적혀있는 스코프가 클로저 스코프이다. 변수 free는 클로저 스코프에 의하여 식별된다.\\\r\n\\\r\n클로저 스코프가 생성되기 위한 조건을 정리하면 아래와 같다.\r\n\r\n```\r\n1. 두개의 함수가 있다. 이를 각각 inner 함수와 outer 함수라 하자.\r\n\r\n2. inner 함수는 outer 함수 내부에 정의되어 있다.\r\n\r\n3. inner 함수는 outer함수에 정의된 지역변수를 참조한다.\r\n이 지역변수를 참조하는 과정에서 스코프 체이닝을 수행한다.\r\n스코프 체이닝을 수행하는 과정에서 일련의 스코프를 순차적으로 탐색한다.\r\n\r\n4. 스코프 탐색 도중 outer함수에 정의된 지역변수를 발견한다.\r\n이 스코프의 이름을 클로저 스코프라고 한다\r\n```\r\n\r\n위의 내용을 더 간단하게 정리하면 아래와 같다.\r\n\r\n`함수가 중첩되어 있는 상황에서 안쪽의 함수가 바깥쪽 함수에 정의된 변수를 참조할 때 클로저 스코프라는 이름의 스코프에서 참조한다`\r\n\r\n위의 내용만 듣고보면 클로저의 유용함을 납득하기 어렵다. 위의 정의를 재해석해보면 아래와 같다\r\n\r\n`외부에 상태를 보존하고 있는 함수를 클로저라고 한다`\r\n\r\nouter 함수에 정의된 변수를 상태의 관점에서 접근하면 클로저의 유용함을 이해하기 편하다.\\\r\n\\\r\n클로저는 함수가 호출되는 시점의 상태에 근거하여 리턴값을 반환할 수 있다. 상태라는 개념은 함수 내부에 선언된 변수가 아닌 함수 외부에 선언된 변수에 접근하여 구현할 수 있다.\\\r\n\\\r\n이처럼 함수 외부에 선언되었고 함수 내부에서 접근할 수 있는 변수를 자유변수라고 한다. 함수를 호출할 때 중간 상태값에 근거하여 리턴값을 반환할 수 있다는 데서 자유변수의 의의가 있다.\\\r\n\\\r\n이처럼 자유변수를 특정 함수에서만 접근할 수 있는 패턴은 아래와 같이 작성한다\r\n\r\n```javascript\r\nfunction outer() {\r\n\r\n    var free = 1;\r\n\r\n    return function inner() {\r\n        free++;\r\n    };\r\n};\r\n\r\nconst inner = outer();\r\ninner();\r\n\r\n```\r\n\r\n위의 코드는 outer 함수를 호출하고 리턴값으로 inner 함수의 참조값을 반환받는다. 그리고 반환받은 inner 함수를 호출한다.\\\r\n\\\r\n호출된 inner 함수는 변수 free를 참조하여 값을 1 증가시킨다. 만일 클로저라는 개념이 없다면 위의 코드는 에러를 발생시킨다. 왜냐하면 inner 함수를 호출하는 시점에는 메모리상에 변수 free가 해제되어 존재하지 않기 때문이다. 클로저가 없다고 가정하고 이 상황을 정리하면 아래와 같다\r\n\r\n1. 먼저 outer 함수가 호출된다. outer 함수가 호출되는 시점에 outer 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 내부에는 outer함수 내부에서 선언된 지역 변수인 free가 저장되어 있다.\r\n이 실행 컨텍스트는 메모리 heap 영역에 저장된다.\r\n\r\n1. outer 함수의 루틴이 실행되고 먼저 변수 free에 값 1을 대입한다.\r\n\r\n1. 함수 inner를 리턴한다. 이 때 inner 함수 자체를 리턴하지 않으며 함수가 메모리상에서 정의된 메모리 주소를 리턴한다.\\\r\n이를 참조값(reference) 이라고 한다. 따라서 함수의 참조값을 리턴하기 전 메모리상에 함수에 대한 정보를 저장해 놓는다.\\\r\n이 함수에 대한 정보에는 식별자 해결(identifier resolution) 메커니즘인 스코프 체이 포함되어 있다.\\\r\n스코프 체인은 함수 내부에서 사용되는 변수가 어떤 실행 컨텍스트에 정의되어 있는지 판별하는 식별자 해결 메커니즘이다.\\\r\ninner 함수에서 참조하는 변수 free는 함수 외부에 정의되어 있다.\r\n따라서 이 free 변수를 참조할 수 있는 스코프를 스코프 체인 내부에 저장해 놓는다.\r\n이 스코프의 이름은 outer이다\r\n\r\n1. outer 함수가 리턴되고 outer 함수의 변수를 저장해 놓은 실행 컨텍스트가 메모리에서 해제된다.\r\n이제 outer함수의 실행 컨텍스트에 저장된 변수 free에 접근할 수 없다\r\n\r\n1. inner 함수가 호출된다. inner 함수가 호출되는 시점에 inner 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 생성 과정에서 어떠한 지역 변수가 선언되었는지 확인한다.\r\n확인결과 inner 함수의 내부에는 어떠한 지역 변수도 선언되지 않았다.\r\n따라서 inner 함수의 실행 컨텍스트에는 어떠한 지역 변수도 정의되지 않는다.\r\n\r\n1. inner 함수 내부에서 free++ ; 연산을 수행한다.\r\n이 때 free 변수가 inner함수 내부에 저장되어 있는지 확인하기 위하여 실행 컨텍스트를 참고한다.\r\n확인결과 inner 함수는 정의되지 않았다. 따라서 식별자 해결을 수행하는데 이 때 스코프 체인을 참고한다.\r\n이 스코프체인은 스탭 3에서 생성된 스코프 체인이고 이 스코프 체인에 따르면 free 변수는 outer 함수의 실행 컨텍스트에 저장되어 있다.\r\n따라서 outer 함수의 컨텍스트로 이동하여 해당 변수 값을 참고하려 할 것이다.\r\n\r\n1. 그러나 outer 함수의 실행 컨텍스트는 outer 함수가 종료된 시점에 메모리 상에서 사라졌다.\r\n따라서 outer 함수의 실행 컨텍스트를 참조할 수 없고 결과적으로 free 변수도 참조할 수 없다\r\n\r\n8. 변수를 참조할 수 없으므로 자바스크립트 엔진은 'Uncaught ReferenceError: free is not defined' 에러를 발생시키고 프로그램을 종료한다\r\n그러나 위의 시나리오와는 다르게 free 변수는 정상적으로 참조할 수 있다. 그 이유는 자바스크립트 엔진이 outer 함수의 실행 컨텍스트를 해제하지 않았기 떄문이다.\r\n본래대로라면 함수가 리턴되는 순간 실행 컨텍스트가 해제되지만 몇가지 조건이 갖추어지면 함수가 리턴되는 상황에서도 실행 컨텍스트가 해제되지 않는다. 그 조건은 아래와 같다\r\n```\r\n1. 함수가 리턴할 때 자기자신이 아닌 또다른 함수를 리턴한다.\r\n리턴되는 함수를 inner라 하자.\r\n\r\n2. inner 함수 내부에서 현재 실행중인 함수의 지역변수를 참조한다\r\n```\r\n\r\n위와 같은 조건에서는 함수가 종료되어도 실행 컨텍스트가 해제되지 않는다. 이렇게 되면 outer 변수의 free에 접근할 수 있는 수단은 inner함수를 호출하는 방법 외에는 없다.\\\r\n\\\r\n이로서 inner 함수가 자유변수를 사용할 수 있게 되었고, 오직 inner 함수를 통해서만 자유변수에 접근할 수 있게 되었다. 객체지향 프로그래밍을 공부해 본 사람이라면 이러한 개념이 객체가 제공하는 private 변수와 유사하다는 것을 느꼇을 것이다. 실제로 객체의 private 변수와 클로저의 자유변수는 개념상 거의 유사하고 추구하는 목적은 같다. 이러한 유사성에 대하여 윌리엄스 칼리지의 Daniel Barowy 교수는 다음과 같이 말했다\r\n\r\n> Objects are kind of closure\r\n\r\n`(www.cs.williams.edu/~dbarowy/cs334s18/assets/lecture_2018-04-10.pdf)`\\\r\n\\\r\n그리고 Norman Adams라는 사람은 다음과 같이 말했다\r\n\r\n> Objects are a poor man's closures\\\r\n> (객체란 실력이 부족한 사람들이 사용하는 클로저이다)\r\n\r\n`(Ken Dickey, \"Scheming with Objects\")`\\\r\n\\\r\n반면 소르본 대학의 명예교수인 크리스티안(Christian Queinnec)은 다음과 같이 말했다\r\n\r\n> 많은 사람들이 객체를 두고 실력이 부족한 사람들이 사용하는 클로저라고 말하는데,\\\r\n> 사실 클로저는 실력이 부족한 사람들이 사용하는 객체이다.\\\r\n> (although many people consider objects to be 'poor man's closures, closures are in fact poor man's objects)\r\n\r\n`(people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html)`\\\r\n\\\r\n위의 주장들은 누구의 주장이 옮다는 차원을 넘어서 클로저와 객체가 같은 지향점을 향한다는 점을 시사한다.\\\r\n\\\r\n이 둘은 모두 캡슐화를 지향한다. 그 목표를 달성하는 수단이 다를 뿐이다\\\r\n이런 점을 감안하면 굳이 클로저에 정의에 얽매일 필요가 없다. 자유변수를 하나의 함수에서만 접근할 수 있으면 그 함수는 클로저가 아니더라도 클로저처럼 사용할 수 있다\r\n\r\n```javascript\r\n{\r\n    let free = 0;\r\n\r\n    function func() {\r\n        return ++free;\r\n    }\r\n}\r\n\r\nconsole.log(func());\r\nconsole.log(func());\r\nconsole.log(func());\r\n```\r\n\r\n위의 코드에서 함수 func는 정의상으로는 클로저가 아닐지 몰라도 의미상으로는 클로저와 같다. 왜 그런지 알아보자.\\\r\n\\\r\n함수 func는 자유변수 free를 참조한다. 그리고 변수 free는 func를 통해서만 접근할 수 있다. 왜냐하면 블록 스코프 `{ }` 내부에 정의된 let은 블록 스코프에서 벗어나는 순간 접근이 불가하기 때문이다.\\\r\n\\\r\n본래대로라면 블록스코프 `{ }` 를 벗어난 순간 변수 free는 메모리에서 해제되어 접근할 수 있는 방법이 없어지게 된다. 하지만 블록 스코프를 벗어나는 시점에 지역변수 free를 참조하는 함수가 존재하는지 검사하는데 위의 경우 함수 func가 변수 free를 참조하기 때문에 블록 스코프는 메모리에서 해제되지 않는다. 메모리에서 해제되지는 않지만 블록스코프를 벗어난 지점에서 변수 free에 직접 접근할 수는 없다. 변수 free는 func 함수를 호출하여 참조할 수 있고 그 외에 접근할 수 있는 수단은 없다. 자유변수를 참조할 수 있는 방법을 강제로 제한해 버린다는 측면에서 이 패턴은 클로저로 분류될 수 있다.\\\r\n그렇다면 함수 func는 변수 free를 참조하는 스코프를 클로저스코프로 분류하는가? 아래 그림은 변수 free가 어느 스코프에서 참조되는지를 보여준다\r\n\r\n![aaa](/assets/blog/closure/2.png)\r\n<!-- ![aaa](./img_클로저의_뜻과_존재의의/2.png) -->\r\n\r\n변수 free는 block 스코프에서 참조된다. 그렇다면 변수 free가 클로저스코프에서 참조되지 않으니 함수 func는 클로저가 아니라고 말할 수 있는가? 정의상으로 클로저가 맞던 틀리던 간에 결과적으로 위의 자유변수 free는 객체지향 언어의 private 변수와 같은 개념으로 func함수가 접근할 수 있다. 따라서 클로저스코프를 생성하지는 않으나 함수를 사용하는 입장에서 func함수를 클로저로 보아도 큰 지장은 없다. 클로저의 정의에 얾매일 필요가 없다는 말은 이런 이유 때문이다.\\\r\n\\\r\n주제를 바꿔서 이야기해보자면, 상태를 보존한다는 개념이 구체적으로 어떤 유용함이 있는가? 게임의 예를 들어보자.\\\r\n\\\r\n1:1 격투게임을 구현할 때 각 플레이어의 HP를 감소시키려는 함수를 구현한다. 클로저를 사용하지 않은 상태에서 순수함수의 형태로 구현하면 아래와 같다.\r\n\r\n```javascript\r\nfunction modifyHP(currentHP, damage) {\r\n\r\n    return currentHP - damage;\r\n}\r\n```\r\n\r\n그리고 위의 함수는 아래와 같은 형태로 사용된다\r\n\r\n```javascript\r\nconst damage = getDamage();\r\n\r\nconst currentHP = getCurrentHP();\r\n\r\nconst modifiedHP = modifyHP(currentHP, damage);\r\n\r\nsaveHP(modifiedHP);\r\n```\r\n\r\n만일 상태가 없는 함수를 사용한다면 상태를 불러와 함수를 호출하고 그 리턴값을 다른 함수를 통하여 저장해야 한다\\\r\n\\\r\n반면 HP감소 함수를 클로저로 구현하면 아래와 같다.\r\n\r\n```javascript\r\nfunction hp수정(maxHP) {\r\n\r\n    let currentHP = maxHP;\r\n\r\n    return function (damage) {\r\n        return currentHP - damage;\r\n    }\r\n};\r\n\r\nconst modifyHP = outer(100);\r\n```\r\n\r\n그리고 위의 클로저 함수는 아래와 같이 사용된다.\r\n\r\n```javascript\r\nconst damage = getDamage()\r\n\r\nconst modifiedHP = modifyHP(damage)\r\n```\r\n\r\n내부에서 상태를 저장하므로 외부에서 상태를 불러올 필요가 없고 외부 함수를 통하여 상태를 저장할 필요가 없다.\\\r\n한마디로 클로저는 개발의 편의성을 제공한다.\\\r\n\\\r\n그러나 함수 외부에서 상태를 참조하는 것이 목적이라면 전역 변수를 참조하면 되는데 굳이 외부함수를 만들어 가면서까지 상태를 저장할 필요가 있는지 그 실용성에 의구심을 가질 수가 있다. 위에서 구현한 HP 감소 함수를 전역 변수를 사용하여 구현하면 다음과 같다.\r\n\r\n```javascript\r\nlet currentHP = maxHP;\r\n\r\nfunction modifyHP(damage) {\r\n    return currentHP - damage;\r\n}\r\n```\r\n\r\n위의 코드는 클로저에 비하여 직관적이고 코드량이 적다. 모든 면에서 클로저보다 이상적으로 보이기도 한다.\\\r\n\\\r\n소규모 프로젝트를 진행중이라면 이런 식의 코드 작성이 더 나은 선택일 수도 있다. 하지만 20명 이상이 참여하는 대규모 프론트엔드 프로젝트라면 이야기가 달라질 수도 있다.\\\r\n\\\r\n위에서 정의한 currentHP 변수는 전역변수이기 때문에 나 뿐만이 아닌 다른 모든 팀원이 접근할 수 있다. 따라서 다른 팀원이 currentHP 변수에 접근하지 않아야 한다는 보장이 필요하다. 만일 다른 팀원이 currentHP 변수에 접근하여 내가 의도한 것과 다른 방식으로 변수값을 조정하는 경우 플레이어의 hp가 의도치 않은 상황에 증가하거나 감소하는 상황이 발생하여 게임 진행 자체가 불가능하게 될 것이다. 이와 같은 상황을 방지하려면 전역변수를 생성할 때 마다 다른 모든 팀원을 대상으로 공지사항을 알려줘야 한다.\r\n\r\n> currentHP는 제가 만든 변수이니 이 변수를 사용하지 말라.\\\r\n> currentMP도 접근하지 말라\\\r\n> currentPowerGauge 접근하면 안되고 . . .\r\n\r\n코드를 작성할 수록 전역 변수는 늘어난다. 프로그램 실행중의 에러를 방지하려면 이 모든것을 문서화 해야 할 것이다. 이 자체만으로도 어려운 일이지만 만일 나 뿐만이 아닌 다른 모든 팀원들이 전역 변수를 사용한다면? 접근해서는 안되는 수백개의 전역변수를 기억한 채로 코드를 작성해야 한다. 이것은 고역이고 가능하지도 않다.\\\r\n\\\r\n더 큰 문제는 누군가가 currentHP에 임의로 접근하여 의도치 않은 상황에 hp가 증가하거나 감소하는 경우, 디버깅 대상이 되는 코드는 프로젝트 내의 전체 코드가 된다. 프로그램 내에 어떠한 문맥에서도 전역변수에 접근할 수 있기 때문이다. 이 경우 어떻게 디버깅을 진행할 것인가 ? 팀원 한명한명을 불러서 네가 currentHP에 접근했는지 심문할 것인가? 사실 개발자는 자기가 작성한 코드를 일일이 기억할 수 없다. 따라서 '나는 currentHP를 건드리지 않았는데요' 라고 어떤 개발자가 말했다고 해서 그 사람이 currentHP에 접근하지 않았다는 보장이 없다. 만일 전체 소스코드가 충분히 복잡하고 해당 버그를 재현하기도 어려운 상황이라면 최악의 상황에는 버그를 수정할 수 없는 상황까지 발생할 수 있다.\\\r\n\\\r\n이처럼 전역변수를 사용하는 데서 오는 코스트는 감당하기 어렵다. 개발자들은 디버깅 코스트를 최소화하기 위하여 오랜기간 고민하였고 그 결과 나온 개념이 함수형 프로그래밍 진형에서는 클로저이고 객체지향 프로그래밍 진형에서는 프라이빗(private) 멤버변수라는 형태로 고안되었다. 그 결과 변수가 오용될 수 있는 범위를 극적으로 줄일 수 있게 되었다. 더불어 상태값이 잘못 할당되어 프로그램이 오작동 될 때 디버깅 해야하는 코드 범위를 줄여 막대한 생산성 향상을 이끌어 내었다.\r\n\r\n-- 끝",
      "html": "<h1 id=\"클로저-closure\">클로저 (closure)</h1>\n<p>컴퓨터 과학 분야에서 클로저라는 개념은 란딘이 발표한 논문 <code>The mechanical evaluation of expressions</code>에서 처음 등장하지만 자바스크립트를 사용하는데 있어 이 정의는 크게 도움이 되지 않는다.<br>\n<br>\n그는 클로저를 다음과 같이 정의하였다</p>\n<blockquote>\n<p>클로저는 환경 파트와 컨트롤 파트로 나뉘어진 람다 표현식이고 이는 표현식을 평가하는데 쓰인다.<br>\n(a closure has an environment part and a control part which consists of a list whose sole item is an AE.)</p>\n</blockquote>\n<p><code>(www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Landin64.pdf)</code>\r\n<br>\n자바스크립트의 명세인 ECMAScript 스펙에도 클로저는 정의되어 있지 않다. 따라서 자바스크립트 내부에서 정확히 클로저가 무엇을 의미하는지는 알 수 없다.<br>\n<br>\n다만 자바스크립트의 가상 머신인 v8에 정의된 클로저 스코프라는 용어를 근거로 정의할 수 있다</p>\n<p><code>자바스크립트에서 클로저란 클로저 스코프를 포함한 함수를 뜻한다</code></p>\n<p>만일 함수가 클로저 스코프를 포함하지 않아도 클로저가 될 수 있다면 클로저 스코프의 존재 의의가 없어진다.<br>\n<br>\n그런 의미에서 이러한 정의는 어느정도의 설득력을 가질 수 있다.<br>\n<br>\n위의 정의에 의하면 함수가 가지고 있는 스코프 체인 내부에 클로저 스코프라는 유형의 스코프가 존재할 때 해당 함수는 클로저이다.<br>\n<br>\n클로저 스코프란 스코프의 일종인데 V8 엔진 내부에는 총 9종류의 스코프가 존재한다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum ScopeType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    ScopeTypeGlobal = 0,\r\n    ScopeTypeLocal,\r\n    ScopeTypeWith,\r\n    ScopeTypeClosure,\r\n    ScopeTypeCatch,\r\n    ScopeTypeBlock,\r\n    ScopeTypeScript,\r\n    ScopeTypeEval,\r\n    ScopeTypeModule\r\n};\n</code></pre>\n<p>&lt; 참고 : v8/src/debug/debug-scopes.h ><br>\n<br>\n이 정보는 enum 형식으로 ScopeIterator 클래스에 정의되어 있다.<br>\n<br>\n클로저 스코프는 아래와 같은 상황에서 생성된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function outer() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    var free = 1;\r\n\r\n    function inner() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        free++;\r\n    };\r\n\r\n    inner();\r\n};\n</code></pre>\n<p>위의 코드는 함수가 중첩되어 있는 상황에서 안쪽에 정의된 함수가 바깥쪽에 정의된 변수를 참조하는 상황이다.<br>\n<br>\ninner 함수가 호출될 때 생성되는 스코프 체인은 아래와 같다</p>\n<!-- D:\\project\\리눅스폴더\\myblog_astro\\public\\assets\\blog\\closure -->\n<p><img src=\"/assets/blog/closure/1.png\" alt=\"aaa\"></p>\n<p>위의 스코프에서 Closure (outer) 라고 적혀있는 스코프가 클로저 스코프이다. 변수 free는 클로저 스코프에 의하여 식별된다.<br>\n<br>\n클로저 스코프가 생성되기 위한 조건을 정리하면 아래와 같다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. 두개의 함수가 있다. 이를 각각 inner 함수와 outer 함수라 하자.\r\n\r\n2. inner 함수는 outer 함수 내부에 정의되어 있다.\r\n\r\n3. inner 함수는 outer함수에 정의된 지역변수를 참조한다.\r\n이 지역변수를 참조하는 과정에서 스코프 체이닝을 수행한다.\r\n스코프 체이닝을 수행하는 과정에서 일련의 스코프를 순차적으로 탐색한다.\r\n\r\n4. 스코프 탐색 도중 outer함수에 정의된 지역변수를 발견한다.\r\n이 스코프의 이름을 클로저 스코프라고 한다\n</code></pre>\n<p>위의 내용을 더 간단하게 정리하면 아래와 같다.</p>\n<p><code>함수가 중첩되어 있는 상황에서 안쪽의 함수가 바깥쪽 함수에 정의된 변수를 참조할 때 클로저 스코프라는 이름의 스코프에서 참조한다</code></p>\n<p>위의 내용만 듣고보면 클로저의 유용함을 납득하기 어렵다. 위의 정의를 재해석해보면 아래와 같다</p>\n<p><code>외부에 상태를 보존하고 있는 함수를 클로저라고 한다</code></p>\n<p>outer 함수에 정의된 변수를 상태의 관점에서 접근하면 클로저의 유용함을 이해하기 편하다.<br>\n<br>\n클로저는 함수가 호출되는 시점의 상태에 근거하여 리턴값을 반환할 수 있다. 상태라는 개념은 함수 내부에 선언된 변수가 아닌 함수 외부에 선언된 변수에 접근하여 구현할 수 있다.<br>\n<br>\n이처럼 함수 외부에 선언되었고 함수 내부에서 접근할 수 있는 변수를 자유변수라고 한다. 함수를 호출할 때 중간 상태값에 근거하여 리턴값을 반환할 수 있다는 데서 자유변수의 의의가 있다.<br>\n<br>\n이처럼 자유변수를 특정 함수에서만 접근할 수 있는 패턴은 아래와 같이 작성한다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function outer() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    var free = 1;\r\n\r\n    return function inner() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        free++;\r\n    };\r\n};\r\n\r\nconst inner = outer();\r\ninner();\r\n\n</code></pre>\n<p>위의 코드는 outer 함수를 호출하고 리턴값으로 inner 함수의 참조값을 반환받는다. 그리고 반환받은 inner 함수를 호출한다.<br>\n<br>\n호출된 inner 함수는 변수 free를 참조하여 값을 1 증가시킨다. 만일 클로저라는 개념이 없다면 위의 코드는 에러를 발생시킨다. 왜냐하면 inner 함수를 호출하는 시점에는 메모리상에 변수 free가 해제되어 존재하지 않기 때문이다. 클로저가 없다고 가정하고 이 상황을 정리하면 아래와 같다</p>\n<ol>\n<li>\n<p>먼저 outer 함수가 호출된다. outer 함수가 호출되는 시점에 outer 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 내부에는 outer함수 내부에서 선언된 지역 변수인 free가 저장되어 있다.\r\n이 실행 컨텍스트는 메모리 heap 영역에 저장된다.</p>\n</li>\n<li>\n<p>outer 함수의 루틴이 실행되고 먼저 변수 free에 값 1을 대입한다.</p>\n</li>\n<li>\n<p>함수 inner를 리턴한다. 이 때 inner 함수 자체를 리턴하지 않으며 함수가 메모리상에서 정의된 메모리 주소를 리턴한다.<br>\n이를 참조값(reference) 이라고 한다. 따라서 함수의 참조값을 리턴하기 전 메모리상에 함수에 대한 정보를 저장해 놓는다.<br>\n이 함수에 대한 정보에는 식별자 해결(identifier resolution) 메커니즘인 스코프 체이 포함되어 있다.<br>\n스코프 체인은 함수 내부에서 사용되는 변수가 어떤 실행 컨텍스트에 정의되어 있는지 판별하는 식별자 해결 메커니즘이다.<br>\ninner 함수에서 참조하는 변수 free는 함수 외부에 정의되어 있다.\r\n따라서 이 free 변수를 참조할 수 있는 스코프를 스코프 체인 내부에 저장해 놓는다.\r\n이 스코프의 이름은 outer이다</p>\n</li>\n<li>\n<p>outer 함수가 리턴되고 outer 함수의 변수를 저장해 놓은 실행 컨텍스트가 메모리에서 해제된다.\r\n이제 outer함수의 실행 컨텍스트에 저장된 변수 free에 접근할 수 없다</p>\n</li>\n<li>\n<p>inner 함수가 호출된다. inner 함수가 호출되는 시점에 inner 함수의 실행 컨텍스트가 생성된다.\r\n실행 컨텍스트 생성 과정에서 어떠한 지역 변수가 선언되었는지 확인한다.\r\n확인결과 inner 함수의 내부에는 어떠한 지역 변수도 선언되지 않았다.\r\n따라서 inner 함수의 실행 컨텍스트에는 어떠한 지역 변수도 정의되지 않는다.</p>\n</li>\n<li>\n<p>inner 함수 내부에서 free++ ; 연산을 수행한다.\r\n이 때 free 변수가 inner함수 내부에 저장되어 있는지 확인하기 위하여 실행 컨텍스트를 참고한다.\r\n확인결과 inner 함수는 정의되지 않았다. 따라서 식별자 해결을 수행하는데 이 때 스코프 체인을 참고한다.\r\n이 스코프체인은 스탭 3에서 생성된 스코프 체인이고 이 스코프 체인에 따르면 free 변수는 outer 함수의 실행 컨텍스트에 저장되어 있다.\r\n따라서 outer 함수의 컨텍스트로 이동하여 해당 변수 값을 참고하려 할 것이다.</p>\n</li>\n<li>\n<p>그러나 outer 함수의 실행 컨텍스트는 outer 함수가 종료된 시점에 메모리 상에서 사라졌다.\r\n따라서 outer 함수의 실행 컨텍스트를 참조할 수 없고 결과적으로 free 변수도 참조할 수 없다</p>\n</li>\n<li>\n<p>변수를 참조할 수 없으므로 자바스크립트 엔진은 ‘Uncaught ReferenceError: free is not defined’ 에러를 발생시키고 프로그램을 종료한다\r\n그러나 위의 시나리오와는 다르게 free 변수는 정상적으로 참조할 수 있다. 그 이유는 자바스크립트 엔진이 outer 함수의 실행 컨텍스트를 해제하지 않았기 떄문이다.\r\n본래대로라면 함수가 리턴되는 순간 실행 컨텍스트가 해제되지만 몇가지 조건이 갖추어지면 함수가 리턴되는 상황에서도 실행 컨텍스트가 해제되지 않는다. 그 조건은 아래와 같다</p>\n</li>\n</ol>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. 함수가 리턴할 때 자기자신이 아닌 또다른 함수를 리턴한다.\r\n리턴되는 함수를 inner라 하자.\r\n\r\n2. inner 함수 내부에서 현재 실행중인 함수의 지역변수를 참조한다\n</code></pre>\n<p>위와 같은 조건에서는 함수가 종료되어도 실행 컨텍스트가 해제되지 않는다. 이렇게 되면 outer 변수의 free에 접근할 수 있는 수단은 inner함수를 호출하는 방법 외에는 없다.<br>\n<br>\n이로서 inner 함수가 자유변수를 사용할 수 있게 되었고, 오직 inner 함수를 통해서만 자유변수에 접근할 수 있게 되었다. 객체지향 프로그래밍을 공부해 본 사람이라면 이러한 개념이 객체가 제공하는 private 변수와 유사하다는 것을 느꼇을 것이다. 실제로 객체의 private 변수와 클로저의 자유변수는 개념상 거의 유사하고 추구하는 목적은 같다. 이러한 유사성에 대하여 윌리엄스 칼리지의 Daniel Barowy 교수는 다음과 같이 말했다</p>\n<blockquote>\n<p>Objects are kind of closure</p>\n</blockquote>\n<p><code>(www.cs.williams.edu/~dbarowy/cs334s18/assets/lecture_2018-04-10.pdf)</code><br>\n<br>\n그리고 Norman Adams라는 사람은 다음과 같이 말했다</p>\n<blockquote>\n<p>Objects are a poor man’s closures<br>\n(객체란 실력이 부족한 사람들이 사용하는 클로저이다)</p>\n</blockquote>\n<p><code>(Ken Dickey, \"Scheming with Objects\")</code><br>\n<br>\n반면 소르본 대학의 명예교수인 크리스티안(Christian Queinnec)은 다음과 같이 말했다</p>\n<blockquote>\n<p>많은 사람들이 객체를 두고 실력이 부족한 사람들이 사용하는 클로저라고 말하는데,<br>\n사실 클로저는 실력이 부족한 사람들이 사용하는 객체이다.<br>\n(although many people consider objects to be ‘poor man’s closures, closures are in fact poor man’s objects)</p>\n</blockquote>\n<p><code>(people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html)</code><br>\n<br>\n위의 주장들은 누구의 주장이 옮다는 차원을 넘어서 클로저와 객체가 같은 지향점을 향한다는 점을 시사한다.<br>\n<br>\n이 둘은 모두 캡슐화를 지향한다. 그 목표를 달성하는 수단이 다를 뿐이다<br>\n이런 점을 감안하면 굳이 클로저에 정의에 얽매일 필요가 없다. 자유변수를 하나의 함수에서만 접근할 수 있으면 그 함수는 클로저가 아니더라도 클로저처럼 사용할 수 있다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    let free = 0;\r\n\r\n    function func() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        return ++free;\r\n    }\r\n}\r\n\r\nconsole.log(func());\r\nconsole.log(func());\r\nconsole.log(func());\n</code></pre>\n<p>위의 코드에서 함수 func는 정의상으로는 클로저가 아닐지 몰라도 의미상으로는 클로저와 같다. 왜 그런지 알아보자.<br>\n<br>\n함수 func는 자유변수 free를 참조한다. 그리고 변수 free는 func를 통해서만 접근할 수 있다. 왜냐하면 블록 스코프 <code>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000 }</code> 내부에 정의된 let은 블록 스코프에서 벗어나는 순간 접근이 불가하기 때문이다.<br>\n<br>\n본래대로라면 블록스코프 <code>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000 }</code> 를 벗어난 순간 변수 free는 메모리에서 해제되어 접근할 수 있는 방법이 없어지게 된다. 하지만 블록 스코프를 벗어나는 시점에 지역변수 free를 참조하는 함수가 존재하는지 검사하는데 위의 경우 함수 func가 변수 free를 참조하기 때문에 블록 스코프는 메모리에서 해제되지 않는다. 메모리에서 해제되지는 않지만 블록스코프를 벗어난 지점에서 변수 free에 직접 접근할 수는 없다. 변수 free는 func 함수를 호출하여 참조할 수 있고 그 외에 접근할 수 있는 수단은 없다. 자유변수를 참조할 수 있는 방법을 강제로 제한해 버린다는 측면에서 이 패턴은 클로저로 분류될 수 있다.<br>\n그렇다면 함수 func는 변수 free를 참조하는 스코프를 클로저스코프로 분류하는가? 아래 그림은 변수 free가 어느 스코프에서 참조되는지를 보여준다</p>\n<p><img src=\"/assets/blog/closure/2.png\" alt=\"aaa\"></p>\n<!-- ![aaa](./img_클로저의_뜻과_존재의의/2.png) -->\n<p>변수 free는 block 스코프에서 참조된다. 그렇다면 변수 free가 클로저스코프에서 참조되지 않으니 함수 func는 클로저가 아니라고 말할 수 있는가? 정의상으로 클로저가 맞던 틀리던 간에 결과적으로 위의 자유변수 free는 객체지향 언어의 private 변수와 같은 개념으로 func함수가 접근할 수 있다. 따라서 클로저스코프를 생성하지는 않으나 함수를 사용하는 입장에서 func함수를 클로저로 보아도 큰 지장은 없다. 클로저의 정의에 얾매일 필요가 없다는 말은 이런 이유 때문이다.<br>\n<br>\n주제를 바꿔서 이야기해보자면, 상태를 보존한다는 개념이 구체적으로 어떤 유용함이 있는가? 게임의 예를 들어보자.<br>\n<br>\n1:1 격투게임을 구현할 때 각 플레이어의 HP를 감소시키려는 함수를 구현한다. 클로저를 사용하지 않은 상태에서 순수함수의 형태로 구현하면 아래와 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function modifyHP(currentHP, damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    return currentHP - damage;\r\n}\n</code></pre>\n<p>그리고 위의 함수는 아래와 같은 형태로 사용된다</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const damage = getDamage();\r\n\r\nconst currentHP = getCurrentHP();\r\n\r\nconst modifiedHP = modifyHP(currentHP, damage);\r\n\r\nsaveHP(modifiedHP);\n</code></pre>\n<p>만일 상태가 없는 함수를 사용한다면 상태를 불러와 함수를 호출하고 그 리턴값을 다른 함수를 통하여 저장해야 한다<br>\n<br>\n반면 HP감소 함수를 클로저로 구현하면 아래와 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">function hp수정(maxHP) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    let currentHP = maxHP;\r\n\r\n    return function (damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n        return currentHP - damage;\r\n    }\r\n};\r\n\r\nconst modifyHP = outer(100);\n</code></pre>\n<p>그리고 위의 클로저 함수는 아래와 같이 사용된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">const damage = getDamage()\r\n\r\nconst modifiedHP = modifyHP(damage)\n</code></pre>\n<p>내부에서 상태를 저장하므로 외부에서 상태를 불러올 필요가 없고 외부 함수를 통하여 상태를 저장할 필요가 없다.<br>\n한마디로 클로저는 개발의 편의성을 제공한다.<br>\n<br>\n그러나 함수 외부에서 상태를 참조하는 것이 목적이라면 전역 변수를 참조하면 되는데 굳이 외부함수를 만들어 가면서까지 상태를 저장할 필요가 있는지 그 실용성에 의구심을 가질 수가 있다. 위에서 구현한 HP 감소 함수를 전역 변수를 사용하여 구현하면 다음과 같다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">let currentHP = maxHP;\r\n\r\nfunction modifyHP(damage) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    return currentHP - damage;\r\n}\n</code></pre>\n<p>위의 코드는 클로저에 비하여 직관적이고 코드량이 적다. 모든 면에서 클로저보다 이상적으로 보이기도 한다.<br>\n<br>\n소규모 프로젝트를 진행중이라면 이런 식의 코드 작성이 더 나은 선택일 수도 있다. 하지만 20명 이상이 참여하는 대규모 프론트엔드 프로젝트라면 이야기가 달라질 수도 있다.<br>\n<br>\n위에서 정의한 currentHP 변수는 전역변수이기 때문에 나 뿐만이 아닌 다른 모든 팀원이 접근할 수 있다. 따라서 다른 팀원이 currentHP 변수에 접근하지 않아야 한다는 보장이 필요하다. 만일 다른 팀원이 currentHP 변수에 접근하여 내가 의도한 것과 다른 방식으로 변수값을 조정하는 경우 플레이어의 hp가 의도치 않은 상황에 증가하거나 감소하는 상황이 발생하여 게임 진행 자체가 불가능하게 될 것이다. 이와 같은 상황을 방지하려면 전역변수를 생성할 때 마다 다른 모든 팀원을 대상으로 공지사항을 알려줘야 한다.</p>\n<blockquote>\n<p>currentHP는 제가 만든 변수이니 이 변수를 사용하지 말라.<br>\ncurrentMP도 접근하지 말라<br>\ncurrentPowerGauge 접근하면 안되고 …</p>\n</blockquote>\n<p>코드를 작성할 수록 전역 변수는 늘어난다. 프로그램 실행중의 에러를 방지하려면 이 모든것을 문서화 해야 할 것이다. 이 자체만으로도 어려운 일이지만 만일 나 뿐만이 아닌 다른 모든 팀원들이 전역 변수를 사용한다면? 접근해서는 안되는 수백개의 전역변수를 기억한 채로 코드를 작성해야 한다. 이것은 고역이고 가능하지도 않다.<br>\n<br>\n더 큰 문제는 누군가가 currentHP에 임의로 접근하여 의도치 않은 상황에 hp가 증가하거나 감소하는 경우, 디버깅 대상이 되는 코드는 프로젝트 내의 전체 코드가 된다. 프로그램 내에 어떠한 문맥에서도 전역변수에 접근할 수 있기 때문이다. 이 경우 어떻게 디버깅을 진행할 것인가 ? 팀원 한명한명을 불러서 네가 currentHP에 접근했는지 심문할 것인가? 사실 개발자는 자기가 작성한 코드를 일일이 기억할 수 없다. 따라서 ‘나는 currentHP를 건드리지 않았는데요’ 라고 어떤 개발자가 말했다고 해서 그 사람이 currentHP에 접근하지 않았다는 보장이 없다. 만일 전체 소스코드가 충분히 복잡하고 해당 버그를 재현하기도 어려운 상황이라면 최악의 상황에는 버그를 수정할 수 없는 상황까지 발생할 수 있다.<br>\n<br>\n이처럼 전역변수를 사용하는 데서 오는 코스트는 감당하기 어렵다. 개발자들은 디버깅 코스트를 최소화하기 위하여 오랜기간 고민하였고 그 결과 나온 개념이 함수형 프로그래밍 진형에서는 클로저이고 객체지향 프로그래밍 진형에서는 프라이빗(private) 멤버변수라는 형태로 고안되었다. 그 결과 변수가 오용될 수 있는 범위를 극적으로 줄일 수 있게 되었다. 더불어 상태값이 잘못 할당되어 프로그램이 오작동 될 때 디버깅 해야하는 코드 범위를 줄여 막대한 생산성 향상을 이끌어 내었다.</p>\n<p>— 끝</p>"
    },
    "url": "/posts/210505_closure",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/210505_closure.md")
  }
}, children);

});
</script><astro-root uid="Q1InT"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95"><p class="title">크로미움에서 requestAnimationFrame이 수행되는 과정</p></a></header><time>2021.05.03</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("Q1InT", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "크로미움에서 requestAnimationFrame이 수행되는 과정",
    "description": "rAF API의 작동과정",
    "publishDate": "2021.05.03",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "크로미움에서-requestanimationframe이-수행되는-과정",
        "text": "크로미움에서 requestAnimationFrame이 수행되는 과정"
      }, {
        "depth": 4,
        "slug": "참고",
        "text": "참고"
      }],
      "source": "\r\n### 크로미움에서 requestAnimationFrame이 수행되는 과정\r\n\r\n( 최종수정일 : 2021년 5월 3일 AM 9:29)\r\n\r\nrequestAnimationFrame 함수 줄여서 rAF를 이해하려면 rAF가 만들어진 배경을 이해하는 것이 좋다.\r\n\r\nrAF가 존재하기 전 웹페이지에서 매끄러운 애니메이션을 구현할 때는 setInterval 함수에 의존해야 했다.\r\n\r\n하지만 setInterval 함수는 크게 3가지 문제가 존재했다.\r\n\r\n첫째로 이 함수는 5회 이상 반복되는 주기부터 정밀도가 최소 4ms로 강제 조정된다.\r\n\r\n유저가 setInterval의 timeout주기를 1ms로 설정한다 하여도 5회 이상 반복되는 시점부터는 4ms로 강제 조정된다. 이를 타이머의 클램핑 기능이라고 한다.\r\n\r\n이는 WHATWG HTML Living Standard에 명시되어 있다\r\n\r\n> If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\r\n`(https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval)`\r\n\r\n그리고 이러한 명세는 크로미움에 반영되어 있다\r\n\r\n> // Step 11 of the algorithm at https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html requires that a timeout less than 4ms is increased to 4ms when the nesting level is greater than 5.\\\r\n> \\\r\n> constexpr int kMaxTimerNestingLevel = 5;\\\r\n> constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.cc)`\r\n\r\n이러한 조치는 setInterval 함수보다 낮은 우선순위를 가진 테스크들의 기아 상태를 방지하기 위하여 고안되었다.\r\n\r\n이러한 클램핑 기능은 기아 상태를 방지하는 차원에서는 효율적이지만 정밀한 타이머를 구현하는 데는 방해거리가 된다.\r\n\r\n두번째 문제 역시 정밀도 문제인데, setInterval의 두번째 인자인 timeout은 소수점 이하를 무시하고 정수로 해석된다.\r\n\r\n예를 들어서 60프레임을 구현하려는 의도로 1초를 60으로 나눈 16.666ms 를 setInterval의 timeout 인자로 넣는다 하더라도 실제 작동시에는 16ms로 인식된다.\r\n\r\n자바스크립트 코드 상에서 에러 메시지를 내뱉지는 않지만 블링크 엔진 내부에서는 소수점 이하가 무시된 값인 16으로 인자값을 받게 되기 때문이다.\r\n\r\n그 이유는 setInterval의 구현체의 timeout 인자 타입이 int이기 때문이다.\r\n\r\n다음은 setTimeout 구현체의 매개변수별 타입이다.\r\n\r\n```cpp\r\nint WindowOrWorkerGlobalScope::setInterval(\r\n\r\n    ScriptState* script_state,\r\n\r\n    EventTarget& event_target,\r\n\r\n    V8Function* handler,\r\n\r\n    int timeout,\r\n\r\n    const HeapVector<ScriptValue>& arguments)\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)`\r\n\r\n\r\n위에서 4번째 값이 setTimeout의 두번째 인자인 timeout 값이다.\r\n\r\n이처럼 소수점이 무시되기 때문에 1ms 미만의 정밀도를 제어할 수 없다.\r\n\r\n세번째로 setInterval 함수는 모니터의 주사율에 근거하여 프레임을 갱신할 수가 없다.\r\n\r\nrAF가 재정되기 이전의 대부분의 모니터는 주사율이 60Hz로 고정되어 있었다. 하지만 최근 출시되는 모니터는 75Hz, 120Hz, 144Hz, 240Hz로 주사율이 다양하다.\r\n\r\n가령 매끄러운 애니메이션을 위해 60프레임을 염두해 두고 16.66ms 단위로 화면을 갱신하기로 했다고 가정해 보자. 이 경우 코드는 아래와 같이 된다.\r\n\r\n```javascript\r\n// 두번째 매개변수의 소수점 이하를 무시하기 때문에 16.66을 반올림한 값을 대입한다\r\n\r\nsetInterval(animateFunction, 17) ;\r\n```\r\n\r\n위의 함수를 실행할 경우 가장 이상적인 시나리오대로 60프레임이 구현된다고 하더라도 주사율이 60Hz을 초과하는 모니터에서 그 이상의 프레임을 보장하기 어렵다.\r\n\r\n그렇다고 240Hz에 맞추어 4.16ms 단위로 화면을 갱신한다면 240hz미만의 모니터에서는 자원의 낭비가 심해진다.\r\n\r\n결국 모니터 주사율에 적응적으로 변화하는 갱신은 setInterval 함수로 해결할 수 없다.\r\n\r\n이와 같은 문제로 인하여 더욱 정밀한 프레임 갱신 방법론에 대한 요구가 있었고 그 결과로 requestAnimationFrame 함수가 탄생하였다.\r\n\r\nrequestAnimationFrame 은 위의 3가지 문제를 처리해 준다. 즉 다음과 같다.\r\n\r\n첫째로 타이머 수치가 임의로 클램핑되지 않는다.\r\n\r\n둘째로 정밀도를 나노초 단위로 제어가 가능하다.\r\n\r\n셋째로 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.\r\n\r\n모니터의 주사율에 근거하여 프레임이 가변적으로 갱신된다는 점은 흥미롭다. 실제로 그렇게 작동하는지 직접 확인해 보겠다.\r\n\r\n```html\r\n<html>\r\n   <body>\r\n      <script>\r\n         (()=>{\r\n         \tlet prev = performance.now() ;\r\n         \tlet cnt = 0 ; \r\n         \tfunction animateFunc(){\r\n         \r\n         \t\tlet curr = performance.now() ;\r\n         \t\tconsole.log(`${curr - prev} ms`) ;\r\n         \t\tprev = curr ;\r\n         \t\t\r\n         \t\tif(++cnt < 100) {\r\n         \t\t\trequestAnimationFrame(animateFunc) ; \r\n         \t\t}\r\n         \t}\r\n         \trequestAnimationFrame(animateFunc);\r\n         })()\r\n      <\/script>\r\n   </body>\r\n</html>\r\n```\r\n\r\n위의 코드는 rAF를 반복 호출한다. 그리고 이전에 호출된 rAF 콜백함수와의 인터벌을 console.log로 출력한다\r\n\r\n위의 코드를 먼저 아래의 60Hz 모니터에서 실행해 보았다\r\n\r\n![aaa](/assets/blog/210523_raf/raf1.png)\r\n\r\n결과는 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf2.png)\r\n\r\n값은 대체로 16.6ms에 근사한 값을 보여준다. 사실 실행한 컴퓨터의 CPU 성능이 좋지 않아서 오차가 비교적 크게 발생하였다. 이 오차는 단일 프로세서의 처리 속도가 빠를수록 감소한다.\r\n\r\n장비를 바꾸어서 144Hz 모니터에서 같은 코드를 수행하였다.\r\n\r\n![aaa](/assets/blog/210523_raf/raf3.png)\r\n\r\n결과는 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf4.png)\r\n\r\n144Hz는 1초에 144회 화면을 갱신하므로 1프레임이 갱신되는 주기는 약 6.94ms이다.\r\n\r\n위의 수치는 약 6.94ms에 근사한 수치를 보여준다. 각 프레임별로 오차가 적은 이유는 CPU의 성능이 앞선 60Hz 테스트에서 사용한 CPU보다 빠르기 때문이다.\r\n\r\n이처럼 모니터 주사율에 가변적으로 rAF 호출 주기가 변경되는 이유는 rAF 함수가 모니터에서 제공하는 vsync pulse를 기반으로 작동하기 때문이다.\r\n\r\nvertical sync pulse, 줄여서 vsync pulse는 모니터에서 제공하는 전기적 신호인데 이 신호는 모니터가 화면상에 새로운 픽셀을 뿌리는 주기와 연관이 있다.\r\n\r\n모니터는 화면상에 새로운 픽셀을 드로잉하고 다음번 픽셀의 드로잉을 준비하기 시작할 때 vertical sync pulse를 생성한다. 예를 들어 60Hz 주사율의 모니터는 1초에 60번 새로운 화면을 갱신하는데 이 갱신 주기는 일정하다. 따라서 1초를 60으로 나눈값인 16.66ms 간격으로 vsync pulse를 생성한다.\r\n\r\n이 전기적 신호는 그래픽카드가 감지할 수 있다. 이 감지된 신호를 기반으로 requestAnimationFrame의 콜백함수가 호출되기 때문에 타이머 수치가 클램핑되지 않고, 나노세컨드 단위로 정밀하며, 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.\r\n\r\n이러한 프로세스가 구체적으로 어떻게 구현되어 있을지 추측해 보자.\r\n\r\n크로미움에서는 탭을 하나 생성할 때 마다 렌더러 프로세스가 한개씩 생성된다. 각 탭은 하나의 렌더러 프로세스를 가지고 있다.\r\n\r\n이 렌더러 프로세스는 탭 안에 보이는 화면을 렌더링하는 역할을 수행한다.\r\n\r\n그러니 이 렌더러 프로세스 내부에 vsync pulse를 감지하는 스레드가 존재한다고 생각할 수 있다.\r\n\r\nvsync 스레드가 vsync를 감지하여 자바스크립트를 실행하는 메인 스레드에게 신호를 전파하고 이 신호를 받은 메인 스레드가 requestAnimationFrame의 콜백함수를 호출하는 방식으로 수행된다고 생각할 수 있다.\r\n\r\n그러나 렌더러 프로세스는 샌드박스화 되어 있으므로 vsync 신호를 보내는 gpu 디바이스에 직접 억세스할 수 없다.\r\n\r\n샌드박스란 일종의 제한된 환경이며 샌드박스 안에 존재하는 프로세스는 CPU와 메모리를 제외한 다른 리소스에 접근할 수 없다.\r\n\r\n따라서 렌더러 프로세스는 샌드박스 환경 밖에 있는 GPU 프로세스와의 IPC를 통하여 vsync신호를 전달받게 된다. 도식화하면 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf5.png)\r\n\r\n크로미움 브라우저 내부의 GPU 프로세스는 vsync 스레드를 가지고 있다. 이 스레드는 OS가 제공하는 vsync API를 이용하여 vsync 주기를 감지한다.\r\n\r\n예를들어 windows OS의 경우 vsync API는 IDXGIOutput 클래스가 제공하는데 이 클래스가 제공하는 waitForVBlank 등의 메소드를 사용하여 vsync 주기를 감지한다. 아래 코드는 windows용 vsync 스레드가 v싱크 신호 감지에 사용하는 메소드이다.\r\n\r\n```cpp\r\nvoid VSyncThreadWin::WaitForVSync() {\r\n\r\n  // .. 생략\r\n  const HMONITOR monitor = MonitorFromWindow(nullptr, MONITOR_DEFAULTTOPRIMARY);\r\n\r\n  if (primary_monitor_ != monitor) {\r\n    primary_monitor_ = monitor;\r\n    primary_output_ = DXGIOutputFromMonitor(monitor, d3d11_device_);\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  const bool wait_for_vblank_succeeded =\r\n      primary_output_ && SUCCEEDED(primary_output_->WaitForVBlank());\r\n\r\n  // .. 생략\r\n\r\n  if (!wait_for_vblank_succeeded ||\r\n      wait_for_vblank_elapsed_time < kVBlankIntervalThreshold) {\r\n    Sleep(static_cast<DWORD>(vsync_interval.InMillisecondsRoundedUp()));\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  if (!observers_.empty()) {\r\n    vsync_thread_.task_runner()->PostTask(\r\n        FROM_HERE,\r\n        base::BindOnce(&VSyncThreadWin::WaitForVSync, base::Unretained(this)));\r\n    const base::TimeTicks vsync_time = base::TimeTicks::Now();\r\n    for (auto* obs : observers_)\r\n      obs->OnVSync(vsync_time, vsync_interval);\r\n  } else {\r\n    is_idle_ = true;\r\n  }\r\n}\r\n```\r\n\r\n`< 참조 : ui/gl/vsync_thread_win.cc>`\r\n\r\n위의 코드에서 DXGIOutputFromMonitor함수는 프라이머리로 사용중인 모니터의 정보를 가져온다. 그리고 해당 모니터를 대상으로 WaitForVBlank 메소드를 호출하여 v싱크 주기를 감시한다. 만일 v싱크 주기가 감지된다면 옵저버인 DirectCompositionChildSurfaceWin 클래스의 OnVSync 메소드가 트리거되고 프레임 생성 파이프라인을 시작한다. 이 파이프라인의 시작신호를 BeginFrame이라고 한다.\r\n\r\n크로미움은 BeginFrame을 다음과 같이 정의하고 있다\r\n\r\n> BeginFrame is the mechanism that tells us that now is a good time to start making a frame\\\r\n> (BeginFrame은 메커니즘인데 이 메커니즘은 지금이 프레임의 생성을 시작하는 좋은 타이밍이라는 것을 알려준다.)\r\n\r\n`(cc/scheduler/scheduler.cc)`\r\n\r\nGPU 프로세스는 렌더러 프로세스에게 BeginFrame 신호를 보낸다. 이 때 BeginFrame은 하나의 테스크로서 간주되며 스케줄러에 의해 스케줄링된다. 이 BeginFrame 신호는 렌더러 프로세스의 impl 스레드에게 전달된다.\r\n\r\n사실 렌더러 프로세스에는 크게 2가지의 스레드가 존재한다. 메인스레드와 impl 스레드가 그것인데 각각의 스레드는 별도의 스케줄러를 가지고 있다.\r\n\r\nGPU 프로세서로부터 전달받는 BeginFrame 신호는 impl 스레드가 전달받으며 impl 스레드의 스케줄러에 의해 스케줄링된다. 이때 스케줄링되는 테스크는 impl 스레드에서 수행하는 BeginFrame이라는 의미에서 BeginImplFrame이라고 부른다. BeginImplFrame 테스크가 수행되는 시점에서 impl 스레드는 프레임 생산이 시작되었음을 인지한다.\r\n\r\nimpl 스레드는 BeginImplFrame 테스크의 수행도중 메인 스레드에게 BeginMainFrame 테스크를 수행하라는 메시지를 전송한다. 이 테스크를 수행하는 시점에서 메인 스레드는 프레임 생산이 시작되었음을 인지한다.\r\n\r\n지금까지의 과정을 요약하면 아래와 같다\r\n\r\n![aaa](/assets/blog/210523_raf/raf6.png)\r\n\r\n위의 과정은 매우 간략화된 형태이지만 사실 BeginMainFrame은 메인스레드의 이벤트 루프 내부에서 테스크의 형태로 실행된다.\r\n\r\n여기까지 이 글을 읽은 독자라면 이벤트 루프가 여러개의 테스크 큐를 대상으로 우선순위에 기반하여 수행된다는 사실을 알고있을 것이다.\r\n\r\n따라서 BeginMainFrame 또한 작업이 실행되기 전까지 특정한 테스크 큐에 저장되어 있다가 해당 테스크 큐의 순서가 오면 dequeue되어 수행된다. BeginMainFrame은 작업이 수행되기 전까지 컴포지터 테스크 큐에 저장된다.\r\n\r\n이 BeginMainFrame 테스크가 메인스레드 내부에서 하는 일을 요약하면 아래와 같다.\r\n\r\n가장 먼저 유저 입력에 대한 이벤트리스너를 수행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.\r\n\r\n곧이어 requestAnimationFrame의 콜백함수가 스케줄러에 등록되어 있다면 해당 함수를 실행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.\r\n\r\n이 시점에서 rAF 콜백함수가 종료되지만 변경사항이 바로 모니터에 적용되는 것은 아니며 모니터의 갱신까지는 몇가지 추가 단계를 필요로 한다.\r\n\r\nrAF의 종료이후 LocalFrameView 클래스의 UpdateLifeCycle 메소드를 수행한다. 이 테스크는 페이지의 최종 변경사항을 레이아웃 트리에 적용시킨다. 이 레이아웃 트리의 변경사항은 최종적으로 레이어 트리와 프로퍼티 트리를 생성한다.\r\n\r\n변경사항의 반영이 종료되면 레이어 트리의 커밋을 수행할 준비가 되었다는 신호인 NotifyReadyToCommit를 impl 스레드에게 전송한다. 이 메시지의 전송작업은 메인스레드의 프록시 클래스인 ProxyMain이 수행한다. 이 때 impl 스레드에게 뮤텍스를 보내며 메인 스레드는 블록킹 상태에 빠진다. 메인스레드가 블록킹 상태에 빠지는 이유는 impl 스레드가 레이어 트리를 복제하는 작업이 완료되기 전 까지는 레이어 트리를 수정해선 안되기 때문이다.\r\n\r\n여기까지가 메인스레드의 렌더링 작업이고 이후의 작업은 impl 스레드가 수행한다.\r\n\r\nNotifyReadyToCommit 신호를 전달받은 impl 스레드가 커밋 준비를 마친다면 ProxyImpl 클래스를 이용하여 메인 스레드의 데이터를 복제하여 컴포지터 스레드만이 접근할 수 있는 데이터를 생성한다. 만일 이러한 복제물을 생성하지 않은 채 메인스레드와 impl 스레드가 레이어 트리를 공유하여 사용한다면 메인스레드에서 변경작업 중인 레이어 트리의 변경작업이 완료되기도 전에 impl 스레드 측에서 임의로 디스플레이에 출력하는 사태가 발생할 수 있다. 이 경우 모니터의 티어링 현상이 발생할 수 있다.\r\n\r\n레이어 트리의 복제 작업이 완료되면 impl 스레드가 데이터의 복제가 완료되었다는 신호를 메인 스레드에게 건내주고 메인스레드는 블록킹 상태에서 벗어나 테스크를 재개할 수 있게된다. impl 스레드는 복제된 데이터를 기반으로 컴포지팅 작업을 수행한다. 컴포지팅은 화면상에 출력될 비트맵을 생성하는 작업이다. 비트맵의 생성이 완료되면 GPU 프로세스가 드로잉 작업을 수행하고 최종 결과물이 모니터에 드로잉된다.\r\n\r\n여기까지가 프레임생성의 풀 파이프라인이고 rAF의 콜백함수는 이러한 프레임 생성의 전체 파이프라인 중 BeginMainFrame 테스크의 일부분으로서 실행된다. 위의 설명은 전체 파이프라인을 매우 축약한 것이며 실제 과정은 더욱 디테일하다. 본 문서는 풀 파이프라인 중 rAF가 실행되는 과정에 집중하여 작성되었다.\r\n\r\n---\r\n\r\n#### 참고\r\n\r\n[Youtube - Life of a pixel (Chrome University 2019)](https://www.youtube.com/watch?v=m-J-tbAlFic)\r\n\r\n[웹사이트 : Chromium Code Search](https://source.chromium.org/chromium)\r\n\r\n[크로미움 문서 : How cc Works](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/how_cc_works.md)\r\n\r\n[크로미움 문서 : Blink Scheduler](https://chromium.googlesource.com/chromium/src/+/66.0.3359.158/third_party/WebKit/Source/platform/scheduler/README.md)",
      "html": "<h3 id=\"크로미움에서-requestanimationframe이-수행되는-과정\">크로미움에서 requestAnimationFrame이 수행되는 과정</h3>\n<p>( 최종수정일 : 2021년 5월 3일 AM 9:29)</p>\n<p>requestAnimationFrame 함수 줄여서 rAF를 이해하려면 rAF가 만들어진 배경을 이해하는 것이 좋다.</p>\n<p>rAF가 존재하기 전 웹페이지에서 매끄러운 애니메이션을 구현할 때는 setInterval 함수에 의존해야 했다.</p>\n<p>하지만 setInterval 함수는 크게 3가지 문제가 존재했다.</p>\n<p>첫째로 이 함수는 5회 이상 반복되는 주기부터 정밀도가 최소 4ms로 강제 조정된다.</p>\n<p>유저가 setInterval의 timeout주기를 1ms로 설정한다 하여도 5회 이상 반복되는 시점부터는 4ms로 강제 조정된다. 이를 타이머의 클램핑 기능이라고 한다.</p>\n<p>이는 WHATWG HTML Living Standard에 명시되어 있다</p>\n<blockquote>\n<p>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\r\n<code>(https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval)</code></p>\n</blockquote>\n<p>그리고 이러한 명세는 크로미움에 반영되어 있다</p>\n<blockquote>\n<p>// Step 11 of the algorithm at <a href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html\">https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html</a> requires that a timeout less than 4ms is increased to 4ms when the nesting level is greater than 5.<br>\n<br>\nconstexpr int kMaxTimerNestingLevel = 5;<br>\nconstexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);</p>\n</blockquote>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.cc)</code></p>\n<p>이러한 조치는 setInterval 함수보다 낮은 우선순위를 가진 테스크들의 기아 상태를 방지하기 위하여 고안되었다.</p>\n<p>이러한 클램핑 기능은 기아 상태를 방지하는 차원에서는 효율적이지만 정밀한 타이머를 구현하는 데는 방해거리가 된다.</p>\n<p>두번째 문제 역시 정밀도 문제인데, setInterval의 두번째 인자인 timeout은 소수점 이하를 무시하고 정수로 해석된다.</p>\n<p>예를 들어서 60프레임을 구현하려는 의도로 1초를 60으로 나눈 16.666ms 를 setInterval의 timeout 인자로 넣는다 하더라도 실제 작동시에는 16ms로 인식된다.</p>\n<p>자바스크립트 코드 상에서 에러 메시지를 내뱉지는 않지만 블링크 엔진 내부에서는 소수점 이하가 무시된 값인 16으로 인자값을 받게 되기 때문이다.</p>\n<p>그 이유는 setInterval의 구현체의 timeout 인자 타입이 int이기 때문이다.</p>\n<p>다음은 setTimeout 구현체의 매개변수별 타입이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int WindowOrWorkerGlobalScope::setInterval(\r\n\r\n    ScriptState* script_state,\r\n\r\n    EventTarget&amp; event_target,\r\n\r\n    V8Function* handler,\r\n\r\n    int timeout,\r\n\r\n    const HeapVector&lt;ScriptValue>&amp; arguments)\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)</code></p>\n<p>위에서 4번째 값이 setTimeout의 두번째 인자인 timeout 값이다.</p>\n<p>이처럼 소수점이 무시되기 때문에 1ms 미만의 정밀도를 제어할 수 없다.</p>\n<p>세번째로 setInterval 함수는 모니터의 주사율에 근거하여 프레임을 갱신할 수가 없다.</p>\n<p>rAF가 재정되기 이전의 대부분의 모니터는 주사율이 60Hz로 고정되어 있었다. 하지만 최근 출시되는 모니터는 75Hz, 120Hz, 144Hz, 240Hz로 주사율이 다양하다.</p>\n<p>가령 매끄러운 애니메이션을 위해 60프레임을 염두해 두고 16.66ms 단위로 화면을 갱신하기로 했다고 가정해 보자. 이 경우 코드는 아래와 같이 된다.</p>\n<pre class=\"language-javascript\" lang=\"javascript\"><code class=\"language-javascript\" lang=\"javascript\">// 두번째 매개변수의 소수점 이하를 무시하기 때문에 16.66을 반올림한 값을 대입한다\r\n\r\nsetInterval(animateFunction, 17) ;\n</code></pre>\n<p>위의 함수를 실행할 경우 가장 이상적인 시나리오대로 60프레임이 구현된다고 하더라도 주사율이 60Hz을 초과하는 모니터에서 그 이상의 프레임을 보장하기 어렵다.</p>\n<p>그렇다고 240Hz에 맞추어 4.16ms 단위로 화면을 갱신한다면 240hz미만의 모니터에서는 자원의 낭비가 심해진다.</p>\n<p>결국 모니터 주사율에 적응적으로 변화하는 갱신은 setInterval 함수로 해결할 수 없다.</p>\n<p>이와 같은 문제로 인하여 더욱 정밀한 프레임 갱신 방법론에 대한 요구가 있었고 그 결과로 requestAnimationFrame 함수가 탄생하였다.</p>\n<p>requestAnimationFrame 은 위의 3가지 문제를 처리해 준다. 즉 다음과 같다.</p>\n<p>첫째로 타이머 수치가 임의로 클램핑되지 않는다.</p>\n<p>둘째로 정밀도를 나노초 단위로 제어가 가능하다.</p>\n<p>셋째로 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.</p>\n<p>모니터의 주사율에 근거하여 프레임이 가변적으로 갱신된다는 점은 흥미롭다. 실제로 그렇게 작동하는지 직접 확인해 보겠다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;html>\r\n   &lt;body>\r\n      &lt;script>\r\n         (()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \tlet prev = performance.now() ;\r\n         \tlet cnt = 0 ; \r\n         \tfunction animateFunc()ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \r\n         \t\tlet curr = performance.now() ;\r\n         \t\tconsole.log(`$ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000curr - prev} ms`) ;\r\n         \t\tprev = curr ;\r\n         \t\t\r\n         \t\tif(++cnt &lt; 100) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n         \t\t\trequestAnimationFrame(animateFunc) ; \r\n         \t\t}\r\n         \t}\r\n         \trequestAnimationFrame(animateFunc);\r\n         })()\r\n      &lt;/script>\r\n   &lt;/body>\r\n&lt;/html>\n</code></pre>\n<p>위의 코드는 rAF를 반복 호출한다. 그리고 이전에 호출된 rAF 콜백함수와의 인터벌을 console.log로 출력한다</p>\n<p>위의 코드를 먼저 아래의 60Hz 모니터에서 실행해 보았다</p>\n<p><img src=\"/assets/blog/210523_raf/raf1.png\" alt=\"aaa\"></p>\n<p>결과는 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf2.png\" alt=\"aaa\"></p>\n<p>값은 대체로 16.6ms에 근사한 값을 보여준다. 사실 실행한 컴퓨터의 CPU 성능이 좋지 않아서 오차가 비교적 크게 발생하였다. 이 오차는 단일 프로세서의 처리 속도가 빠를수록 감소한다.</p>\n<p>장비를 바꾸어서 144Hz 모니터에서 같은 코드를 수행하였다.</p>\n<p><img src=\"/assets/blog/210523_raf/raf3.png\" alt=\"aaa\"></p>\n<p>결과는 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf4.png\" alt=\"aaa\"></p>\n<p>144Hz는 1초에 144회 화면을 갱신하므로 1프레임이 갱신되는 주기는 약 6.94ms이다.</p>\n<p>위의 수치는 약 6.94ms에 근사한 수치를 보여준다. 각 프레임별로 오차가 적은 이유는 CPU의 성능이 앞선 60Hz 테스트에서 사용한 CPU보다 빠르기 때문이다.</p>\n<p>이처럼 모니터 주사율에 가변적으로 rAF 호출 주기가 변경되는 이유는 rAF 함수가 모니터에서 제공하는 vsync pulse를 기반으로 작동하기 때문이다.</p>\n<p>vertical sync pulse, 줄여서 vsync pulse는 모니터에서 제공하는 전기적 신호인데 이 신호는 모니터가 화면상에 새로운 픽셀을 뿌리는 주기와 연관이 있다.</p>\n<p>모니터는 화면상에 새로운 픽셀을 드로잉하고 다음번 픽셀의 드로잉을 준비하기 시작할 때 vertical sync pulse를 생성한다. 예를 들어 60Hz 주사율의 모니터는 1초에 60번 새로운 화면을 갱신하는데 이 갱신 주기는 일정하다. 따라서 1초를 60으로 나눈값인 16.66ms 간격으로 vsync pulse를 생성한다.</p>\n<p>이 전기적 신호는 그래픽카드가 감지할 수 있다. 이 감지된 신호를 기반으로 requestAnimationFrame의 콜백함수가 호출되기 때문에 타이머 수치가 클램핑되지 않고, 나노세컨드 단위로 정밀하며, 모니터의 주사율에 근거하여 프레임을 갱신할 수 있다.</p>\n<p>이러한 프로세스가 구체적으로 어떻게 구현되어 있을지 추측해 보자.</p>\n<p>크로미움에서는 탭을 하나 생성할 때 마다 렌더러 프로세스가 한개씩 생성된다. 각 탭은 하나의 렌더러 프로세스를 가지고 있다.</p>\n<p>이 렌더러 프로세스는 탭 안에 보이는 화면을 렌더링하는 역할을 수행한다.</p>\n<p>그러니 이 렌더러 프로세스 내부에 vsync pulse를 감지하는 스레드가 존재한다고 생각할 수 있다.</p>\n<p>vsync 스레드가 vsync를 감지하여 자바스크립트를 실행하는 메인 스레드에게 신호를 전파하고 이 신호를 받은 메인 스레드가 requestAnimationFrame의 콜백함수를 호출하는 방식으로 수행된다고 생각할 수 있다.</p>\n<p>그러나 렌더러 프로세스는 샌드박스화 되어 있으므로 vsync 신호를 보내는 gpu 디바이스에 직접 억세스할 수 없다.</p>\n<p>샌드박스란 일종의 제한된 환경이며 샌드박스 안에 존재하는 프로세스는 CPU와 메모리를 제외한 다른 리소스에 접근할 수 없다.</p>\n<p>따라서 렌더러 프로세스는 샌드박스 환경 밖에 있는 GPU 프로세스와의 IPC를 통하여 vsync신호를 전달받게 된다. 도식화하면 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf5.png\" alt=\"aaa\"></p>\n<p>크로미움 브라우저 내부의 GPU 프로세스는 vsync 스레드를 가지고 있다. 이 스레드는 OS가 제공하는 vsync API를 이용하여 vsync 주기를 감지한다.</p>\n<p>예를들어 windows OS의 경우 vsync API는 IDXGIOutput 클래스가 제공하는데 이 클래스가 제공하는 waitForVBlank 등의 메소드를 사용하여 vsync 주기를 감지한다. 아래 코드는 windows용 vsync 스레드가 v싱크 신호 감지에 사용하는 메소드이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void VSyncThreadWin::WaitForVSync() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n  const HMONITOR monitor = MonitorFromWindow(nullptr, MONITOR_DEFAULTTOPRIMARY);\r\n\r\n  if (primary_monitor_ != monitor) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    primary_monitor_ = monitor;\r\n    primary_output_ = DXGIOutputFromMonitor(monitor, d3d11_device_);\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  const bool wait_for_vblank_succeeded =\r\n      primary_output_ &amp;&amp; SUCCEEDED(primary_output_->WaitForVBlank());\r\n\r\n  // .. 생략\r\n\r\n  if (!wait_for_vblank_succeeded ||\r\n      wait_for_vblank_elapsed_time &lt; kVBlankIntervalThreshold) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    Sleep(static_cast&lt;DWORD>(vsync_interval.InMillisecondsRoundedUp()));\r\n  }\r\n\r\n  // .. 생략\r\n\r\n  if (!observers_.empty()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    vsync_thread_.task_runner()->PostTask(\r\n        FROM_HERE,\r\n        base::BindOnce(&amp;VSyncThreadWin::WaitForVSync, base::Unretained(this)));\r\n    const base::TimeTicks vsync_time = base::TimeTicks::Now();\r\n    for (auto* obs : observers_)\r\n      obs->OnVSync(vsync_time, vsync_interval);\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    is_idle_ = true;\r\n  }\r\n}\n</code></pre>\n<p><code>&lt; 참조 : ui/gl/vsync_thread_win.cc></code></p>\n<p>위의 코드에서 DXGIOutputFromMonitor함수는 프라이머리로 사용중인 모니터의 정보를 가져온다. 그리고 해당 모니터를 대상으로 WaitForVBlank 메소드를 호출하여 v싱크 주기를 감시한다. 만일 v싱크 주기가 감지된다면 옵저버인 DirectCompositionChildSurfaceWin 클래스의 OnVSync 메소드가 트리거되고 프레임 생성 파이프라인을 시작한다. 이 파이프라인의 시작신호를 BeginFrame이라고 한다.</p>\n<p>크로미움은 BeginFrame을 다음과 같이 정의하고 있다</p>\n<blockquote>\n<p>BeginFrame is the mechanism that tells us that now is a good time to start making a frame<br>\n(BeginFrame은 메커니즘인데 이 메커니즘은 지금이 프레임의 생성을 시작하는 좋은 타이밍이라는 것을 알려준다.)</p>\n</blockquote>\n<p><code>(cc/scheduler/scheduler.cc)</code></p>\n<p>GPU 프로세스는 렌더러 프로세스에게 BeginFrame 신호를 보낸다. 이 때 BeginFrame은 하나의 테스크로서 간주되며 스케줄러에 의해 스케줄링된다. 이 BeginFrame 신호는 렌더러 프로세스의 impl 스레드에게 전달된다.</p>\n<p>사실 렌더러 프로세스에는 크게 2가지의 스레드가 존재한다. 메인스레드와 impl 스레드가 그것인데 각각의 스레드는 별도의 스케줄러를 가지고 있다.</p>\n<p>GPU 프로세서로부터 전달받는 BeginFrame 신호는 impl 스레드가 전달받으며 impl 스레드의 스케줄러에 의해 스케줄링된다. 이때 스케줄링되는 테스크는 impl 스레드에서 수행하는 BeginFrame이라는 의미에서 BeginImplFrame이라고 부른다. BeginImplFrame 테스크가 수행되는 시점에서 impl 스레드는 프레임 생산이 시작되었음을 인지한다.</p>\n<p>impl 스레드는 BeginImplFrame 테스크의 수행도중 메인 스레드에게 BeginMainFrame 테스크를 수행하라는 메시지를 전송한다. 이 테스크를 수행하는 시점에서 메인 스레드는 프레임 생산이 시작되었음을 인지한다.</p>\n<p>지금까지의 과정을 요약하면 아래와 같다</p>\n<p><img src=\"/assets/blog/210523_raf/raf6.png\" alt=\"aaa\"></p>\n<p>위의 과정은 매우 간략화된 형태이지만 사실 BeginMainFrame은 메인스레드의 이벤트 루프 내부에서 테스크의 형태로 실행된다.</p>\n<p>여기까지 이 글을 읽은 독자라면 이벤트 루프가 여러개의 테스크 큐를 대상으로 우선순위에 기반하여 수행된다는 사실을 알고있을 것이다.</p>\n<p>따라서 BeginMainFrame 또한 작업이 실행되기 전까지 특정한 테스크 큐에 저장되어 있다가 해당 테스크 큐의 순서가 오면 dequeue되어 수행된다. BeginMainFrame은 작업이 수행되기 전까지 컴포지터 테스크 큐에 저장된다.</p>\n<p>이 BeginMainFrame 테스크가 메인스레드 내부에서 하는 일을 요약하면 아래와 같다.</p>\n<p>가장 먼저 유저 입력에 대한 이벤트리스너를 수행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.</p>\n<p>곧이어 requestAnimationFrame의 콜백함수가 스케줄러에 등록되어 있다면 해당 함수를 실행한다. 이 과정에서 DOM 트리 또는 CSSOM 트리가 변경될 수 있다.</p>\n<p>이 시점에서 rAF 콜백함수가 종료되지만 변경사항이 바로 모니터에 적용되는 것은 아니며 모니터의 갱신까지는 몇가지 추가 단계를 필요로 한다.</p>\n<p>rAF의 종료이후 LocalFrameView 클래스의 UpdateLifeCycle 메소드를 수행한다. 이 테스크는 페이지의 최종 변경사항을 레이아웃 트리에 적용시킨다. 이 레이아웃 트리의 변경사항은 최종적으로 레이어 트리와 프로퍼티 트리를 생성한다.</p>\n<p>변경사항의 반영이 종료되면 레이어 트리의 커밋을 수행할 준비가 되었다는 신호인 NotifyReadyToCommit를 impl 스레드에게 전송한다. 이 메시지의 전송작업은 메인스레드의 프록시 클래스인 ProxyMain이 수행한다. 이 때 impl 스레드에게 뮤텍스를 보내며 메인 스레드는 블록킹 상태에 빠진다. 메인스레드가 블록킹 상태에 빠지는 이유는 impl 스레드가 레이어 트리를 복제하는 작업이 완료되기 전 까지는 레이어 트리를 수정해선 안되기 때문이다.</p>\n<p>여기까지가 메인스레드의 렌더링 작업이고 이후의 작업은 impl 스레드가 수행한다.</p>\n<p>NotifyReadyToCommit 신호를 전달받은 impl 스레드가 커밋 준비를 마친다면 ProxyImpl 클래스를 이용하여 메인 스레드의 데이터를 복제하여 컴포지터 스레드만이 접근할 수 있는 데이터를 생성한다. 만일 이러한 복제물을 생성하지 않은 채 메인스레드와 impl 스레드가 레이어 트리를 공유하여 사용한다면 메인스레드에서 변경작업 중인 레이어 트리의 변경작업이 완료되기도 전에 impl 스레드 측에서 임의로 디스플레이에 출력하는 사태가 발생할 수 있다. 이 경우 모니터의 티어링 현상이 발생할 수 있다.</p>\n<p>레이어 트리의 복제 작업이 완료되면 impl 스레드가 데이터의 복제가 완료되었다는 신호를 메인 스레드에게 건내주고 메인스레드는 블록킹 상태에서 벗어나 테스크를 재개할 수 있게된다. impl 스레드는 복제된 데이터를 기반으로 컴포지팅 작업을 수행한다. 컴포지팅은 화면상에 출력될 비트맵을 생성하는 작업이다. 비트맵의 생성이 완료되면 GPU 프로세스가 드로잉 작업을 수행하고 최종 결과물이 모니터에 드로잉된다.</p>\n<p>여기까지가 프레임생성의 풀 파이프라인이고 rAF의 콜백함수는 이러한 프레임 생성의 전체 파이프라인 중 BeginMainFrame 테스크의 일부분으로서 실행된다. 위의 설명은 전체 파이프라인을 매우 축약한 것이며 실제 과정은 더욱 디테일하다. 본 문서는 풀 파이프라인 중 rAF가 실행되는 과정에 집중하여 작성되었다.</p>\n<hr>\n<h4 id=\"참고\">참고</h4>\n<p><a href=\"https://www.youtube.com/watch?v=m-J-tbAlFic\">Youtube - Life of a pixel (Chrome University 2019)</a></p>\n<p><a href=\"https://source.chromium.org/chromium\">웹사이트 : Chromium Code Search</a></p>\n<p><a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/how_cc_works.md\">크로미움 문서 : How cc Works</a></p>\n<p><a href=\"https://chromium.googlesource.com/chromium/src/+/66.0.3359.158/third_party/WebKit/Source/platform/scheduler/README.md\">크로미움 문서 : Blink Scheduler</a></p>"
    },
    "url": "/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/210503_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_requestAnimationFrame%EC%9D%B4_%EC%88%98%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95.md")
  }
}, children);

});
</script><astro-root uid="2fhblW"><div class="post-preview-container" data-reactroot=""><article class="post-preview"><header><a href="/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95"><p class="title">크로미움 웹브라우저에서 setTimeout이 실행되는 과정</p></a></header><time>2021.04.29</time></article></div></astro-root>
<script type="module">
import setup from '/_astro_frontend/hydrate/load.js';
setup("2fhblW", {}, async () => {
  
  const [{ default: Component }, { default: hydrate }] = await Promise.all([import("/_astro/src/components/BlogPostPreviewReact.js"), import("/_snowpack/pkg/@astrojs.renderer-react.client.v0.2.0.js")]);
  return (el, children) => hydrate(el)(Component, {
  "post": {
    "title": "크로미움 웹브라우저에서 setTimeout이 실행되는 과정",
    "description": "setTimeout API의 작동방식",
    "publishDate": "2021.04.29",
    "astro": {
      "headers": [{
        "depth": 3,
        "slug": "크로미움-웹브라우저에서-settimeout이-실행되는-과정",
        "text": "크로미움 웹브라우저에서 setTimeout이 실행되는 과정"
      }],
      "source": "\r\n### 크로미움 웹브라우저에서 setTimeout이 실행되는 과정\r\n\r\n아래 코드는 setTimeout을 호출하는 코드이다\r\n\r\n```html\r\n<script>\r\n   f1() ;\r\n\r\n   setTimeout(()=>{\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() {\r\n     return 1 ;\r\n   }\r\n<\/script>\r\n\r\n```\r\n브라우저 내부에서 위의 코드가 실행될 때 아래와 같은 루틴으로 처리된다.\\\r\n\\\r\n`<script>` 내부는 자바스크립트 코드로 이루어져 있고 이 코드는 웹브라우저의 렌더러 엔진이 단독으로 처리할 수 없다. 따라서 자바스크립트 가상 머신에게 script 내부의 처리를 요청한다.\\\r\n\\\r\n크로미움에서 해당 작업은 v8이라는 이름의 자바스크립트 가상머신이 수행한다.\\\r\n\\\r\nv8은 먼저 f1 함수를 호출한다. f1의 수행이 종료되면 이어서 setTimeout 함수를 호출한다.\\\r\n\\\r\nsetTimeout 함수를 호출한 주체는 v8 자바스크립트 엔진이지만 setTimeout은 v8에 구현되어 있지 않다.\\\r\n\\\r\nv8은 ECMAScript 스펙의 구현체이지만 setTimeout은 ECMAScript의 스펙에 정의되어 있지 않기 때문이다.\\\r\n\\\r\nsetTimeout은 WHATWG에서 관리하는 HTML Living Standard 스펙에 정의되어 있다\\\r\n`([링크](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout))`\\\r\n\\\r\n이처럼 WHATWG HTML Living Standard 스펙에 정의되어 있는 자바스크립트 함수를 Web API라고 한다\\\r\n\\\r\n이러한 WebAPI는 웹브라우저의 렌더러 엔진에 구현되어 있다. 크로미움의 렌더러 엔진을 블링크라고 한다.\\\r\n\\\r\nv8엔진은 Blink IDL이라는 인터페이스를 통하여 블링크 엔진 내부에 구현된 WebAPI 함수의 실제 구현체를 호출한다.\\\r\n\\\r\nsetTimeout의 실제 구현체는 블링크 엔진 내부에 있는 WindowOrWorkerGlobalScope클래스의 SetTimeout메소드에 정의되어 있다.\\\r\n\\\r\n자바스크립트 코드 내부에서 setTimeout을 호출하는 순간 자바스크립트 코드 실행부는 일시 중지되고 제어권은 블링크 엔진에게 이전된다.\\\r\n\\\r\n블링크 엔진 내부에서 setTimeout 함수의 루틴이 종료되면 리턴값인 타이머 ID를 v8에게 반환하면서 자바스크립트 코드 실행부가 작업을 재개한다.\\\r\n\\\r\n다음은 `WindowOrWorkerGlobalScope::SetTimeout` 메소드이다\r\n\r\n```cpp\r\nint WindowOrWorkerGlobalScope::setTimeout(\r\n    ScriptState* script_state,\r\n    EventTarget& event_target,\r\n    V8Function* handler,\r\n    int timeout,\r\n    const HeapVector<ScriptValue>& arguments) {\r\n\r\n  ExecutionContext* execution_context = event_target.GetExecutionContext();\r\n  if (!IsAllowed(execution_context, false, g_empty_string))\r\n    return 0;\r\n  auto* action = MakeGarbageCollected<ScheduledAction>(\r\n      script_state, execution_context, handler, arguments);\r\n\r\n  return DOMTimer::Install(execution_context, action,\r\n                           base::TimeDelta::FromMilliseconds(timeout), true);\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)`\\\r\n\\\r\n위의 코드는 C++로 작성되었다. 이처럼 블링크 렌더러 엔진을 비롯한 대부분의 크로미움 소스는 C++로 작성되었다.\\\r\n\\\r\n위의 코드에서 마지막 return 직전에 호출되는 `DOMTimer::Install` 메소드는 타이머계열 메소드 (setInterval, setTimeout)의 수행에 사용된다. 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nint DOMTimer::Install(ExecutionContext* context,\r\n                      ScheduledAction* action,\r\n                      base::TimeDelta timeout,\r\n                      bool single_shot) {\r\n  int timeout_id = context->Timers()->InstallNewTimeout(context, action,\r\n                                                        timeout, single_shot);\r\n  return timeout_id;\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.h)`\r\n\\\r\n`DOMTimer::Install`메소드는 내부에서 `DOMTimerCoordinator` 인스턴스의 `InstallNewTimeout` 메소드를 호출한다.\\\r\n\\\r\n`DOMTimerCoordinator::InstallNewTimeout` 메소드는 실질적인 `setTimeout의` 구현체이다. 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nint DOMTimerCoordinator::InstallNewTimeout(ExecutionContext* context,\r\n                                           ScheduledAction* action,\r\n                                           base::TimeDelta timeout,\r\n                                           bool single_shot) {\r\n  // FIXME: DOMTimers depends heavily on ExecutionContext. Decouple them.\r\n  DCHECK_EQ(context->Timers(), this);\r\n  int timeout_id = NextID();\r\n  timers_.insert(timeout_id,\r\n                 MakeGarbageCollected<DOMTimer>(context, action, timeout,\r\n                                                single_shot, timeout_id));\r\n  return timeout_id;\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer_coordinator.cc)`\\\r\n\\\r\n`DOMTimerCoordinator::InstallNewTimeout` 메소드는 크게 2가지 작업을 수행한다.\\\r\n\\\r\n첫째로 콜백함수의 타이머 id를 생성한다. 이는 NextID() 메소드를 호출함으로서 수행된다.\\\r\n\\\r\n둘째로 콜백함수를 스케줄링한다. 해당 작업은 콜백함수를 테스크 큐에 삽입함으로서 수행된다. 테스크 큐라는 용어는 이벤트 루프에 대해 조사해 본 적이 있다면 들어본 적이 있을 것이다. 테스크 큐는 queue라는 자료구조의 구현체로서 수행할 테스크를 후입선출 방식으로 실행하는 자료구조를 의미한다. 여기에는 자바스크립트 `setTimeout` 함수의 첫번째 인자로 삽입된 콜백함수가 스케줄링된다.\\\r\n\\\r\n엄밀하게 이야기하면 콜백함수가 직접 스케줄링되지 않으며 콜백함수를 프로퍼티로 가진 DOMTimer 인스턴스가 스케줄링된다. 스케줄링되는 DOMTimer 인스턴스 내부에 setTimeout 콜백함수가 프로퍼티로 저장되어 있으며 이 프로퍼티의 이름은 action_이다.\\\r\n\\\r\n실제 테스크 수행시에는 최종적으로 해당 콜백함수가 실행된다.\\\r\n\\\r\n이 스케줄링 과정은 위의 `InstallNewTimeout` 메소드에서는 확인하기 어렵다. 위의 코드에서는 timers_.insert() 메소드를 호출하는 과정에서 두번째 인자로 DOMTimer 인스턴스가 전달되는 것을 확인할 수 있는데, 덕분에 timers_.insert() 를 호출하는 행위를 스케줄링 작업으로 오해할 수 있다. 사실 timers_ 는 자바스크립트에서 clearTimeout() 함수를 호출할 때 해당 테스크의 스케줄링을 취소하려는 목적으로 사용된다.\\\r\n\\\r\n실제 스케줄링 작업은 DOMTimer가 생성자를 호출할 때 이루어진다. DOMTimer 생성자의 내부로 진입해 보겠다.\r\n\r\n```cpp\r\nDOMTimer::DOMTimer(ExecutionContext* context,\r\n                   ScheduledAction* action,\r\n                   base::TimeDelta timeout,\r\n                   bool single_shot,\r\n                   int timeout_id)\r\n    : ExecutionContextLifecycleObserver(context),\r\n      TimerBase(nullptr),\r\n      timeout_id_(timeout_id),\r\n      // Step 9:\r\n      nesting_level_(context->Timers()->TimerNestingLevel()),\r\n      action_(action) {\r\n  DCHECK_GT(timeout_id, 0);\r\n\r\n  // Step 10:\r\n  if (timeout < base::TimeDelta())\r\n    timeout = base::TimeDelta();\r\n\r\n  // Steps 12 and 13:\r\n  // Note: The implementation increments the nesting level before using it to\r\n  // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n  IncrementNestingLevel();\r\n\r\n  // Step 11:\r\n  // Note: The implementation uses >= instead of >, contrary to what the spec\r\n  // requires crbug.com/1108877.\r\n  if (nesting_level_ >= kMaxTimerNestingLevel && timeout < kMinimumInterval)\r\n    timeout = kMinimumInterval;\r\n\r\n  // Select TaskType based on nesting level.\r\n  TaskType task_type;\r\n  if (timeout.is_zero()) {\r\n    task_type = TaskType::kJavascriptTimerImmediate;\r\n    DCHECK_LT(nesting_level_, kMaxTimerNestingLevel);\r\n  } else if (nesting_level_ >= kMaxTimerNestingLevel) {\r\n    task_type = TaskType::kJavascriptTimerDelayedHighNesting;\r\n  } else {\r\n    task_type = TaskType::kJavascriptTimerDelayedLowNesting;\r\n  }\r\n  MoveToNewTaskRunner(context->GetTaskRunner(task_type));\r\n\r\n  if (single_shot) {\r\n    StartOneShot(timeout, FROM_HERE);\r\n  } else {\r\n    // TODO(crbug.com/402694): Don't clamp interval timers to 1ms here\r\n    timeout = std::max(timeout, base::TimeDelta::FromMilliseconds(1));\r\n    StartRepeating(timeout, FROM_HERE);\r\n  }\r\n\r\n // ...\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/core/frame/dom_timer.cc )`\r\n\\\r\n소스는 매우 장황하고 이해하기 어렵다. 돔타이머 생성자의 루틴은 크게 두가지 작업으로 나뉜다\\\r\n\\\r\n먼저 자바스크립트 setTimeout의 두번째 인자로 삽입된 timeout 수치를 재조정한다.\\\r\n\\\r\n그 이후 조정된 timeout수치를 참고하여 스케줄링을 수행한다.\\\r\n\\\r\n여기서 timeout수치를 재조정한다는 게 무슨 말인지 의아할 수 있다.\\\r\n\\\r\nsetTimeout함수는 유저가 입력한 timeout수치가 지나치게 낮으면 이를 재조정하도록 설계되어 있다.\\\r\n\\\r\n이 규칙은 WHATWG HTML Living Standard에 명시되어 있다 ([링크](html.spec.whatwg.org/multipage/timers-and-user-prompts.html))\\\r\n\\\r\n위의 소스코드에서 Step 9, Step 10, Step 11 등의 주석을 확인할 수 있는데 이는 HTML 리빙 스탠다드에 명시되어 있는 타이머 초기화 스탭을 구현하는 것을 의미한다.\\\r\n\\\r\n예를 들어 스탭 11의 명세는 아래와 같다.\r\n\r\n> If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.\\\r\n> (중첩 레벨이 5보다 크고 timeout수치가 4 미만인 경우, timeout수치를 4로 재조정한다)\r\n\r\ntimeout 수치를 재조정 작업이 완료되면 스케줄링에 필요한 모든 작업이 완료되었고 소스의 아랫부분에서 확인할 수 있는 것처럼 StartOneShot 메소드를 호출한다. 이는 1회만 호출하는 원샷 타이머의 형태로 스케줄링을 진행하겠다는 뜻이다.\\\r\n\\\r\nStartOneShot 메소드 내부에서 몇번의 서브루틴이 있으며 최종적으로 TimerTaskRunner가 postDelayedTask메소드를 호출하여 콜백함수를 테스크 큐에 enqueue함으로서 스케줄링이 수행된다. 이는 아래 소스에서 확인할 수 있다\\\r\n\r\n```cpp\r\nvoid TimerBase::SetNextFireTime(base::TimeTicks now, base::TimeDelta delay) {\r\n\r\n    //  ..생략\r\n\r\n    web_task_runner_->PostDelayedTask(\r\n        location_, BindTimerClosure(weak_ptr_factory_.GetWeakPtr()), delay);\r\n  }\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/platform/timer.cc)`\\\r\n\\\r\n위의 코드에서 PostDelayedTask 메소드의 첫번째 인자인 location_은 DOMTimer 인스턴스이며 해당 인스턴스에 setTimeout의 콜백함수가 저장되어 있다. 세번째 인자인 delay은 타이머 초기화 스탭으로 재조정된 timeout 수치이다.\\\r\n\\\r\nPostDelayedTask라는 용어에서 post는 테스크를 큐에 삽입하는 행위이고 DelayedTask는 해당 테스크가 시간차를 두고 실행되는 테스크라는 것을 의미한다.\\\r\n\\\r\n결론적으로 setTimeout의 콜백함수는 TimerTask로 분류되며 해당 테스크는 TimerTaskRunner 인스턴스가 컨트롤한다\\\r\n\\\r\n여기서 TimerTaskRunner 인스턴스가 컨트롤하는 테스크 큐를 Frame Throttleable 테스크 큐라고 부른다.\\\r\n\\\r\nFrame Throttleable 테스크 큐는 블링크 렌더러 엔진의 메인 스레드 스케줄러가 관리하는 약 19여개의 테스크 큐 중 하나로서 setInterval, setTimeout과 같은 자바스크립트 수준의 타이머를 관리한다.\\\r\n\\\r\n메인 스레드 스케줄러는 Frame Throttleable 테스크 큐 외에도 약 19여개의 테스크 큐를 관리한다.\\\r\n\\\r\n아래는 메인스레드 테스크 큐의 종류이다.\r\n\r\n```cpp\r\nenum class QueueType {\r\n  kControl = 0,\r\n  kDefault = 1,\r\n  kFrameLoading = 5,\r\n  kCompositor = 8,\r\n  kIdle = 9,\r\n  kTest = 10,\r\n  kFrameLoadingControl = 11,\r\n  kFrameThrottleable = 12,\r\n  kFrameDeferrable = 13,\r\n  kFramePausable = 14,\r\n  kFrameUnpausable = 15,\r\n  kV8 = 16,\r\n  kInput = 18,\r\n  kDetached = 19,\r\n  kWebScheduling = 24,\r\n  kNonWaking = 25,\r\n  kIPCTrackingForCachedPages = 26,\r\n  kOther = 23,\r\n  kCount = 27\r\n};\r\n```\r\n`(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)`\\\r\n\\\r\n위 코드에서 각 QueueType 에 할당된 정수는 코드 내부적으로 가독성을 올리기 위한 수단이며 테스크 우선순위와는 무관하다.\\\r\n\\\r\n물론 각 테스크 큐는 각자의 고유한 우선순위를 가지고 있다. 메인 스케줄러는 이러한 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다. 각 테스크 큐의 우선순위는 아래에서 설명하겠다.\\\r\n\\\r\n여기서부터 조금 더 깊이 들어가보겠다\\\r\n\\\r\nsetTimeout의 콜백함수가 스케줄링 되는 테스크 큐는 Frame Throttleable 테스크 큐 이지만 더 정확히 이야기하면 Frame Throttleable 테스크 큐 내부의 delayed_incoming_queue에 삽입된다.\\\r\n\\\r\n조금 혼란이 올 수가 있는데, 하나의 테스크 큐 내부에는 4가지 종류의 테스크 큐가 있다\r\n\r\n```\r\n1. immediate_incoming_queue\r\n2. immediate_work_queue\r\n3. delayed_incoming_queue\r\n4. delayed_work_queue\r\n```\r\n\r\n이 중 타이머 수행에는 앞에 delayed라는 이름이 붙여진 2개의 테스크 큐가 사용된다.\\\r\n\\\r\nsetTimeout의 콜백함수는 먼저 delayed_incoming_queue에 삽입된다.\\\r\n\\\r\ndelayed_incoming_queue는 유저가 인터벌 값으로 설정한 밀리세컨드 값을 참조하여 해당 콜백함수가 호출되는 시점이 되면 delayed_work_queue로 이전한다.\\\r\n\\\r\ndelayed_work_queue에 이전된 함수는 테스크를 수행할 준비가 되었다는 뜻이며 이는 블링크의 메인스레드 스케줄러에 의해 실행될 수 있다.\\\r\n\\\r\n이처럼 delayed_incoming_queue의 테스크를 delayed_work_queue로 옮기는 작업은 TimeDomain 클래스가 담당하며 TimeDomain 클래스가 UpdateDelayedWorkQueue메소드를 호출함으로서 이전이 수행된다. TimeDomain 클래스는 OS가 제공하는 시스템 틱 API를 호출하여 현재시간을 계산한다.\\\r\n\\\r\nwindows OS의 경우 시스템 틱을 호출하는 루틴은 time_win.cc에 정의되어 있다.\\\r\n\\\r\n여기까지가 setTimeout의 콜백함수를 스케줄링 하는 과정이었다. 다시 자바스크립트의 코드 실행부로 돌아가보겠다.\r\n\r\n```html\r\n   f1()\r\n\r\n   setTimeout(()=>{\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() {\r\n     return 1\r\n   }\r\n```\r\nsetTimeout의 호출이후 자바스크립트의 메인 프로그램이 종료된다. 메인 프로그램의 종료이후 제어권은 embedder(임베더)에게 이전된다.\\\r\n\\\r\n임베더는 자바스크립트의 코드실행을 호출한 주체를 일컫는 데 웹브라우저의 경우 임베더는 렌더러 엔진의 메인스레드이다.\\\r\n즉 제어권이 렌더러 엔진인 블링크의 메인 스레드에게 이전된다. 제어권이 이전되면 렌더러 엔진은 자바스크립트의 마이크로테스크 큐를 실행할 조건이 되는지 검사한다.\\\r\n\\\r\n여기서 자바스크립트의 마이크로테스크 큐를 실행하는 주체가 자바스크립트 엔진이 아닌 자바스크립트 엔진의 임베더라는 사실을 알 수 있다.\\\r\n\\\r\n콜스택의 depth가 0인지를 체크하여 0이라면 마이크로테스크 큐가 소진될 때 까지 반복하여 마이크로테스크를 수행한다.\\\r\n\\\r\n마이크로테스크 작업이 모두 종료되면 블링크 메인스레드의 스케줄러가 스케줄링 정책에 입각하여 다음 테스크를 선택하는 루틴을 수행한다. 여기서부터 흔히 말하는 이벤트루프 단계가 수행된다.\\\r\n\\\r\n위에서 언급했듯이 메인스레드의 스케줄러는 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다.\\\r\n\\\r\n여기서 우리는 setTimeout의 콜백함수가 스케줄링 되어있는 Frame Throttleable 테스크 큐가 언제 실행되는지에 관심이 있다.\\\r\n\\\r\nFrame Throttleable 테스크 큐의 우선순위는 0~11까지 책정되어 있는 우선순위 값 중 7이다. 숫자값이 클수록 우선순위가 높다.\r\n\r\n```cpp\r\nenum class PrioritisationType {\r\n  kInternalScriptContinuation = 0,\r\n  kBestEffort = 1,\r\n  kRegular = 2,\r\n  kLoading = 3,\r\n  kLoadingControl = 4,\r\n  kFindInPage = 5,\r\n  kExperimentalDatabase = 6,\r\n  kJavaScriptTimer = 7,\r\n  kHighPriorityLocalFrame = 8,\r\n  kCompositor = 9,  // Main-thread only.\r\n  kInput = 10,\r\n\r\n  kCount = 11\r\n};\r\n```\r\n\r\n`(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)`\\\r\n\\\r\n위의 코드에서 `kJavaScriptTimer는` `Frame Throttleable 테스크 큐`의 우선순위이다.\\\r\n\\\r\n따라서 값이 7보다 높은 테스크 큐에 예약된 테스크가 이미 존재하는 상황에서는 setTimeout의 콜백함수는 영원히 실행되지 않는다.\\\r\n\\\r\n이런 상황을 기아상태라고 한다.\\\r\n\\\r\n우선순위가 7보다 높은 테스크 큐에는 컴포지터 테스크 큐와 유저인풋 테스크 큐 등이 존재한다.\\\r\n\\\r\n만일 우선순위가 7보다 높은 테스크 큐에 테스크가 없다면 `Frame Throttleable 테스크 큐` 내부의 `immediate_work_queue`와 `delayed_work_queue`에 수행할 테스크가 존재하는지 체크한다.\\\r\n\\\r\n만일 테스크가 존재한다면 해당 테스크를 수행한다.\\\r\n\\\r\n만일 존재하지 않는다면 우선순위가 7보다 낮은 테스크 큐에 테스크가 존재하는지 체크한다.\\\r\n\\\r\n블링크의 테스크 스케줄링은 위와 같은 방식으로 수행된다. 이것이 흔히 말하는 이벤트 루프의 민낯이다.\\\r\n\\\r\n1000ms가 지나서 `delayed_work_queue`에 수행할 테스크가 적재되었다면 스케줄러는 해당 테스크를 수행한다.\\\r\n\\\r\n위에서 setTimeout의 콜백함수는 DOMTimer 인스턴스의 형태로 스케줄링 된다고 언급하였다.\\\r\n\\\r\nDOMTimer는 Fired 메소드를 호출하여 해당 콜백함수가 트리거 됨을 알린다. Fired 메소드의 코드는 아래와 같다\r\n\r\n```cpp\r\n\r\nvoid DOMTimer::Fired() {\r\n\r\n  // .. 생략\r\n\r\n  // Simple case for non-one-shot timers.\r\n  if (IsActive()) {\r\n    DCHECK(is_interval);\r\n\r\n    // Steps 12 and 13:\r\n    // Note: The implementation increments the nesting level before using it to\r\n    // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n    IncrementNestingLevel();\r\n\r\n    // Make adjustments when the nesting level becomes >= |kMaxNestingLevel|.\r\n    // Note: The implementation uses >= instead of >, contrary to what the spec\r\n    // requires crbug.com/1108877.\r\n    if (nesting_level_ == kMaxTimerNestingLevel) {\r\n      // Move to the TaskType that corresponds to nesting level >=\r\n      // |kMaxNestingLevel|.\r\n      MoveToNewTaskRunner(\r\n          context->GetTaskRunner(TaskType::kJavascriptTimerDelayedHighNesting));\r\n      // Step 11:\r\n      if (RepeatInterval() < kMinimumInterval)\r\n        AugmentRepeatInterval(kMinimumInterval - RepeatInterval());\r\n    }\r\n\r\n    DCHECK(nesting_level_ < kMaxTimerNestingLevel ||\r\n           RepeatInterval() >= kMinimumInterval);\r\n\r\n    // No access to member variables after this point, it can delete the timer.\r\n    action_->Execute(context);\r\n\r\n    context->Timers()->SetTimerNestingLevel(0);\r\n\r\n    return;\r\n  }\r\n```\r\n\r\n여전히 소스는 장황하고 이해하기 어렵다. 맨 아래에서 세번째 명령어인 `action_->Execute(context) ;` 부분은 실질적인 콜백함수의 호출로 이어진다. action_ 프로퍼티는 `ScheduledAction` 클래스의 인스턴스인데 해당 인스턴스는 V8 엔진과 블링크 렌더러 엔진의 브릿지 역할을 수행한다\r\n\r\n```cpp\r\nvoid ScheduledAction::Execute(ExecutionContext* context) {\r\n\r\n  // .. 생략\r\n  script->RunScriptOnScriptStateAndReturnValue(script_state_->Get());\r\n}\r\n```\r\n\r\n`(third_party/blink/renderer/bindings/core/v8/scheduled_action.cc)`\\\r\n\\\r\n위의 소스코드에서 `RunScriptOnScriptStateAndReturnValue` 메소드는 직접적인 스크립트의 수행을 V8에게 요청한다.\\\r\n\\\r\n이 작업은 `V8ScriptRunner`클래스가 `CallFunction`을 호출하여 수행된다.\\\r\n\\\r\n이로서 자바스크립트 엔진에게 제어권이 넘어가게 되고 setTimeout의 첫번째 인자인 콜백 함수가 호출된다.\\\r\n\\\r\n이로서 setTimeout의 실행 사이클은 종료된다\\\r\n\\\r\n위와 같은 사실로부터 몇가지 사실을 도출할 수 있다.\\\r\n\r\n> 첫번째, 렌더러 엔진 내부에서 렌더링 과정의 수행과 자바스크립트 코드 실행은 같은 스레드에서 수행된다.\\\r\n> 두번째, 마이크로테스크 큐의 실행은 렌더러 엔진의 스케줄링 과정에 포함되어 있지 않다.\\\r\n> 세번째, 자바스크립트 코드로 호출 가능한 WebAPI는 자바스크립트 엔진 내부에 구현되어 있지 않으며 렌더러 엔진에 구현되어 있다\r\n\r\n따라서 WebAPI는 렌더러 엔진을 구현한 프로그래밍 언어로 실행된다. 크로미움의 경우 WebAPI는 C++ 코드로 실행된다.\\\r\n\\\r\n네번째, 이벤트 루프는 자바스크립트 코드를 수행하는 것을 포함하여 더 넒은 범위의 테스크를 포함한다.\\\r\n\\\r\n이러한 이벤트 루프는 렌더러의 메인 스레드 내부의 스케줄링 정책에 의해 수행된다.\\\r\n\\\r\nHTML Living Standard는 이벤트 루프를 다음과 같이 정의한다\r\n\r\n> To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section.\\\r\n> Each agent has an associated event loop, which is unique to that agent.\r\n\r\n위의 문장을 해석하면 아래와 같다\r\n\r\n> 이벤트, 사용자와의 상호 작용, 스크립트의 실행, 화면 렌더링, 네트워킹 등을 조정하려면 유저 에이전트(웹 브라우저)는 이 절에 설명된 대로 이벤트 루프를 사용해야 한다.\\\r\n> 유저 에이전트는 각 에이전트 고유의 이벤트 루프를 가지고 있다.\r\n\r\n-- 참고 : whatwg.org",
      "html": "<h3 id=\"크로미움-웹브라우저에서-settimeout이-실행되는-과정\">크로미움 웹브라우저에서 setTimeout이 실행되는 과정</h3>\n<p>아래 코드는 setTimeout을 호출하는 코드이다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">&lt;script>\r\n   f1() ;\r\n\r\n   setTimeout(()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     return 1 ;\r\n   }\r\n&lt;/script>\r\n\n</code></pre>\n<p>브라우저 내부에서 위의 코드가 실행될 때 아래와 같은 루틴으로 처리된다.<br>\n<br>\n<code>&lt;script></code> 내부는 자바스크립트 코드로 이루어져 있고 이 코드는 웹브라우저의 렌더러 엔진이 단독으로 처리할 수 없다. 따라서 자바스크립트 가상 머신에게 script 내부의 처리를 요청한다.<br>\n<br>\n크로미움에서 해당 작업은 v8이라는 이름의 자바스크립트 가상머신이 수행한다.<br>\n<br>\nv8은 먼저 f1 함수를 호출한다. f1의 수행이 종료되면 이어서 setTimeout 함수를 호출한다.<br>\n<br>\nsetTimeout 함수를 호출한 주체는 v8 자바스크립트 엔진이지만 setTimeout은 v8에 구현되어 있지 않다.<br>\n<br>\nv8은 ECMAScript 스펙의 구현체이지만 setTimeout은 ECMAScript의 스펙에 정의되어 있지 않기 때문이다.<br>\n<br>\nsetTimeout은 WHATWG에서 관리하는 HTML Living Standard 스펙에 정의되어 있다<br>\n<code>([링크](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout))</code><br>\n<br>\n이처럼 WHATWG HTML Living Standard 스펙에 정의되어 있는 자바스크립트 함수를 Web API라고 한다<br>\n<br>\n이러한 WebAPI는 웹브라우저의 렌더러 엔진에 구현되어 있다. 크로미움의 렌더러 엔진을 블링크라고 한다.<br>\n<br>\nv8엔진은 Blink IDL이라는 인터페이스를 통하여 블링크 엔진 내부에 구현된 WebAPI 함수의 실제 구현체를 호출한다.<br>\n<br>\nsetTimeout의 실제 구현체는 블링크 엔진 내부에 있는 WindowOrWorkerGlobalScope클래스의 SetTimeout메소드에 정의되어 있다.<br>\n<br>\n자바스크립트 코드 내부에서 setTimeout을 호출하는 순간 자바스크립트 코드 실행부는 일시 중지되고 제어권은 블링크 엔진에게 이전된다.<br>\n<br>\n블링크 엔진 내부에서 setTimeout 함수의 루틴이 종료되면 리턴값인 타이머 ID를 v8에게 반환하면서 자바스크립트 코드 실행부가 작업을 재개한다.<br>\n<br>\n다음은 <code>WindowOrWorkerGlobalScope::SetTimeout</code> 메소드이다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int WindowOrWorkerGlobalScope::setTimeout(\r\n    ScriptState* script_state,\r\n    EventTarget&amp; event_target,\r\n    V8Function* handler,\r\n    int timeout,\r\n    const HeapVector&lt;ScriptValue>&amp; arguments) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  ExecutionContext* execution_context = event_target.GetExecutionContext();\r\n  if (!IsAllowed(execution_context, false, g_empty_string))\r\n    return 0;\r\n  auto* action = MakeGarbageCollected&lt;ScheduledAction>(\r\n      script_state, execution_context, handler, arguments);\r\n\r\n  return DOMTimer::Install(execution_context, action,\r\n                           base::TimeDelta::FromMilliseconds(timeout), true);\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc)</code><br>\n<br>\n위의 코드는 C++로 작성되었다. 이처럼 블링크 렌더러 엔진을 비롯한 대부분의 크로미움 소스는 C++로 작성되었다.<br>\n<br>\n위의 코드에서 마지막 return 직전에 호출되는 <code>DOMTimer::Install</code> 메소드는 타이머계열 메소드 (setInterval, setTimeout)의 수행에 사용된다. 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int DOMTimer::Install(ExecutionContext* context,\r\n                      ScheduledAction* action,\r\n                      base::TimeDelta timeout,\r\n                      bool single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  int timeout_id = context->Timers()->InstallNewTimeout(context, action,\r\n                                                        timeout, single_shot);\r\n  return timeout_id;\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.h)</code>\r\n<br>\n<code>DOMTimer::Install</code>메소드는 내부에서 <code>DOMTimerCoordinator</code> 인스턴스의 <code>InstallNewTimeout</code> 메소드를 호출한다.<br>\n<br>\n<code>DOMTimerCoordinator::InstallNewTimeout</code> 메소드는 실질적인 <code>setTimeout의</code> 구현체이다. 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">int DOMTimerCoordinator::InstallNewTimeout(ExecutionContext* context,\r\n                                           ScheduledAction* action,\r\n                                           base::TimeDelta timeout,\r\n                                           bool single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  // FIXME: DOMTimers depends heavily on ExecutionContext. Decouple them.\r\n  DCHECK_EQ(context->Timers(), this);\r\n  int timeout_id = NextID();\r\n  timers_.insert(timeout_id,\r\n                 MakeGarbageCollected&lt;DOMTimer>(context, action, timeout,\r\n                                                single_shot, timeout_id));\r\n  return timeout_id;\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer_coordinator.cc)</code><br>\n<br>\n<code>DOMTimerCoordinator::InstallNewTimeout</code> 메소드는 크게 2가지 작업을 수행한다.<br>\n<br>\n첫째로 콜백함수의 타이머 id를 생성한다. 이는 NextID() 메소드를 호출함으로서 수행된다.<br>\n<br>\n둘째로 콜백함수를 스케줄링한다. 해당 작업은 콜백함수를 테스크 큐에 삽입함으로서 수행된다. 테스크 큐라는 용어는 이벤트 루프에 대해 조사해 본 적이 있다면 들어본 적이 있을 것이다. 테스크 큐는 queue라는 자료구조의 구현체로서 수행할 테스크를 후입선출 방식으로 실행하는 자료구조를 의미한다. 여기에는 자바스크립트 <code>setTimeout</code> 함수의 첫번째 인자로 삽입된 콜백함수가 스케줄링된다.<br>\n<br>\n엄밀하게 이야기하면 콜백함수가 직접 스케줄링되지 않으며 콜백함수를 프로퍼티로 가진 DOMTimer 인스턴스가 스케줄링된다. 스케줄링되는 DOMTimer 인스턴스 내부에 setTimeout 콜백함수가 프로퍼티로 저장되어 있으며 이 프로퍼티의 이름은 action_이다.<br>\n<br>\n실제 테스크 수행시에는 최종적으로 해당 콜백함수가 실행된다.<br>\n<br>\n이 스케줄링 과정은 위의 <code>InstallNewTimeout</code> 메소드에서는 확인하기 어렵다. 위의 코드에서는 timers_.insert() 메소드를 호출하는 과정에서 두번째 인자로 DOMTimer 인스턴스가 전달되는 것을 확인할 수 있는데, 덕분에 timers_.insert() 를 호출하는 행위를 스케줄링 작업으로 오해할 수 있다. 사실 timers_ 는 자바스크립트에서 clearTimeout() 함수를 호출할 때 해당 테스크의 스케줄링을 취소하려는 목적으로 사용된다.<br>\n<br>\n실제 스케줄링 작업은 DOMTimer가 생성자를 호출할 때 이루어진다. DOMTimer 생성자의 내부로 진입해 보겠다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">DOMTimer::DOMTimer(ExecutionContext* context,\r\n                   ScheduledAction* action,\r\n                   base::TimeDelta timeout,\r\n                   bool single_shot,\r\n                   int timeout_id)\r\n    : ExecutionContextLifecycleObserver(context),\r\n      TimerBase(nullptr),\r\n      timeout_id_(timeout_id),\r\n      // Step 9:\r\n      nesting_level_(context->Timers()->TimerNestingLevel()),\r\n      action_(action) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  DCHECK_GT(timeout_id, 0);\r\n\r\n  // Step 10:\r\n  if (timeout &lt; base::TimeDelta())\r\n    timeout = base::TimeDelta();\r\n\r\n  // Steps 12 and 13:\r\n  // Note: The implementation increments the nesting level before using it to\r\n  // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n  IncrementNestingLevel();\r\n\r\n  // Step 11:\r\n  // Note: The implementation uses >= instead of >, contrary to what the spec\r\n  // requires crbug.com/1108877.\r\n  if (nesting_level_ >= kMaxTimerNestingLevel &amp;&amp; timeout &lt; kMinimumInterval)\r\n    timeout = kMinimumInterval;\r\n\r\n  // Select TaskType based on nesting level.\r\n  TaskType task_type;\r\n  if (timeout.is_zero()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerImmediate;\r\n    DCHECK_LT(nesting_level_, kMaxTimerNestingLevel);\r\n  } else if (nesting_level_ >= kMaxTimerNestingLevel) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerDelayedHighNesting;\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    task_type = TaskType::kJavascriptTimerDelayedLowNesting;\r\n  }\r\n  MoveToNewTaskRunner(context->GetTaskRunner(task_type));\r\n\r\n  if (single_shot) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    StartOneShot(timeout, FROM_HERE);\r\n  } else ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    // TODO(crbug.com/402694): Don't clamp interval timers to 1ms here\r\n    timeout = std::max(timeout, base::TimeDelta::FromMilliseconds(1));\r\n    StartRepeating(timeout, FROM_HERE);\r\n  }\r\n\r\n // ...\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/core/frame/dom_timer.cc )</code>\r\n<br>\n소스는 매우 장황하고 이해하기 어렵다. 돔타이머 생성자의 루틴은 크게 두가지 작업으로 나뉜다<br>\n<br>\n먼저 자바스크립트 setTimeout의 두번째 인자로 삽입된 timeout 수치를 재조정한다.<br>\n<br>\n그 이후 조정된 timeout수치를 참고하여 스케줄링을 수행한다.<br>\n<br>\n여기서 timeout수치를 재조정한다는 게 무슨 말인지 의아할 수 있다.<br>\n<br>\nsetTimeout함수는 유저가 입력한 timeout수치가 지나치게 낮으면 이를 재조정하도록 설계되어 있다.<br>\n<br>\n이 규칙은 WHATWG HTML Living Standard에 명시되어 있다 (<a href=\"html.spec.whatwg.org/multipage/timers-and-user-prompts.html\">링크</a>)<br>\n<br>\n위의 소스코드에서 Step 9, Step 10, Step 11 등의 주석을 확인할 수 있는데 이는 HTML 리빙 스탠다드에 명시되어 있는 타이머 초기화 스탭을 구현하는 것을 의미한다.<br>\n<br>\n예를 들어 스탭 11의 명세는 아래와 같다.</p>\n<blockquote>\n<p>If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.<br>\n(중첩 레벨이 5보다 크고 timeout수치가 4 미만인 경우, timeout수치를 4로 재조정한다)</p>\n</blockquote>\n<p>timeout 수치를 재조정 작업이 완료되면 스케줄링에 필요한 모든 작업이 완료되었고 소스의 아랫부분에서 확인할 수 있는 것처럼 StartOneShot 메소드를 호출한다. 이는 1회만 호출하는 원샷 타이머의 형태로 스케줄링을 진행하겠다는 뜻이다.<br>\n<br>\nStartOneShot 메소드 내부에서 몇번의 서브루틴이 있으며 최종적으로 TimerTaskRunner가 postDelayedTask메소드를 호출하여 콜백함수를 테스크 큐에 enqueue함으로서 스케줄링이 수행된다. 이는 아래 소스에서 확인할 수 있다\\</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void TimerBase::SetNextFireTime(base::TimeTicks now, base::TimeDelta delay) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n    //  ..생략\r\n\r\n    web_task_runner_->PostDelayedTask(\r\n        location_, BindTimerClosure(weak_ptr_factory_.GetWeakPtr()), delay);\r\n  }\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/timer.cc)</code><br>\n<br>\n위의 코드에서 PostDelayedTask 메소드의 첫번째 인자인 location_은 DOMTimer 인스턴스이며 해당 인스턴스에 setTimeout의 콜백함수가 저장되어 있다. 세번째 인자인 delay은 타이머 초기화 스탭으로 재조정된 timeout 수치이다.<br>\n<br>\nPostDelayedTask라는 용어에서 post는 테스크를 큐에 삽입하는 행위이고 DelayedTask는 해당 테스크가 시간차를 두고 실행되는 테스크라는 것을 의미한다.<br>\n<br>\n결론적으로 setTimeout의 콜백함수는 TimerTask로 분류되며 해당 테스크는 TimerTaskRunner 인스턴스가 컨트롤한다<br>\n<br>\n여기서 TimerTaskRunner 인스턴스가 컨트롤하는 테스크 큐를 Frame Throttleable 테스크 큐라고 부른다.<br>\n<br>\nFrame Throttleable 테스크 큐는 블링크 렌더러 엔진의 메인 스레드 스케줄러가 관리하는 약 19여개의 테스크 큐 중 하나로서 setInterval, setTimeout과 같은 자바스크립트 수준의 타이머를 관리한다.<br>\n<br>\n메인 스레드 스케줄러는 Frame Throttleable 테스크 큐 외에도 약 19여개의 테스크 큐를 관리한다.<br>\n<br>\n아래는 메인스레드 테스크 큐의 종류이다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum class QueueType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  kControl = 0,\r\n  kDefault = 1,\r\n  kFrameLoading = 5,\r\n  kCompositor = 8,\r\n  kIdle = 9,\r\n  kTest = 10,\r\n  kFrameLoadingControl = 11,\r\n  kFrameThrottleable = 12,\r\n  kFrameDeferrable = 13,\r\n  kFramePausable = 14,\r\n  kFrameUnpausable = 15,\r\n  kV8 = 16,\r\n  kInput = 18,\r\n  kDetached = 19,\r\n  kWebScheduling = 24,\r\n  kNonWaking = 25,\r\n  kIPCTrackingForCachedPages = 26,\r\n  kOther = 23,\r\n  kCount = 27\r\n};\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)</code><br>\n<br>\n위 코드에서 각 QueueType 에 할당된 정수는 코드 내부적으로 가독성을 올리기 위한 수단이며 테스크 우선순위와는 무관하다.<br>\n<br>\n물론 각 테스크 큐는 각자의 고유한 우선순위를 가지고 있다. 메인 스케줄러는 이러한 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다. 각 테스크 큐의 우선순위는 아래에서 설명하겠다.<br>\n<br>\n여기서부터 조금 더 깊이 들어가보겠다<br>\n<br>\nsetTimeout의 콜백함수가 스케줄링 되는 테스크 큐는 Frame Throttleable 테스크 큐 이지만 더 정확히 이야기하면 Frame Throttleable 테스크 큐 내부의 delayed_incoming_queue에 삽입된다.<br>\n<br>\n조금 혼란이 올 수가 있는데, 하나의 테스크 큐 내부에는 4가지 종류의 테스크 큐가 있다</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">1. immediate_incoming_queue\r\n2. immediate_work_queue\r\n3. delayed_incoming_queue\r\n4. delayed_work_queue\n</code></pre>\n<p>이 중 타이머 수행에는 앞에 delayed라는 이름이 붙여진 2개의 테스크 큐가 사용된다.<br>\n<br>\nsetTimeout의 콜백함수는 먼저 delayed_incoming_queue에 삽입된다.<br>\n<br>\ndelayed_incoming_queue는 유저가 인터벌 값으로 설정한 밀리세컨드 값을 참조하여 해당 콜백함수가 호출되는 시점이 되면 delayed_work_queue로 이전한다.<br>\n<br>\ndelayed_work_queue에 이전된 함수는 테스크를 수행할 준비가 되었다는 뜻이며 이는 블링크의 메인스레드 스케줄러에 의해 실행될 수 있다.<br>\n<br>\n이처럼 delayed_incoming_queue의 테스크를 delayed_work_queue로 옮기는 작업은 TimeDomain 클래스가 담당하며 TimeDomain 클래스가 UpdateDelayedWorkQueue메소드를 호출함으로서 이전이 수행된다. TimeDomain 클래스는 OS가 제공하는 시스템 틱 API를 호출하여 현재시간을 계산한다.<br>\n<br>\nwindows OS의 경우 시스템 틱을 호출하는 루틴은 time_win.cc에 정의되어 있다.<br>\n<br>\n여기까지가 setTimeout의 콜백함수를 스케줄링 하는 과정이었다. 다시 자바스크립트의 코드 실행부로 돌아가보겠다.</p>\n<pre class=\"language-html\" lang=\"html\"><code class=\"language-html\" lang=\"html\">   f1()\r\n\r\n   setTimeout(()=>ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     console.log('hi') ;\r\n   }, 1000) ;\r\n\r\n   function f1() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n     return 1\r\n   }\n</code></pre>\n<p>setTimeout의 호출이후 자바스크립트의 메인 프로그램이 종료된다. 메인 프로그램의 종료이후 제어권은 embedder(임베더)에게 이전된다.<br>\n<br>\n임베더는 자바스크립트의 코드실행을 호출한 주체를 일컫는 데 웹브라우저의 경우 임베더는 렌더러 엔진의 메인스레드이다.<br>\n즉 제어권이 렌더러 엔진인 블링크의 메인 스레드에게 이전된다. 제어권이 이전되면 렌더러 엔진은 자바스크립트의 마이크로테스크 큐를 실행할 조건이 되는지 검사한다.<br>\n<br>\n여기서 자바스크립트의 마이크로테스크 큐를 실행하는 주체가 자바스크립트 엔진이 아닌 자바스크립트 엔진의 임베더라는 사실을 알 수 있다.<br>\n<br>\n콜스택의 depth가 0인지를 체크하여 0이라면 마이크로테스크 큐가 소진될 때 까지 반복하여 마이크로테스크를 수행한다.<br>\n<br>\n마이크로테스크 작업이 모두 종료되면 블링크 메인스레드의 스케줄러가 스케줄링 정책에 입각하여 다음 테스크를 선택하는 루틴을 수행한다. 여기서부터 흔히 말하는 이벤트루프 단계가 수행된다.<br>\n<br>\n위에서 언급했듯이 메인스레드의 스케줄러는 여러가지 종류의 테스크 큐를 우선순위 정책에 입각하여 실행한다.<br>\n<br>\n여기서 우리는 setTimeout의 콜백함수가 스케줄링 되어있는 Frame Throttleable 테스크 큐가 언제 실행되는지에 관심이 있다.<br>\n<br>\nFrame Throttleable 테스크 큐의 우선순위는 0~11까지 책정되어 있는 우선순위 값 중 7이다. 숫자값이 클수록 우선순위가 높다.</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">enum class PrioritisationType ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n  kInternalScriptContinuation = 0,\r\n  kBestEffort = 1,\r\n  kRegular = 2,\r\n  kLoading = 3,\r\n  kLoadingControl = 4,\r\n  kFindInPage = 5,\r\n  kExperimentalDatabase = 6,\r\n  kJavaScriptTimer = 7,\r\n  kHighPriorityLocalFrame = 8,\r\n  kCompositor = 9,  // Main-thread only.\r\n  kInput = 10,\r\n\r\n  kCount = 11\r\n};\n</code></pre>\n<p><code>(third_party/blink/renderer/platform/scheduler/main_thread/main_thread_task_queue.h)</code><br>\n<br>\n위의 코드에서 <code>kJavaScriptTimer는</code> <code>Frame Throttleable 테스크 큐</code>의 우선순위이다.<br>\n<br>\n따라서 값이 7보다 높은 테스크 큐에 예약된 테스크가 이미 존재하는 상황에서는 setTimeout의 콜백함수는 영원히 실행되지 않는다.<br>\n<br>\n이런 상황을 기아상태라고 한다.<br>\n<br>\n우선순위가 7보다 높은 테스크 큐에는 컴포지터 테스크 큐와 유저인풋 테스크 큐 등이 존재한다.<br>\n<br>\n만일 우선순위가 7보다 높은 테스크 큐에 테스크가 없다면 <code>Frame Throttleable 테스크 큐</code> 내부의 <code>immediate_work_queue</code>와 <code>delayed_work_queue</code>에 수행할 테스크가 존재하는지 체크한다.<br>\n<br>\n만일 테스크가 존재한다면 해당 테스크를 수행한다.<br>\n<br>\n만일 존재하지 않는다면 우선순위가 7보다 낮은 테스크 큐에 테스크가 존재하는지 체크한다.<br>\n<br>\n블링크의 테스크 스케줄링은 위와 같은 방식으로 수행된다. 이것이 흔히 말하는 이벤트 루프의 민낯이다.<br>\n<br>\n1000ms가 지나서 <code>delayed_work_queue</code>에 수행할 테스크가 적재되었다면 스케줄러는 해당 테스크를 수행한다.<br>\n<br>\n위에서 setTimeout의 콜백함수는 DOMTimer 인스턴스의 형태로 스케줄링 된다고 언급하였다.<br>\n<br>\nDOMTimer는 Fired 메소드를 호출하여 해당 콜백함수가 트리거 됨을 알린다. Fired 메소드의 코드는 아래와 같다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">\r\nvoid DOMTimer::Fired() ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n\r\n  // Simple case for non-one-shot timers.\r\n  if (IsActive()) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n    DCHECK(is_interval);\r\n\r\n    // Steps 12 and 13:\r\n    // Note: The implementation increments the nesting level before using it to\r\n    // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n    IncrementNestingLevel();\r\n\r\n    // Make adjustments when the nesting level becomes >= |kMaxNestingLevel|.\r\n    // Note: The implementation uses >= instead of >, contrary to what the spec\r\n    // requires crbug.com/1108877.\r\n    if (nesting_level_ == kMaxTimerNestingLevel) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n      // Move to the TaskType that corresponds to nesting level >=\r\n      // |kMaxNestingLevel|.\r\n      MoveToNewTaskRunner(\r\n          context->GetTaskRunner(TaskType::kJavascriptTimerDelayedHighNesting));\r\n      // Step 11:\r\n      if (RepeatInterval() &lt; kMinimumInterval)\r\n        AugmentRepeatInterval(kMinimumInterval - RepeatInterval());\r\n    }\r\n\r\n    DCHECK(nesting_level_ &lt; kMaxTimerNestingLevel ||\r\n           RepeatInterval() >= kMinimumInterval);\r\n\r\n    // No access to member variables after this point, it can delete the timer.\r\n    action_->Execute(context);\r\n\r\n    context->Timers()->SetTimerNestingLevel(0);\r\n\r\n    return;\r\n  }\n</code></pre>\n<p>여전히 소스는 장황하고 이해하기 어렵다. 맨 아래에서 세번째 명령어인 <code>action_->Execute(context) ;</code> 부분은 실질적인 콜백함수의 호출로 이어진다. action_ 프로퍼티는 <code>ScheduledAction</code> 클래스의 인스턴스인데 해당 인스턴스는 V8 엔진과 블링크 렌더러 엔진의 브릿지 역할을 수행한다</p>\n<pre class=\"language-cpp\" lang=\"cpp\"><code class=\"language-cpp\" lang=\"cpp\">void ScheduledAction::Execute(ExecutionContext* context) ASTRO_ESCAPED_LEFT_CURLY_BRACKET\u0000\r\n\r\n  // .. 생략\r\n  script->RunScriptOnScriptStateAndReturnValue(script_state_->Get());\r\n}\n</code></pre>\n<p><code>(third_party/blink/renderer/bindings/core/v8/scheduled_action.cc)</code><br>\n<br>\n위의 소스코드에서 <code>RunScriptOnScriptStateAndReturnValue</code> 메소드는 직접적인 스크립트의 수행을 V8에게 요청한다.<br>\n<br>\n이 작업은 <code>V8ScriptRunner</code>클래스가 <code>CallFunction</code>을 호출하여 수행된다.<br>\n<br>\n이로서 자바스크립트 엔진에게 제어권이 넘어가게 되고 setTimeout의 첫번째 인자인 콜백 함수가 호출된다.<br>\n<br>\n이로서 setTimeout의 실행 사이클은 종료된다<br>\n<br>\n위와 같은 사실로부터 몇가지 사실을 도출할 수 있다.\\</p>\n<blockquote>\n<p>첫번째, 렌더러 엔진 내부에서 렌더링 과정의 수행과 자바스크립트 코드 실행은 같은 스레드에서 수행된다.<br>\n두번째, 마이크로테스크 큐의 실행은 렌더러 엔진의 스케줄링 과정에 포함되어 있지 않다.<br>\n세번째, 자바스크립트 코드로 호출 가능한 WebAPI는 자바스크립트 엔진 내부에 구현되어 있지 않으며 렌더러 엔진에 구현되어 있다</p>\n</blockquote>\n<p>따라서 WebAPI는 렌더러 엔진을 구현한 프로그래밍 언어로 실행된다. 크로미움의 경우 WebAPI는 C++ 코드로 실행된다.<br>\n<br>\n네번째, 이벤트 루프는 자바스크립트 코드를 수행하는 것을 포함하여 더 넒은 범위의 테스크를 포함한다.<br>\n<br>\n이러한 이벤트 루프는 렌더러의 메인 스레드 내부의 스케줄링 정책에 의해 수행된다.<br>\n<br>\nHTML Living Standard는 이벤트 루프를 다음과 같이 정의한다</p>\n<blockquote>\n<p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section.<br>\nEach agent has an associated event loop, which is unique to that agent.</p>\n</blockquote>\n<p>위의 문장을 해석하면 아래와 같다</p>\n<blockquote>\n<p>이벤트, 사용자와의 상호 작용, 스크립트의 실행, 화면 렌더링, 네트워킹 등을 조정하려면 유저 에이전트(웹 브라우저)는 이 절에 설명된 대로 이벤트 루프를 사용해야 한다.<br>\n유저 에이전트는 각 에이전트 고유의 이벤트 루프를 가지고 있다.</p>\n</blockquote>\n<p>— 참고 : whatwg.org</p>"
    },
    "url": "/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95",
    "file": new URL("file:///H:/project/site/myblog_astro/src/pages/posts/210428_%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%9B%80%EC%97%90%EC%84%9C_setTimeout%EC%9D%B4_%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94_%EA%B3%BC%EC%A0%95.md")
  }
}, children);

});
</script><hr class="astro-ldKR6c5M"><p class="astro-ldKR6c5M"><a href="/aboutme" class="astro-ldKR6c5M">주인장 소개</a></p><p class="astro-ldKR6c5M"><a href="https://devkr.info" class="astro-ldKR6c5M">devkr.info로 가기</a></p><p class="astro-ldKR6c5M"><a href="/en" class="astro-ldKR6c5M">go english page</a></p><hr class="astro-ldKR6c5M"><footer class="astro-ldKR6c5M">powered by 
          <svg class="logo astro-RnEq1mMV astro-ldKR6c5M" height="1em" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><style type="text/css">
            #flame.astro-RnEq1mMV.astro-ldKR6c5M {
              fill: #ff5d01;
            }
            #a.astro-RnEq1mMV.astro-ldKR6c5M {
              fill: white;
            }
          </style><title>Astro</title><path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z" class="astro-RnEq1mMV astro-ldKR6c5M"></path><path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z" class="astro-RnEq1mMV astro-ldKR6c5M"></path></svg>
        , github pages
    </footer></div></body></html>