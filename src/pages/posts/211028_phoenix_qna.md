---
title: '엘릭서의 피닉스 프레임워크 FAQ'
description: "피닉스 프레임워크에 대해 흔하게 물어보는 질문들과 그 답변들"
publishDate: '2021.11.03'
# author: 'lkb'
# heroImage: ''
# alt: 'Astro'
layout: '../../components/pages/post/BlogPost.astro'

---

# 엘릭서의 피닉스 프레임워크 FAQ

Q. 피닉스란 무엇인가?\
A. 피닉스는 엘릭서의 웹서버 프레임워크 이다\
\
Q. 피닉스는 누가 만들었나?\
A. 피닉스는 크리스 맥코드가 만들었다. 그는 원래 루비온레일즈로 개발하던 서버 개발자였다. 그는 레일즈에서 `서버기반 상태관리`를 하고 싶었고 실제로 라이브러리까지 만들어가면서 방법을 연구했다. 하지만 루비라는 언어 및 레일즈라는 프레임워크가 제공하는 동시성 수준으로는 한계가 있었고 여러 상황에서 제대로 작동하지 않았던 것이다. 그는 결국 루비온레일즈를 떠났고 높은 수준의 동시성을 제공해주는 환경을 찾다가 결국 엘릭서 생태계로 이전한다. 그리고 나서 결국 웹서버 프레임워크인 피닉스를 만들게 된 것이다.\
[출처 : 해커뉴스 rkangel](https://news.ycombinator.com/item?id=25105581)\
\
Q. 피닉스는 어떤 특징이 있는가?\
A. 위에서 언급했던 대로 피닉스는 `서버기반 상태관리`를 하려다가 좌절한 개발자가 만든 웹 프레임워크다. 따라서 `서버기반 상태관리` 기능을 제공한다. 이를 피닉스 라이브뷰라고 한다\
\
Q. 웹페이지에서 페이지의 상태를 관리하는 기능은 리액트나 뷰 등의 UI 프레임워크가 제공하던 기능이 아닌가 ?\
A. 그렇다. 하지만 리액트나 뷰 등을 사용하는 것은 너무 많은 지식을 필요로 한다. 기술이 빠르게 바뀌고 새로운 라이브러리가 계속 등장하고 새로운 프레임워크도 계속 등장한다. 이것을 계속 따라가는 것은 피곤한 일이다. 하지만 `서버기반 상태관리`에 의존하면 이런 기술들을 계속 쫒아갈 필요가 없다. 그저 엘릭서와 피닉스에 대한 지식만으로도 SPA 웹사이트를 만들 수 있는 것이다. 자바스크립트를 단 한줄도 작성할 필요가 없다\
\
Q. 라이브뷰가 어떤 방식으로 `서버기반 상태관리 기능`을 제공하길래 자바스크립트를 한 줄도 작성할 필요가 없는가?\
A. 라이브뷰는 두가지로 이루어진다. 먼저 `템플릿 기반의 html 코드`이다. 이것은 다른 프레임워크도 흔하게 제공하는 기능이다. 두번째로 `이벤트 처리기`이다. 이벤트 처리기란 웹소켓을 통하여 클라이언트와 서버가 교신하는 모델이다. 클라이언트에게 이벤트가 발생하면 그 이벤트는 서버로 전송된다. 서버는 그 이벤트를 받아서 현재 `서버에 저장된 상태를 기준으로` 재랜더링(re-render)을 수행한다. 재랜더링을 수행하는 과정에서 diff알고리즘으로 이전 랜더링과의 차이점을 분석하고 변경된 사항만을 클라이언트에게 전송한다. 이것이 라이브뷰의 핵심이다\
\
Q. 서버가 상태를 가지고 있고 렌더링도 수행한다면 이건 `서버에서 작동하는 리액트`가 아닌가?\
A. 그렇게 볼 수도 있다. 다만 소위 말하는 `서버에서 작동하는 리액트`를 구현하기 위해 당신은 자바스크립트를 사용할 필요가 없다. 당연하게도 피닉스 프레임워크는 자바스크립트 기반으로 작동하는 서버가 아닌 엘릭서 기반의 서버이기 때문이다. 따라서 당신은 엘릭서와 자바스크립트 두가지 언어를 모두 알 필요가 없으며 엘릭서만 알아도 클라와 서버를 모두 만들 수 있다.\
\
Q. 클라이언트에서 이벤트가 발생할 때마다 서버에게 메시지를 보낸다면 서버에 너무 과부하가 몰리는 건 아닌가 ?\
A. 맞는 말이다. 수십만 수백만 클라이언트와 웹소켓으로 연결되어 실시간으로 메시지가 오간다면 이는 필연적으로 과부하를 야기한다. 하지만 피닉스는 엘릭서 기반이고 엘릭서는 높은 수준의 병렬성을 제공한다. 엘릭서의 창시자 호세 발림에 의하면 그는 루비온레일즈로 100개의 서버가 필요했던 환경에서 엘릭서로 이전하고 난 뒤에는 2개의 서버 만으로 감당할 수 있었다고 한다. 이렇게 극적으로 서버 갯수를 줄일 수 있었던 배경에는 엘릭서가 제공하는 높은 수준의 동시성이 있었기 때문이다.\
\
Q. `서버기반 상태관리`를 제공하는 프레임워크가 피닉스 뿐인가?\
A. 아니다. 웬만한 언어별로 `서버기반 상태관리` 라이브러리가 있다. 자세한 내용은 [여기](https://github.com/dbohdan/liveviews)에서 참조할 수 있다\
\
Q. 그렇다면 굳이 피닉스 프레임워크를 고집할 이유가 없는 것인가?\
A. 엄밀히 말하면 `서버기반 상태관리`는 엘릭서만의 전유물은 아니다. 하지만 위에서 말했듯이 엘릭서의 엑터 모델은 모든 언어를 통틀어 최고수준의 동시성을 보장한다. 따라서 서버기반 상태관리에 최적화 되어있는 언어라고 볼 수 있을것이다.\
\
Q. `서버기반 상태관리`외에 피닉스의 장점이 있는가?\
A. 그렇다. 피닉스는 PubSub모델을 제공한다\
\
Q. PubSub 모델이 뭔가?\
A. 어떤 클러스터 내에 누가 접속했고 누가 연결을 끊었는지 알수있는 매커니즘이라고 한다\
\
Q. 그게 왜 좋은가?\
A. 분산 컴퓨팅을 할 수 있기 때문이다. 어떤 서버에서 hello_world라는 함수를 실행하도록 요청받았는데 그런 함수가 구현되어 있지 않다면? 클러스터 내에 연결되어 있는 다른 노드에 대신 수행해 달라고 요청하면 된다. 다시말해 피닉스는 분산 컴퓨팅에 특화되어 있다

---

#### 약간 심화내용

Q. 라이브뷰는 구체적으로 어떻게 구현되었는가 ?\
A. 먼저 라이브뷰가 비헤이비어 라는것을 이해해야 한다. 비헤이비어가 낮설다면 일종의 추상 클래스라고 이해해도 좋다. 비헤이비어는 특정한 함수들을 구현할 것을 강제하는데 이런 함수들을 함수 시그니처에 맞추어 구현하는 것이 비헤이비어의 존재 의의이다. 따라서 비헤이비어를 일종의 인터페이스라고 이해해도 좋다. 이렇게 구현된 함수들은 하나의 웹페이지에서 페이지의 상태를 관리하고 렌더링을 수행한다\
\
Q. 라이브뷰가 비헤이비어이고 비헤이비어가 특정 함수의 구현을 강제하는 것은 알겠다. 그러면 라이브뷰는 어떤 함수의 구현을 강제하는가?\
A. 라이브뷰는 웹소켓 기반의 메시지 통신을 구현할 것을 강제한다. 왜냐하면 클라이언트가 서버에게 이벤트의 발생을 알릴 때 웹소켓을 사용하기 때문이다
